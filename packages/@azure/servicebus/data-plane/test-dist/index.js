'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var debugModule = _interopDefault(require('debug'));
var tslib_1 = require('tslib');
var os = require('os');
var amqpCommon = require('@azure/amqp-common');
var rheaPromise = require('rhea-promise');
var Long = _interopDefault(require('long'));
var util = require('util');
var msRestNodeAuth = require('@azure/ms-rest-nodeauth');
var armServicebus = require('@azure/arm-servicebus');
var msRestAzure = require('ms-rest-azure');

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
}
/*!
 * Primary Exports
 */

var assertionError = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || AssertionError;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    try {
      throw new Error();
    } catch(e) {
      this.stack = e.stack;
    }
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */

function hasProperty(obj, name) {
  if (typeof obj === 'undefined' || obj === null) {
    return false;
  }

  // The `in` operator does not work with primitives.
  return name in Object(obj);
}

/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `internalGetPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath(path$$1) {
  var str = path$$1.replace(/([^\\])\[/g, '$1.[');
  var parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function mapMatches(value) {
    var regexp = /^\[(\d+)\]$/;
    var mArr = regexp.exec(value);
    var parsed = null;
    if (mArr) {
      parsed = { i: parseFloat(mArr[1]) };
    } else {
      parsed = { p: value.replace(/\\([.\[\]])/g, '$1') };
    }

    return parsed;
  });
}

/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from `parsePath`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */

function internalGetPathValue(obj, parsed, pathDepth) {
  var temporaryValue = obj;
  var res = null;
  pathDepth = (typeof pathDepth === 'undefined' ? parsed.length : pathDepth);

  for (var i = 0; i < pathDepth; i++) {
    var part = parsed[i];
    if (temporaryValue) {
      if (typeof part.p === 'undefined') {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }

      if (i === (pathDepth - 1)) {
        res = temporaryValue;
      }
    }
  }

  return res;
}

/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for `parsePath` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from `parsePath`
 * @api private
 */

function internalSetPathValue(obj, val, parsed) {
  var tempObj = obj;
  var pathDepth = parsed.length;
  var part = null;
  // Here we iterate through every part of the path
  for (var i = 0; i < pathDepth; i++) {
    var propName = null;
    var propVal = null;
    part = parsed[i];

    // If it's the last part of the path, we set the 'propName' value with the property name
    if (i === (pathDepth - 1)) {
      propName = typeof part.p === 'undefined' ? part.i : part.p;
      // Now we set the property with the name held by 'propName' on object with the desired val
      tempObj[propName] = val;
    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
      tempObj = tempObj[part.p];
    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
      tempObj = tempObj[part.i];
    } else {
      // If the obj doesn't have the property we create one with that name to define it
      var next = parsed[i + 1];
      // Here we set the name of the property which will be defined
      propName = typeof part.p === 'undefined' ? part.i : part.p;
      // Here we decide if this property will be an array or a new object
      propVal = typeof next.p === 'undefined' ? [] : {};
      tempObj[propName] = propVal;
      tempObj = tempObj[propName];
    }
  }
}

/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

function getPathInfo(obj, path$$1) {
  var parsed = parsePath(path$$1);
  var last = parsed[parsed.length - 1];
  var info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed),
  };
  info.exists = hasProperty(info.parent, info.name);

  return info;
}

/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */

function getPathValue(obj, path$$1) {
  var info = getPathInfo(obj, path$$1);
  return info.value;
}

/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * ```js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * ```
 *
 * The following would be acceptable.
 *
 * ```js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * ```
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */

function setPathValue(obj, path$$1, val) {
  var parsed = parsePath(path$$1);
  internalSetPathValue(obj, val, parsed);
  return obj;
}

var pathval = {
  hasProperty: hasProperty,
  getPathInfo: getPathInfo,
  getPathValue: getPathValue,
  setPathValue: setPathValue,
};

/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */

var flag = function flag(obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */



/**
 * ### .test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

var test = function test(obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

var typeDetect = createCommonjsModule(function (module, exports) {
(function (global, factory) {
	module.exports = factory();
}(commonjsGlobal, (function () {
/* !
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var promiseExists = typeof Promise === 'function';

/* eslint-disable no-undef */
var globalObject = typeof self === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist

var symbolExists = typeof Symbol !== 'undefined';
var mapExists = typeof Map !== 'undefined';
var setExists = typeof Set !== 'undefined';
var weakMapExists = typeof WeakMap !== 'undefined';
var weakSetExists = typeof WeakSet !== 'undefined';
var dataViewExists = typeof DataView !== 'undefined';
var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
var toStringLeftSliceLength = 8;
var toStringRightSliceLength = -1;
/**
 * ### typeOf (obj)
 *
 * Uses `Object.prototype.toString` to determine the type of an object,
 * normalising behaviour across engine versions & well optimised.
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */
function typeDetect(obj) {
  /* ! Speed optimisation
   * Pre:
   *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
   *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
   *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
   *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
   *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
   * Post:
   *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
   *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
   *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
   *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
   *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
   */
  var typeofObj = typeof obj;
  if (typeofObj !== 'object') {
    return typeofObj;
  }

  /* ! Speed optimisation
   * Pre:
   *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
   * Post:
   *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
   */
  if (obj === null) {
    return 'null';
  }

  /* ! Spec Conformance
   * Test: `Object.prototype.toString.call(window)``
   *  - Node === "[object global]"
   *  - Chrome === "[object global]"
   *  - Firefox === "[object Window]"
   *  - PhantomJS === "[object Window]"
   *  - Safari === "[object Window]"
   *  - IE 11 === "[object Window]"
   *  - IE Edge === "[object Window]"
   * Test: `Object.prototype.toString.call(this)``
   *  - Chrome Worker === "[object global]"
   *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
   *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
   *  - IE 11 Worker === "[object WorkerGlobalScope]"
   *  - IE Edge Worker === "[object WorkerGlobalScope]"
   */
  if (obj === globalObject) {
    return 'global';
  }

  /* ! Speed optimisation
   * Pre:
   *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
   * Post:
   *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
   */
  if (
    Array.isArray(obj) &&
    (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))
  ) {
    return 'Array';
  }

  // Not caching existence of `window` and related properties due to potential
  // for `window` to be unset before tests in quasi-browser environments.
  if (typeof window === 'object' && window !== null) {
    /* ! Spec Conformance
     * (https://html.spec.whatwg.org/multipage/browsers.html#location)
     * WhatWG HTML$7.7.3 - The `Location` interface
     * Test: `Object.prototype.toString.call(window.location)``
     *  - IE <=11 === "[object Object]"
     *  - IE Edge <=13 === "[object Object]"
     */
    if (typeof window.location === 'object' && obj === window.location) {
      return 'Location';
    }

    /* ! Spec Conformance
     * (https://html.spec.whatwg.org/#document)
     * WhatWG HTML$3.1.1 - The `Document` object
     * Note: Most browsers currently adher to the W3C DOM Level 2 spec
     *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
     *       which suggests that browsers should use HTMLTableCellElement for
     *       both TD and TH elements. WhatWG separates these.
     *       WhatWG HTML states:
     *         > For historical reasons, Window objects must also have a
     *         > writable, configurable, non-enumerable property named
     *         > HTMLDocument whose value is the Document interface object.
     * Test: `Object.prototype.toString.call(document)``
     *  - Chrome === "[object HTMLDocument]"
     *  - Firefox === "[object HTMLDocument]"
     *  - Safari === "[object HTMLDocument]"
     *  - IE <=10 === "[object Document]"
     *  - IE 11 === "[object HTMLDocument]"
     *  - IE Edge <=13 === "[object HTMLDocument]"
     */
    if (typeof window.document === 'object' && obj === window.document) {
      return 'Document';
    }

    if (typeof window.navigator === 'object') {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
       *  - IE <=10 === "[object MSMimeTypesCollection]"
       */
      if (typeof window.navigator.mimeTypes === 'object' &&
          obj === window.navigator.mimeTypes) {
        return 'MimeTypeArray';
      }

      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
       * Test: `Object.prototype.toString.call(navigator.plugins)``
       *  - IE <=10 === "[object MSPluginsCollection]"
       */
      if (typeof window.navigator.plugins === 'object' &&
          obj === window.navigator.plugins) {
        return 'PluginArray';
      }
    }

    if ((typeof window.HTMLElement === 'function' ||
        typeof window.HTMLElement === 'object') &&
        obj instanceof window.HTMLElement) {
      /* ! Spec Conformance
      * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
      * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
      * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
      *  - IE <=10 === "[object HTMLBlockElement]"
      */
      if (obj.tagName === 'BLOCKQUOTE') {
        return 'HTMLQuoteElement';
      }

      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('td'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */
      if (obj.tagName === 'TD') {
        return 'HTMLTableDataCellElement';
      }

      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('th'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */
      if (obj.tagName === 'TH') {
        return 'HTMLTableHeaderCellElement';
      }
    }
  }

  /* ! Speed optimisation
  * Pre:
  *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
  *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
  *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
  *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
  *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
  *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
  *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
  *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
  *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
  * Post:
  *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
  *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
  *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
  *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
  *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
  *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
  *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
  *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
  *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
  */
  var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);
  if (typeof stringTag === 'string') {
    return stringTag;
  }

  var objPrototype = Object.getPrototypeOf(obj);
  /* ! Speed optimisation
  * Pre:
  *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
  *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
  * Post:
  *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
  *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
  */
  if (objPrototype === RegExp.prototype) {
    return 'RegExp';
  }

  /* ! Speed optimisation
  * Pre:
  *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
  * Post:
  *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
  */
  if (objPrototype === Date.prototype) {
    return 'Date';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
   * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
   * Test: `Object.prototype.toString.call(Promise.resolve())``
   *  - Chrome <=47 === "[object Object]"
   *  - Edge <=20 === "[object Object]"
   *  - Firefox 29-Latest === "[object Promise]"
   *  - Safari 7.1-Latest === "[object Promise]"
   */
  if (promiseExists && objPrototype === Promise.prototype) {
    return 'Promise';
  }

  /* ! Speed optimisation
  * Pre:
  *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
  * Post:
  *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
  */
  if (setExists && objPrototype === Set.prototype) {
    return 'Set';
  }

  /* ! Speed optimisation
  * Pre:
  *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
  * Post:
  *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
  */
  if (mapExists && objPrototype === Map.prototype) {
    return 'Map';
  }

  /* ! Speed optimisation
  * Pre:
  *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
  * Post:
  *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
  */
  if (weakSetExists && objPrototype === WeakSet.prototype) {
    return 'WeakSet';
  }

  /* ! Speed optimisation
  * Pre:
  *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
  * Post:
  *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
  */
  if (weakMapExists && objPrototype === WeakMap.prototype) {
    return 'WeakMap';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
   * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
   * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
   *  - Edge <=13 === "[object Object]"
   */
  if (dataViewExists && objPrototype === DataView.prototype) {
    return 'DataView';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
   * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
   * Test: `Object.prototype.toString.call(new Map().entries())``
   *  - Edge <=13 === "[object Object]"
   */
  if (mapExists && objPrototype === mapIteratorPrototype) {
    return 'Map Iterator';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
   * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
   * Test: `Object.prototype.toString.call(new Set().entries())``
   *  - Edge <=13 === "[object Object]"
   */
  if (setExists && objPrototype === setIteratorPrototype) {
    return 'Set Iterator';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
   * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
   * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
   *  - Edge <=13 === "[object Object]"
   */
  if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
    return 'Array Iterator';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
   * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
   * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
   *  - Edge <=13 === "[object Object]"
   */
  if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
    return 'String Iterator';
  }

  /* ! Speed optimisation
  * Pre:
  *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
  * Post:
  *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
  */
  if (objPrototype === null) {
    return 'Object';
  }

  return Object
    .prototype
    .toString
    .call(obj)
    .slice(toStringLeftSliceLength, toStringRightSliceLength);
}

return typeDetect;

})));
});

/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */





var expectTypes = function expectTypes(obj, types) {
  var flagMsg = flag(obj, 'message');
  var ssfi = flag(obj, 'ssfi');

  flagMsg = flagMsg ? flagMsg + ': ' : '';

  obj = flag(obj, 'object');
  types = types.map(function (t) { return t.toLowerCase(); });
  types.sort();

  // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'
  var str = types.map(function (t, index) {
    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');

  var objType = typeDetect(obj).toLowerCase();

  if (!types.some(function (expected) { return objType === expected; })) {
    throw new assertionError(
      flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given',
      undefined,
      ssfi
    );
  }
};

/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */

var getActual = function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns `null`.
 * This also includes a polyfill function if `aFunc.name` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */

var toString = Function.prototype.toString;
var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;
function getFuncName(aFunc) {
  if (typeof aFunc !== 'function') {
    return null;
  }

  var name = '';
  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
    var match = toString.call(aFunc).match(functionNameMatch);
    if (match) {
      name = match[1];
    }
  } else {
    // If we've got a `name` property we just use it
    name = aFunc.name;
  }

  return name;
}

var getFuncName_1 = getFuncName;

/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */

var getProperties = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */

var getEnumerableProperties = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

var config = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

  includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40,

  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */

  useProxy: true,

  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */

  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']
};

var inspect_1 = createCommonjsModule(function (module, exports) {
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js






module.exports = inspect;

/**
 * ### .inspect(obj, [showHidden], [depth], [colors])
 *
 * Echoes the value of a value. Tries to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects. Default is false.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 * @namespace Utils
 * @name inspect
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      'nodeType' in object &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If this is a DOM element, try to get the outer HTML.
  if (isDOMElement(value)) {
    if ('outerHTML' in value) {
      return value.outerHTML;
      // This value does not have an outerHTML attribute,
      //   it could still be an XML element
    } else {
      // Attempt to serialize it
      try {
        if (document.xmlVersion) {
          var xmlSerializer = new XMLSerializer();
          return xmlSerializer.serializeToString(value);
        } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
          var ns = "http://www.w3.org/1999/xhtml";
          var container = document.createElementNS(ns, '_');

          container.appendChild(value.cloneNode(false));
          var html = container.innerHTML
            .replace('><', '>' + value.innerHTML + '<');
          container.innerHTML = '';
          return html;
        }
      } catch (err) {
        // This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
      }
    }
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  var name, nameSuffix;

  // Some type of object without properties can be shortcut.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      name = getFuncName_1(value);
      nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = ''
    , array = false
    , typedArray = false
    , braces = ['{', '}'];

  if (isTypedArray(value)) {
    typedArray = true;
    braces = ['[', ']'];
  }

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    name = getFuncName_1(value);
    nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else if (typedArray) {
    return formatTypedArray(value);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      if (value === 0 && (1/value) === -Infinity) {
        return ctx.stylize('-0', 'number');
      }
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');

    case 'symbol':
      return ctx.stylize(value.toString(), 'symbol');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}

function formatTypedArray(value) {
  var str = '[ ';

  for (var i = 0; i < value.length; ++i) {
    if (str.length >= config.truncateThreshold - 7) {
      str += '...';
      break;
    }
    str += value[i] + ', ';
  }
  str += ' ]';

  // Removing trailing `, ` if the array was not truncated
  if (str.indexOf(',  ]') !== -1) {
    str = str.replace(',  ]', ' ]');
  }

  return str;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name;
  var propDescriptor = Object.getOwnPropertyDescriptor(value, key);
  var str;

  if (propDescriptor) {
    if (propDescriptor.get) {
      if (propDescriptor.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (propDescriptor.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function(prev, cur) {
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isTypedArray(ar) {
  // Unfortunately there's no way to check if an object is a TypedArray
  // We have to check if it's one of these types
  return (typeof ar === 'object' && /\w+Array]$/.test(objectToString(ar)));
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
});

/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */




/**
 * ### .objDisplay(object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

var objDisplay = function objDisplay(obj) {
  var str = inspect_1(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */



/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

var getMessage = function getMessage(obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  if(typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg
    .replace(/#\{this\}/g, function () { return objDisplay(val); })
    .replace(/#\{act\}/g, function () { return objDisplay(actual); })
    .replace(/#\{exp\}/g, function () { return objDisplay(expected); });

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, `lockSsfi`,
 * and `message`) will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAssertion = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */

var transferFlags = function transferFlags(assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

/* globals Symbol: false, Uint8Array: false, WeakMap: false */
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


function FakeMap() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}

FakeMap.prototype = {
  get: function getMap(key) {
    return key[this._key];
  },
  set: function setMap(key, value) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value,
        configurable: true,
      });
    }
  },
};

var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);
    if (typeof result === 'boolean') {
      return result;
    }
  }
  return null;
}

/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}

/*!
 * Primary Export
 */

var deepEql = deepEqual;
var MemoizeMap_1 = MemoizeMap;

/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */
function deepEqual(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
  if (simpleResult !== null) {
    return simpleResult;
  }

  // Deeper comparisons are pushed through to a larger function
  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}

/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */
function simpleEqual(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  }

  // handle NaN cases
  if (
    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
    return true;
  }

  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.
  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }
  return null;
}

/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator;

  // Check if a memoized result exists.
  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }
  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  }

  // If a comparator is present, use it.
  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
    // Comparators may return null, in which case we want to go back to default behavior.
    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    }
    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect(leftHandOperand);
  if (leftHandType !== typeDetect(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  }

  // Temporarily set the operands in the memoize object to prevent blowing the stack
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);

  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;
    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual(leftHandOperand, rightHandOperand, options);
    case 'RegExp':
      return regexpEqual(leftHandOperand, rightHandOperand);
    case 'Generator':
      return generatorEqual(leftHandOperand, rightHandOperand, options);
    case 'DataView':
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
    case 'ArrayBuffer':
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
    case 'Set':
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case 'Map':
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}

/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */

function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}

/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */

function entriesEqual(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }
  if (leftHandOperand.size === 0) {
    return true;
  }
  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([ key, value ]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([ key, value ]);
  });
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}

/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */

function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;
  if (length !== rightHandOperand.length) {
    return false;
  }
  if (length === 0) {
    return true;
  }
  var index = -1;
  while (++index < length) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }
  return true;
}

/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */

function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}

/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */
function hasIteratorFunction(target) {
  return typeof Symbol !== 'undefined' &&
    typeof target === 'object' &&
    typeof Symbol.iterator !== 'undefined' &&
    typeof target[Symbol.iterator] === 'function';
}

/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */
function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }
  return [];
}

/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */
function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [ generatorResult.value ];
  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }
  return accumulator;
}

/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */
function getEnumerableKeys(target) {
  var keys = [];
  for (var key in target) {
    keys.push(key);
  }
  return keys;
}

/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */
function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;
  if (length === 0) {
    return true;
  }
  for (var i = 0; i < length; i += 1) {
    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }
  return true;
}

/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */

function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);
  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();
    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {
      return false;
    }
    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);
  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 &&
      leftHandEntries.length === 0 &&
      rightHandKeys.length === 0 &&
      rightHandEntries.length === 0) {
    return true;
  }

  return false;
}

/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */
function isPrimitive(value) {
  return value === null || typeof value !== 'object';
}
deepEql.MemoizeMap = MemoizeMap_1;

/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .isProxyEnabled()
 *
 * Helper function to check if Chai's proxy protection feature is enabled. If
 * proxies are unsupported or disabled via the user's Chai config, then return
 * false. Otherwise, return true.
 *
 * @namespace Utils
 * @name isProxyEnabled
 */

var isProxyEnabled = function isProxyEnabled() {
  return config.useProxy &&
    typeof Proxy !== 'undefined' &&
    typeof Reflect !== 'undefined';
};

/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */






/**
 * ### .addProperty(ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

var addProperty = function addProperty(ctx, name, getter) {
  getter = getter === undefined ? function () {} : getter;

  Object.defineProperty(ctx, name,
    { get: function propertyGetter() {
        // Setting the `ssfi` flag to `propertyGetter` causes this function to
        // be the starting point for removing implementation frames from the
        // stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if
        // the `lockSsfi` flag isn't set and proxy protection is disabled.
        //
        // If the `lockSsfi` flag is set, then either this assertion has been
        // overwritten by another assertion, or this assertion is being invoked
        // from inside of another assertion. In the first case, the `ssfi` flag
        // has already been set by the overwriting assertion. In the second
        // case, the `ssfi` flag has already been set by the outer assertion.
        //
        // If proxy protection is enabled, then the `ssfi` flag has already been
        // set by the proxy getter.
        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', propertyGetter);
        }

        var result = getter.call(this);
        if (result !== undefined)
          return result;

        var newAssertion = new chai.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }
    , configurable: true
  });
};

var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');

/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addLengthGuard(fn, assertionName, isChainable)
 *
 * Define `length` as a getter on the given uninvoked method assertion. The
 * getter acts as a guard against chaining `length` directly off of an uninvoked
 * method assertion, which is a problem because it references `function`'s
 * built-in `length` property instead of Chai's `length` assertion. When the
 * getter catches the user making this mistake, it throws an error with a
 * helpful message.
 *
 * There are two ways in which this mistake can be made. The first way is by
 * chaining the `length` assertion directly off of an uninvoked chainable
 * method. In this case, Chai suggests that the user use `lengthOf` instead. The
 * second way is by chaining the `length` assertion directly off of an uninvoked
 * non-chainable method. Non-chainable methods must be invoked prior to
 * chaining. In this case, Chai suggests that the user consult the docs for the
 * given assertion.
 *
 * If the `length` property of functions is unconfigurable, then return `fn`
 * without modification.
 *
 * Note that in ES6, the function's `length` property is configurable, so once
 * support for legacy environments is dropped, Chai's `length` property can
 * replace the built-in function's `length` property, and this length guard will
 * no longer be necessary. In the mean time, maintaining consistency across all
 * environments is the priority.
 *
 * @param {Function} fn
 * @param {String} assertionName
 * @param {Boolean} isChainable
 * @namespace Utils
 * @name addLengthGuard
 */

var addLengthGuard = function addLengthGuard (fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable) return fn;

  Object.defineProperty(fn, 'length', {
    get: function () {
      if (isChainable) {
        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' +
          ' to a compatibility issue, "length" cannot directly follow "' +
          assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }

      throw Error('Invalid Chai property: ' + assertionName + '.length. See' +
        ' docs for proper usage of "' + assertionName + '".');
    }
  });

  return fn;
};

/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .proxify(object)
 *
 * Return a proxy of given object that throws an error when a non-existent
 * property is read. By default, the root cause is assumed to be a misspelled
 * property, and thus an attempt is made to offer a reasonable suggestion from
 * the list of existing properties. However, if a nonChainableMethodName is
 * provided, then the root cause is instead a failure to invoke a non-chainable
 * method prior to reading the non-existent property.
 *
 * If proxies are unsupported or disabled via the user's Chai config, then
 * return object without modification.
 *
 * @param {Object} obj
 * @param {String} nonChainableMethodName
 * @namespace Utils
 * @name proxify
 */

var builtins = ['__flags', '__methods', '_obj', 'assert'];

var proxify = function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled()) return obj;

  return new Proxy(obj, {
    get: function proxyGetter(target, property) {
      // This check is here because we should not throw errors on Symbol properties
      // such as `Symbol.toStringTag`.
      // The values for which an error should be thrown can be configured using
      // the `config.proxyExcludedKeys` setting.
      if (typeof property === 'string' &&
          config.proxyExcludedKeys.indexOf(property) === -1 &&
          !Reflect.has(target, property)) {
        // Special message for invalid property access of non-chainable methods.
        if (nonChainableMethodName) {
          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' +
            property + '. See docs for proper usage of "' +
            nonChainableMethodName + '".');
        }

        // If the property is reasonably close to an existing Chai property,
        // suggest that property to the user. Only suggest properties with a
        // distance less than 4.
        var suggestion = null;
        var suggestionDistance = 4;
        getProperties(target).forEach(function(prop) {
          if (
            !Object.prototype.hasOwnProperty(prop) &&
            builtins.indexOf(prop) === -1
          ) {
            var dist = stringDistanceCapped(
              property,
              prop,
              suggestionDistance
            );
            if (dist < suggestionDistance) {
              suggestion = prop;
              suggestionDistance = dist;
            }
          }
        });

        if (suggestion !== null) {
          throw Error('Invalid Chai property: ' + property +
            '. Did you mean "' + suggestion + '"?');
        } else {
          throw Error('Invalid Chai property: ' + property);
        }
      }

      // Use this proxy getter as the starting point for removing implementation
      // frames from the stack trace of a failed assertion. For property
      // assertions, this prevents the proxy getter from showing up in the stack
      // trace since it's invoked before the property getter. For method and
      // chainable method assertions, this flag will end up getting changed to
      // the method wrapper, which is good since this frame will no longer be in
      // the stack once the method is invoked. Note that Chai builtin assertion
      // properties such as `__flags` are skipped since this is only meant to
      // capture the starting point of an assertion. This step is also skipped
      // if the `lockSsfi` flag is set, thus indicating that this assertion is
      // being called from within another assertion. In that case, the `ssfi`
      // flag is already set to the outer assertion's starting point.
      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {
        flag(target, 'ssfi', proxyGetter);
      }

      return Reflect.get(target, property);
    }
  });
};

/**
 * # stringDistanceCapped(strA, strB, cap)
 * Return the Levenshtein distance between two strings, but no more than cap.
 * @param {string} strA
 * @param {string} strB
 * @param {number} number
 * @return {number} min(string distance between strA and strB, cap)
 * @api private
 */

function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) {
    return cap;
  }

  var memo = [];
  // `memo` is a two-dimensional array containing distances.
  // memo[i][j] is the distance between strA.slice(0, i) and
  // strB.slice(0, j).
  for (var i = 0; i <= strA.length; i++) {
    memo[i] = Array(strB.length + 1).fill(0);
    memo[i][0] = i;
  }
  for (var j = 0; j < strB.length; j++) {
    memo[0][j] = j;
  }

  for (var i = 1; i <= strA.length; i++) {
    var ch = strA.charCodeAt(i - 1);
    for (var j = 1; j <= strB.length; j++) {
      if (Math.abs(i - j) >= cap) {
        memo[i][j] = cap;
        continue;
      }
      memo[i][j] = Math.min(
        memo[i - 1][j] + 1,
        memo[i][j - 1] + 1,
        memo[i - 1][j - 1] +
          (ch === strB.charCodeAt(j - 1) ? 0 : 1)
      );
    }
  }

  return memo[strA.length][strB.length];
}

/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */







/**
 * ### .addMethod(ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */

var addMethod = function addMethod(ctx, name, method) {
  var methodWrapper = function () {
    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the
    // starting point for removing implementation frames from the stack trace of
    // a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', methodWrapper);
    }

    var result = method.apply(this, arguments);
    if (result !== undefined)
      return result;

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
};

/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */






/**
 * ### .overwriteProperty(ctx, name, fn)
 *
 * Overwrites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

var overwriteProperty = function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get;

  Object.defineProperty(ctx, name,
    { get: function overwritingPropertyGetter() {
        // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this
        // function to be the starting point for removing implementation frames
        // from the stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if
        // the `lockSsfi` flag isn't set and proxy protection is disabled.
        //
        // If the `lockSsfi` flag is set, then either this assertion has been
        // overwritten by another assertion, or this assertion is being invoked
        // from inside of another assertion. In the first case, the `ssfi` flag
        // has already been set by the overwriting assertion. In the second
        // case, the `ssfi` flag has already been set by the outer assertion.
        //
        // If proxy protection is enabled, then the `ssfi` flag has already been
        // set by the proxy getter.
        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', overwritingPropertyGetter);
        }

        // Setting the `lockSsfi` flag to `true` prevents the overwritten
        // assertion from changing the `ssfi` flag. By this point, the `ssfi`
        // flag is already set to the correct starting point for this assertion.
        var origLockSsfi = flag(this, 'lockSsfi');
        flag(this, 'lockSsfi', true);
        var result = getter(_super).call(this);
        flag(this, 'lockSsfi', origLockSsfi);

        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }
    , configurable: true
  });
};

/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */







/**
 * ### .overwriteMethod(ctx, name, fn)
 *
 * Overwrites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

var overwriteMethod = function overwriteMethod(ctx, name, method) {
  var _method = ctx[name]
    , _super = function () {
      throw new Error(name + ' is not a function');
    };

  if (_method && 'function' === typeof _method)
    _super = _method;

  var overwritingMethodWrapper = function () {
    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this
    // function to be the starting point for removing implementation frames from
    // the stack trace of a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', overwritingMethodWrapper);
    }

    // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion
    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already
    // set to the correct starting point for this assertion.
    var origLockSsfi = flag(this, 'lockSsfi');
    flag(this, 'lockSsfi', true);
    var result = method(_super).apply(this, arguments);
    flag(this, 'lockSsfi', origLockSsfi);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
};

/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */







/*!
 * Module variables
 */

// Check whether `Object.setPrototypeOf` is supported
var canSetPrototype = typeof Object.setPrototypeOf === 'function';

// Without `Object.setPrototypeOf` support, this module will need to add properties to a function.
// However, some of functions' own props are not configurable and should be skipped.
var testFn = function() {};
var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);

  // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,
  // but then returns `undefined` as the property descriptor for `callee`. As a
  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,
  // and then filter it out if it's not an object as it should be.
  if (typeof propDesc !== 'object')
    return true;

  return !propDesc.configurable;
});

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### .addChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

var addChainableMethod = function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function chainableMethodGetter() {
        chainableBehavior.chainingBehavior.call(this);

        var chainableMethodWrapper = function () {
          // Setting the `ssfi` flag to `chainableMethodWrapper` causes this
          // function to be the starting point for removing implementation
          // frames from the stack trace of a failed assertion.
          //
          // However, we only want to use this function as the starting point if
          // the `lockSsfi` flag isn't set.
          //
          // If the `lockSsfi` flag is set, then this assertion is being
          // invoked from inside of another assertion. In this case, the `ssfi`
          // flag has already been set by the outer assertion.
          //
          // Note that overwriting a chainable method merely replaces the saved
          // methods in `ctx.__methods` instead of completely replacing the
          // overwritten assertion. Therefore, an overwriting assertion won't
          // set the `ssfi` or `lockSsfi` flags.
          if (!flag(this, 'lockSsfi')) {
            flag(this, 'ssfi', chainableMethodWrapper);
          }

          var result = chainableBehavior.method.apply(this, arguments);
          if (result !== undefined) {
            return result;
          }

          var newAssertion = new chai.Assertion();
          transferFlags(this, newAssertion);
          return newAssertion;
        };

        addLengthGuard(chainableMethodWrapper, name, true);

        // Use `Object.setPrototypeOf` if available
        if (canSetPrototype) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
          Object.setPrototypeOf(chainableMethodWrapper, prototype);
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }

            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }

        transferFlags(this, chainableMethodWrapper);
        return proxify(chainableMethodWrapper);
      }
    , configurable: true
  });
};

/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */




/**
 * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Overwrites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.lengthOf(3);
 *     expect(myFoo).to.have.lengthOf.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

var overwriteChainableMethod = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);
    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);
    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };
};

/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */



/**
 * ### .compareByInspect(mixed, mixed)
 *
 * To be used as a compareFunction with Array.prototype.sort. Compares elements
 * using inspect instead of default behavior of using toString so that Symbols
 * and objects with irregular/missing toString can still be sorted without a
 * TypeError.
 *
 * @param {Mixed} first element to compare
 * @param {Mixed} second element to compare
 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1
 * @name compareByInspect
 * @namespace Utils
 * @api public
 */

var compareByInspect = function compareByInspect(a, b) {
  return inspect_1(a) < inspect_1(b) ? -1 : 1;
};

/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getOwnEnumerablePropertySymbols(object)
 *
 * This allows the retrieval of directly-owned enumerable property symbols of an
 * object. This function is necessary because Object.getOwnPropertySymbols
 * returns both enumerable and non-enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerablePropertySymbols
 * @api public
 */

var getOwnEnumerablePropertySymbols = function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== 'function') return [];

  return Object.getOwnPropertySymbols(obj).filter(function (sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
};

/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */



/**
 * ### .getOwnEnumerableProperties(object)
 *
 * This allows the retrieval of directly-owned enumerable property names and
 * symbols of an object. This function is necessary because Object.keys only
 * returns enumerable property names, not enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerableProperties
 * @api public
 */

var getOwnEnumerableProperties = function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
};

/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */

/**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleInstance(thrown, errorLike) {
  return errorLike instanceof Error && thrown === errorLike;
}

/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the `errorLike` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleConstructor(thrown, errorLike) {
  if (errorLike instanceof Error) {
    // If `errorLike` is an instance of any error we compare their constructors
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if (errorLike.prototype instanceof Error || errorLike === Error) {
    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }

  return false;
}

/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */

function compatibleMessage(thrown, errMatcher) {
  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;
  if (errMatcher instanceof RegExp) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === 'string') {
    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
  }

  return false;
}

/**
 * ### .getFunctionName(constructorFn)
 *
 * Returns the name of a function.
 * This also includes a polyfill function if `constructorFn.name` is not defined.
 *
 * @name getFunctionName
 * @param {Function} constructorFn
 * @namespace Utils
 * @api private
 */

var functionNameMatch$1 = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;
function getFunctionName(constructorFn) {
  var name = '';
  if (typeof constructorFn.name === 'undefined') {
    // Here we run a polyfill if constructorFn.name is not defined
    var match = String(constructorFn).match(functionNameMatch$1);
    if (match) {
      name = match[1];
    }
  } else {
    name = constructorFn.name;
  }

  return name;
}

/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */

function getConstructorName(errorLike) {
  var constructorName = errorLike;
  if (errorLike instanceof Error) {
    constructorName = getFunctionName(errorLike.constructor);
  } else if (typeof errorLike === 'function') {
    // If `err` is not an instance of Error it is an error constructor itself or another function.
    // If we've got a common function we get its name, otherwise we may need to create a new instance
    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
    constructorName = getFunctionName(errorLike).trim() ||
        getFunctionName(new errorLike()); // eslint-disable-line new-cap
  }

  return constructorName;
}

/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If `err` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */

function getMessage$1(errorLike) {
  var msg = '';
  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === 'string') {
    msg = errorLike;
  }

  return msg;
}

var checkError = {
  compatibleInstance: compatibleInstance,
  compatibleConstructor: compatibleConstructor,
  compatibleMessage: compatibleMessage,
  getMessage: getMessage$1,
  getConstructorName: getConstructorName,
};

/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */

/**
 * ### .isNaN(value)
 *
 * Checks if the given value is NaN or not.
 *
 *     utils.isNaN(NaN); // true
 *
 * @param {Value} The value which has to be checked if it is NaN
 * @name isNaN
 * @api private
 */

function isNaN(value) {
  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
  // section's NOTE.
  return value !== value;
}

// If ECMAScript 6's Number.isNaN is present, prefer that.
var _isNaN = Number.isNaN || isNaN;

/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Dependencies that are used for multiple exports are required here only once
 */



/*!
 * test utility
 */

var test$1 = test;

/*!
 * type utility
 */

var type = typeDetect;

/*!
 * expectTypes utility
 */
var expectTypes$1 = expectTypes;

/*!
 * message utility
 */

var getMessage$2 = getMessage;

/*!
 * actual utility
 */

var getActual$1 = getActual;

/*!
 * Inspect util
 */

var inspect = inspect_1;

/*!
 * Object Display util
 */

var objDisplay$1 = objDisplay;

/*!
 * Flag utility
 */

var flag$1 = flag;

/*!
 * Flag transferring utility
 */

var transferFlags$1 = transferFlags;

/*!
 * Deep equal utility
 */

var eql = deepEql;

/*!
 * Deep path info
 */

var getPathInfo$1 = pathval.getPathInfo;

/*!
 * Check if a property exists
 */

var hasProperty$1 = pathval.hasProperty;

/*!
 * Function name
 */

var getName = getFuncName_1;

/*!
 * add Property
 */

var addProperty$1 = addProperty;

/*!
 * add Method
 */

var addMethod$1 = addMethod;

/*!
 * overwrite Property
 */

var overwriteProperty$1 = overwriteProperty;

/*!
 * overwrite Method
 */

var overwriteMethod$1 = overwriteMethod;

/*!
 * Add a chainable method
 */

var addChainableMethod$1 = addChainableMethod;

/*!
 * Overwrite chainable method
 */

var overwriteChainableMethod$1 = overwriteChainableMethod;

/*!
 * Compare by inspect method
 */

var compareByInspect$1 = compareByInspect;

/*!
 * Get own enumerable property symbols method
 */

var getOwnEnumerablePropertySymbols$1 = getOwnEnumerablePropertySymbols;

/*!
 * Get own enumerable properties method
 */

var getOwnEnumerableProperties$1 = getOwnEnumerableProperties;

/*!
 * Checks error against a given set of criteria
 */

var checkError$1 = checkError;

/*!
 * Proxify util
 */

var proxify$1 = proxify;

/*!
 * addLengthGuard util
 */

var addLengthGuard$1 = addLengthGuard;

/*!
 * isProxyEnabled helper
 */

var isProxyEnabled$1 = isProxyEnabled;

/*!
 * isNaN method
 */

var isNaN$1 = _isNaN;

var utils = {
	test: test$1,
	type: type,
	expectTypes: expectTypes$1,
	getMessage: getMessage$2,
	getActual: getActual$1,
	inspect: inspect,
	objDisplay: objDisplay$1,
	flag: flag$1,
	transferFlags: transferFlags$1,
	eql: eql,
	getPathInfo: getPathInfo$1,
	hasProperty: hasProperty$1,
	getName: getName,
	addProperty: addProperty$1,
	addMethod: addMethod$1,
	overwriteProperty: overwriteProperty$1,
	overwriteMethod: overwriteMethod$1,
	addChainableMethod: addChainableMethod$1,
	overwriteChainableMethod: overwriteChainableMethod$1,
	compareByInspect: compareByInspect$1,
	getOwnEnumerablePropertySymbols: getOwnEnumerablePropertySymbols$1,
	getOwnEnumerableProperties: getOwnEnumerableProperties$1,
	checkError: checkError$1,
	proxify: proxify$1,
	addLengthGuard: addLengthGuard$1,
	isProxyEnabled: isProxyEnabled$1,
	isNaN: isNaN$1
};

/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */



var assertion = function (_chai, util$$1) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util$$1.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */

  function Assertion (obj, msg, ssfi, lockSsfi) {
    flag(this, 'ssfi', ssfi || Assertion);
    flag(this, 'lockSsfi', lockSsfi);
    flag(this, 'object', obj);
    flag(this, 'message', msg);

    return util$$1.proxify(this);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util$$1.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util$$1.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util$$1.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util$$1.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util$$1.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util$$1.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util$$1.test(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (undefined === expected && undefined === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      msg = util$$1.getMessage(this, arguments);
      var actual = util$$1.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var assertions = function (chai, _) {
  var Assertion = chai.Assertion
    , AssertionError = chai.AssertionError
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to improve the readability
   * of your assertions.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   * - but
   * - does
   * - still
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  [ 'to', 'be', 'been', 'is'
  , 'and', 'has', 'have', 'with'
  , 'that', 'which', 'at', 'of'
  , 'same', 'but', 'does', 'still' ].forEach(function (chain) {
    Assertion.addProperty(chain);
  });

  /**
   * ### .not
   *
   * Negates all assertions that follow in the chain.
   *
   *     expect(function () {}).to.not.throw();
   *     expect({a: 1}).to.not.have.property('b');
   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
   *
   * Just because you can negate any assertion with `.not` doesn't mean you
   * should. With great power comes great responsibility. It's often best to
   * assert that the one expected output was produced, rather than asserting
   * that one of countless unexpected outputs wasn't produced. See individual
   * assertions for specific guidance.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.equal(1); // Not recommended
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
   * assertions that follow in the chain to use deep equality instead of strict
   * (`===`) equality. See the `deep-eql` project page for info on the deep
   * equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .nested
   *
   * Enables dot- and bracket-notation in all `.property` and `.include`
   * assertions that follow in the chain.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
   *
   * `.nested` cannot be combined with `.own`.
   *
   * @name nested
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('nested', function () {
    flag(this, 'nested', true);
  });

  /**
   * ### .own
   *
   * Causes all `.property` and `.include` assertions that follow in the chain
   * to ignore inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * `.own` cannot be combined with `.nested`.
   *
   * @name own
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('own', function () {
    flag(this, 'own', true);
  });

  /**
   * ### .ordered
   *
   * Causes all `.members` assertions that follow in the chain to require that
   * members be in the same order.
   *
   *     expect([1, 2]).to.have.ordered.members([1, 2])
   *       .but.not.have.ordered.members([2, 1]);
   *
   * When `.include` and `.ordered` are combined, the ordering begins at the
   * start of both arrays.
   *
   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
   *       .but.not.include.ordered.members([2, 3]);
   *
   * @name ordered
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ordered', function () {
    flag(this, 'ordered', true);
  });

  /**
   * ### .any
   *
   * Causes all `.keys` assertions that follow in the chain to only require that
   * the target have at least one of the given keys. This is the opposite of
   * `.all`, which requires that the target have all of the given keys.
   *
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false);
  });

  /**
   * ### .all
   *
   * Causes all `.keys` assertions that follow in the chain to require that the
   * target have all of the given keys. This is the opposite of `.any`, which
   * only requires that the target have at least one of the given keys.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` are
   * added earlier in the chain. However, it's often best to add `.all` anyway
   * because it improves readability.
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });

  /**
   * ### .a(type[, msg])
   *
   * Asserts that the target's type is equal to the given string `type`. Types
   * are case insensitive. See the `type-detect` project page for info on the
   * type detection algorithm: https://github.com/chaijs/type-detect.
   *
   *     expect('foo').to.be.a('string');
   *     expect({a: 1}).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(Promise.resolve()).to.be.a('promise');
   *     expect(new Float32Array).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.
   *
   *     var myObj = {
   *       [Symbol.toStringTag]: 'myCustomType'
   *     };
   *
   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
   *
   * It's often best to use `.a` to check a target's type before making more
   * assertions on the same target. That way, you avoid unexpected behavior from
   * any assertion that does different things based on the target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to
   * assert that the target is the expected type, rather than asserting that it
   * isn't one of many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.an('array'); // Not recommended
   *
   * `.a` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     expect(1).to.be.a('string', 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.a('string');
   *
   * `.a` can also be used as a language chain to improve the readability of
   * your assertions.
   *
   *     expect({b: 2}).to.have.a.property('b');
   *
   * The alias `.an` can be used interchangeably with `.a`.
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj).toLowerCase()
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(val[, msg])
   *
   * When the target is a string, `.include` asserts that the given string `val`
   * is a substring of the target.
   *
   *     expect('foobar').to.include('foo');
   *
   * When the target is an array, `.include` asserts that the given `val` is a
   * member of the target.
   *
   *     expect([1, 2, 3]).to.include(2);
   *
   * When the target is an object, `.include` asserts that the given object
   * `val`'s properties are a subset of the target's properties.
   *
   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
   *
   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
   * member of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Set([1, 2])).to.include(2);
   *
   * When the target is a Map, `.include` asserts that the given `val` is one of
   * the values of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
   *
   * Because `.include` does different things based on the target's type, it's
   * important to check the target's type before using `.include`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *
   * By default, strict (`===`) equality is used to compare array members and
   * object properties. Add `.deep` earlier in the chain to use deep equality
   * instead (WeakSet targets are not supported). See the `deep-eql` project
   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   * By default, all of the target's properties are searched when working with
   * objects. This includes properties that are inherited and/or non-enumerable.
   * Add `.own` earlier in the chain to exclude the target's inherited
   * properties from the search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * Note that a target object is always only searched for `val`'s own
   * enumerable properties.
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.include`.
   *
   *     expect('foobar').to.not.include('taco');
   *     expect([1, 2, 3]).to.not.include(4);
   *
   * However, it's dangerous to negate `.include` when the target is an object.
   * The problem is that it creates uncertain expectations by asserting that the
   * target object doesn't have all of `val`'s key/value pairs but may or may
   * not have some of them. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target object isn't even expected to have `val`'s keys, it's
   * often best to assert exactly that.
   *
   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * When the target object is expected to have `val`'s keys, it's often best to
   * assert that each of the properties has its expected value, rather than
   * asserting that each property doesn't have one of many unexpected values.
   *
   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * `.include` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
   *
   * `.include` can also be used as a language chain, causing all `.members` and
   * `.keys` assertions that follow in the chain to require the target to be a
   * superset of the expected set, rather than an identical set. Note that
   * `.members` ignores duplicates in the subset when `.include` is added.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * Note that adding `.any` earlier in the chain causes the `.keys` assertion
   * to ignore `.include`.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *
   * The aliases `.includes`, `.contain`, and `.contains` can be used
   * interchangeably with `.include`.
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function SameValueZero(a, b) {
    return (_.isNaN(a) && _.isNaN(b)) || a === b;
  }

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object')
      , objType = _.type(obj).toLowerCase()
      , flagMsg = flag(this, 'message')
      , negate = flag(this, 'negate')
      , ssfi = flag(this, 'ssfi')
      , isDeep = flag(this, 'deep')
      , descriptor = isDeep ? 'deep ' : '';

    flagMsg = flagMsg ? flagMsg + ': ' : '';

    var included = false;

    switch (objType) {
      case 'string':
        included = obj.indexOf(val) !== -1;
        break;

      case 'weakset':
        if (isDeep) {
          throw new AssertionError(
            flagMsg + 'unable to use .deep.include with WeakSet',
            undefined,
            ssfi
          );
        }

        included = obj.has(val);
        break;

      case 'map':
        var isEql = isDeep ? _.eql : SameValueZero;
        obj.forEach(function (item) {
          included = included || isEql(item, val);
        });
        break;

      case 'set':
        if (isDeep) {
          obj.forEach(function (item) {
            included = included || _.eql(item, val);
          });
        } else {
          included = obj.has(val);
        }
        break;

      case 'array':
        if (isDeep) {
          included = obj.some(function (item) {
            return _.eql(item, val);
          });
        } else {
          included = obj.indexOf(val) !== -1;
        }
        break;

      default:
        // This block is for asserting a subset of properties in an object.
        // `_.expectTypes` isn't used here because `.include` should work with
        // objects with a custom `@@toStringTag`.
        if (val !== Object(val)) {
          throw new AssertionError(
            flagMsg + 'object tested must be an array, a map, an object,'
              + ' a set, a string, or a weakset, but ' + objType + ' given',
            undefined,
            ssfi
          );
        }

        var props = Object.keys(val)
          , firstErr = null
          , numErrs = 0;

        props.forEach(function (prop) {
          var propAssertion = new Assertion(obj);
          _.transferFlags(this, propAssertion, true);
          flag(propAssertion, 'lockSsfi', true);

          if (!negate || props.length === 1) {
            propAssertion.property(prop, val[prop]);
            return;
          }

          try {
            propAssertion.property(prop, val[prop]);
          } catch (err) {
            if (!_.checkError.compatibleConstructor(err, AssertionError)) {
              throw err;
            }
            if (firstErr === null) firstErr = err;
            numErrs++;
          }
        }, this);

        // When validating .not.include with multiple properties, we only want
        // to throw an assertion error if all of the properties are included,
        // in which case we throw the first property assertion error that we
        // encountered.
        if (negate && props.length > 1 && numErrs === props.length) {
          throw firstErr;
        }
        return;
    }

    // Assert inclusion in collection or substring in a string.
    this.assert(
      included
      , 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val)
      , 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is a truthy value (considered `true` in boolean context).
   * However, it's often best to assert that the target is strictly (`===`) or
   * deeply equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.ok; // Not recommended
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.be.ok; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.ok`.
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.not.be.ok; // Not recommended
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.ok; // Not recommended
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.be.ok; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.be.ok; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is strictly (`===`) equal to `true`.
   *
   *     expect(true).to.be.true;
   *
   * Add `.not` earlier in the chain to negate `.true`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `true`.
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.true; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.true; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , flag(this, 'negate') ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is strictly (`===`) equal to `false`.
   *
   *     expect(false).to.be.false;
   *
   * Add `.not` earlier in the chain to negate `.false`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `false`.
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.not.be.false; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.false; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(true, 'nooo why fail??').to.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , flag(this, 'negate') ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is strictly (`===`) equal to `null`.
   *
   *     expect(null).to.be.null;
   *
   * Add `.not` earlier in the chain to negate `.null`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `null`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.null; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is strictly (`===`) equal to `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *
   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `undefined`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.undefined; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .NaN
   *
   * Asserts that the target is exactly `NaN`.
   *
   *     expect(NaN).to.be.NaN;
   *
   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `NaN`.
   *
   *     expect('foo').to.equal('foo'); // Recommended
   *     expect('foo').to.not.be.NaN; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(
        _.isNaN(flag(this, 'object'))
        , 'expected #{this} to be NaN'
        , 'expected #{this} not to be NaN'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is not strictly (`===`) equal to either `null` or
   * `undefined`. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.exist; // Not recommended
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.exist; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.exist`.
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.exist; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.exist; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(null, 'nooo why fail??').to.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('exist', function () {
    var val = flag(this, 'object');
    this.assert(
        val !== null && val !== undefined
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });

  /**
   * ### .empty
   *
   * When the target is a string or array, `.empty` asserts that the target's
   * `length` property is strictly (`===`) equal to `0`.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *
   * When the target is a map or set, `.empty` asserts that the target's `size`
   * property is strictly equal to `0`.
   *
   *     expect(new Set()).to.be.empty;
   *     expect(new Map()).to.be.empty;
   *
   * When the target is a non-function object, `.empty` asserts that the target
   * doesn't have any own enumerable properties. Properties with Symbol-based
   * keys are excluded from the count.
   *
   *     expect({}).to.be.empty;
   *
   * Because `.empty` does different things based on the target's type, it's
   * important to check the target's type before using `.empty`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.empty`. However, it's often
   * best to assert that the target contains its expected number of values,
   * rather than asserting that it's not empty.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
   *
   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
   *
   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
   *     expect({a: 1}).to.not.be.empty; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var val = flag(this, 'object')
      , ssfi = flag(this, 'ssfi')
      , flagMsg = flag(this, 'message')
      , itemsCount;

    flagMsg = flagMsg ? flagMsg + ': ' : '';

    switch (_.type(val).toLowerCase()) {
      case 'array':
      case 'string':
        itemsCount = val.length;
        break;
      case 'map':
      case 'set':
        itemsCount = val.size;
        break;
      case 'weakmap':
      case 'weakset':
        throw new AssertionError(
          flagMsg + '.empty was passed a weak collection',
          undefined,
          ssfi
        );
      case 'function':
        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);
        throw new AssertionError(msg.trim(), undefined, ssfi);
      default:
        if (val !== Object(val)) {
          throw new AssertionError(
            flagMsg + '.empty was passed non-string primitive ' + _.inspect(val),
            undefined,
            ssfi
          );
        }
        itemsCount = Object.keys(val).length;
    }

    this.assert(
        0 === itemsCount
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an `arguments` object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   *     test();
   *
   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often
   * best to assert which type the target is expected to be, rather than
   * asserting that its not an `arguments` object.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.arguments; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({}, 'nooo why fail??').to.be.arguments;
   *
   * The alias `.Arguments` can be used interchangeably with `.arguments`.
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = _.type(obj);
    this.assert(
        'Arguments' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(val[, msg])
   *
   * Asserts that the target is strictly (`===`) equal to the given `val`.
   *
   *     expect(1).to.equal(1);
   *     expect('foo').to.equal('foo');
   *
   * Add `.deep` earlier in the chain to use deep equality instead. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) equals `[1, 2]`
   *     expect([1, 2]).to.deep.equal([1, 2]);
   *     expect([1, 2]).to.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.equal`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to one of countless unexpected values.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.equal(2); // Not recommended
   *
   * `.equal` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.equal(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.equal(2);
   *
   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      var prevLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      this.eql(val);
      flag(this, 'lockSsfi', prevLockSsfi);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(obj[, msg])
   *
   * Asserts that the target is deeply equal to the given `obj`. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object is deeply (but not strictly) equal to {a: 1}
   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
   *
   *     // Target array is deeply (but not strictly) equal to [1, 2]
   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best
   * to assert that the target is deeply equal to its expected value, rather
   * than not deeply equal to one of countless unexpected values.
   *
   *     expect({a: 1}).to.eql({a: 1}); // Recommended
   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
   *
   * `.eql` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
   *
   * The alias `.eqls` can be used interchangeably with `.eql`.
   *
   * The `.deep.equal` assertion is almost identical to `.eql` but with one
   * difference: `.deep.equal` causes deep equality comparisons to also be used
   * for any other assertions that follow in the chain.
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} obj
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(n[, msg])
   *
   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.above(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.above`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(1).to.not.be.above(2); // Not recommended
   *
   * `.above` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.above(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.above(2);
   *
   * The aliases `.gt` and `.greaterThan` can be used interchangeably with
   * `.above`.
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , doLength = flag(this, 'doLength')
      , flagMsg = flag(this, 'message')
      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
      , ssfi = flag(this, 'ssfi')
      , objType = _.type(obj).toLowerCase()
      , nType = _.type(n).toLowerCase()
      , errorMessage
      , shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && (objType === 'date' && nType !== 'date')) {
      errorMessage = msgPrefix + 'the argument to above must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to above must be a number';
    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length'
        , itemsCount;
      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
          itemsCount > n
        , 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + ' above #{exp}'
        , n
        , itemsCount
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above #{exp}'
        , 'expected #{this} to be at most #{exp}'
        , n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(n[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `n` respectively. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.at.least(1); // Not recommended
   *     expect(2).to.be.at.least(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.least`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.at.least(2); // Not recommended
   *
   * `.least` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.at.least(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.at.least(2);
   *
   * The alias `.gte` can be used interchangeably with `.least`.
   *
   * @name least
   * @alias gte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , doLength = flag(this, 'doLength')
      , flagMsg = flag(this, 'message')
      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
      , ssfi = flag(this, 'ssfi')
      , objType = _.type(obj).toLowerCase()
      , nType = _.type(n).toLowerCase()
      , errorMessage
      , shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && (objType === 'date' && nType !== 'date')) {
      errorMessage = msgPrefix + 'the argument to least must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to least must be a number';
    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length'
        , itemsCount;
      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
          itemsCount >= n
        , 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}'
        , 'expected #{this} to have a ' + descriptor + ' below #{exp}'
        , n
        , itemsCount
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least #{exp}'
        , 'expected #{this} to be below #{exp}'
        , n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(n[, msg])
   *
   * Asserts that the target is a number or a date less than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.below(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.length(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.below`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.below(1); // Not recommended
   *
   * `.below` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.below(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.below(1);
   *
   * The aliases `.lt` and `.lessThan` can be used interchangeably with
   * `.below`.
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , doLength = flag(this, 'doLength')
      , flagMsg = flag(this, 'message')
      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
      , ssfi = flag(this, 'ssfi')
      , objType = _.type(obj).toLowerCase()
      , nType = _.type(n).toLowerCase()
      , errorMessage
      , shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && (objType === 'date' && nType !== 'date')) {
      errorMessage = msgPrefix + 'the argument to below must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to below must be a number';
    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length'
        , itemsCount;
      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
          itemsCount < n
        , 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + ' below #{exp}'
        , n
        , itemsCount
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below #{exp}'
        , 'expected #{this} to be at least #{exp}'
        , n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(n[, msg])
   *
   * Asserts that the target is a number or a date less than or equal to the given number
   * or date `n` respectively. However, it's often best to assert that the target is equal to its
   * expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.at.most(2); // Not recommended
   *     expect(1).to.be.at.most(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.most`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.at.most(1); // Not recommended
   *
   * `.most` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.at.most(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.at.most(1);
   *
   * The alias `.lte` can be used interchangeably with `.most`.
   *
   * @name most
   * @alias lte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , doLength = flag(this, 'doLength')
      , flagMsg = flag(this, 'message')
      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
      , ssfi = flag(this, 'ssfi')
      , objType = _.type(obj).toLowerCase()
      , nType = _.type(n).toLowerCase()
      , errorMessage
      , shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && (objType === 'date' && nType !== 'date')) {
      errorMessage = msgPrefix + 'the argument to most must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to most must be a number';
    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length'
        , itemsCount;
      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
          itemsCount <= n
        , 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}'
        , 'expected #{this} to have a ' + descriptor + ' above #{exp}'
        , n
        , itemsCount
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most #{exp}'
        , 'expected #{this} to be above #{exp}'
        , n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `start`, and less than or equal to the given number or date `finish` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.within(1, 3); // Not recommended
   *     expect(2).to.be.within(2, 3); // Not recommended
   *     expect(2).to.be.within(1, 2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `start`, and less
   * than or equal to the given number `finish`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.within`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.within(2, 4); // Not recommended
   *
   * `.within` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
   *
   * @name within
   * @param {Number} start lower bound inclusive
   * @param {Number} finish upper bound inclusive
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , doLength = flag(this, 'doLength')
      , flagMsg = flag(this, 'message')
      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
      , ssfi = flag(this, 'ssfi')
      , objType = _.type(obj).toLowerCase()
      , startType = _.type(start).toLowerCase()
      , finishType = _.type(finish).toLowerCase()
      , errorMessage
      , shouldThrow = true
      , range = (startType === 'date' && finishType === 'date')
          ? start.toUTCString() + '..' + finish.toUTCString()
          : start + '..' + finish;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && (objType === 'date' && (startType !== 'date' || finishType !== 'date'))) {
      errorMessage = msgPrefix + 'the arguments to within must be dates';
    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the arguments to within must be numbers';
    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length'
        , itemsCount;
      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
          itemsCount >= start && itemsCount <= finish
        , 'expected #{this} to have a ' + descriptor + ' within ' + range
        , 'expected #{this} to not have a ' + descriptor + ' within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor[, msg])
   *
   * Asserts that the target is an instance of the given `constructor`.
   *
   *     function Cat () { }
   *
   *     expect(new Cat()).to.be.an.instanceof(Cat);
   *     expect([1, 2]).to.be.an.instanceof(Array);
   *
   * Add `.not` earlier in the chain to negate `.instanceof`.
   *
   *     expect({a: 1}).to.not.be.an.instanceof(Array);
   *
   * `.instanceof` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
   *
   * Due to limitations in ES5, `.instanceof` may not always work as expected
   * when using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing built-in object such as
   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} msg _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);

    var target = flag(this, 'object');
    var ssfi = flag(this, 'ssfi');
    var flagMsg = flag(this, 'message');

    try {
      var isInstanceOf = target instanceof constructor;
    } catch (err) {
      if (err instanceof TypeError) {
        flagMsg = flagMsg ? flagMsg + ': ' : '';
        throw new AssertionError(
          flagMsg + 'The instanceof assertion needs a constructor but '
            + _.type(constructor) + ' was given.',
          undefined,
          ssfi
        );
      }
      throw err;
    }

    var name = _.getName(constructor);
    if (name === null) {
      name = 'an unnamed constructor';
    }

    this.assert(
        isInstanceOf
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  }
  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name[, val[, msg]])
   *
   * Asserts that the target has a property with the given key `name`.
   *
   *     expect({a: 1}).to.have.property('a');
   *
   * When `val` is provided, `.property` also asserts that the property's value
   * is equal to the given `val`.
   *
   *     expect({a: 1}).to.have.property('a', 1);
   *
   * By default, strict (`===`) equality is used. Add `.deep` earlier in the
   * chain to use deep equality instead. See the `deep-eql` project page for
   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * The target's enumerable and non-enumerable properties are always included
   * in the search. By default, both own and inherited properties are included.
   * Add `.own` earlier in the chain to exclude inherited properties from the
   * search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.own.property('a', 1);
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}})
   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.property`.
   *
   *     expect({a: 1}).to.not.have.property('b');
   *
   * However, it's dangerous to negate `.property` when providing `val`. The
   * problem is that it creates uncertain expectations by asserting that the
   * target either doesn't have a property with the given key `name`, or that it
   * does have a property with the given key `name` but its value isn't equal to
   * the given `val`. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property with the given key
   * `name`, it's often best to assert exactly that.
   *
   *     expect({b: 2}).to.not.have.property('a'); // Recommended
   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
   *
   * When the target is expected to have a property with the given key `name`,
   * it's often best to assert that the property has its expected value, rather
   * than asserting that it doesn't have one of many unexpected values.
   *
   *     expect({a: 3}).to.have.property('a', 3); // Recommended
   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
   *
   * `.property` changes the target of any assertions that follow in the chain
   * to be the value of the property from the original target object.
   *
   *     expect({a: 1}).to.have.property('a').that.is.a('number');
   *
   * `.property` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing `val`, only use the
   * second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
   *
   *     // Not recommended
   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `val`. Instead,
   * it's asserting that the target object has a `b` property that's equal to
   * `undefined`.
   *
   * The assertions `.ownProperty` and `.haveOwnProperty` can be used
   * interchangeably with `.own.property`.
   *
   * @name property
   * @param {String} name
   * @param {Mixed} val (optional)
   * @param {String} msg _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  function assertProperty (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var isNested = flag(this, 'nested')
      , isOwn = flag(this, 'own')
      , flagMsg = flag(this, 'message')
      , obj = flag(this, 'object')
      , ssfi = flag(this, 'ssfi')
      , nameType = typeof name;

    flagMsg = flagMsg ? flagMsg + ': ' : '';

    if (isNested) {
      if (nameType !== 'string') {
        throw new AssertionError(
          flagMsg + 'the argument to property must be a string when using nested syntax',
          undefined,
          ssfi
        );
      }
    } else {
      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {
        throw new AssertionError(
          flagMsg + 'the argument to property must be a string, number, or symbol',
          undefined,
          ssfi
        );
      }
    }

    if (isNested && isOwn) {
      throw new AssertionError(
        flagMsg + 'The "nested" and "own" flags cannot be combined.',
        undefined,
        ssfi
      );
    }

    if (obj === null || obj === undefined) {
      throw new AssertionError(
        flagMsg + 'Target cannot be null or undefined.',
        undefined,
        ssfi
      );
    }

    var isDeep = flag(this, 'deep')
      , negate = flag(this, 'negate')
      , pathInfo = isNested ? _.getPathInfo(obj, name) : null
      , value = isNested ? pathInfo.value : obj[name];

    var descriptor = '';
    if (isDeep) descriptor += 'deep ';
    if (isOwn) descriptor += 'own ';
    if (isNested) descriptor += 'nested ';
    descriptor += 'property ';

    var hasProperty;
    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);
    else if (isNested) hasProperty = pathInfo.exists;
    else hasProperty = _.hasProperty(obj, name);

    // When performing a negated assertion for both name and val, merely having
    // a property with the given name isn't enough to cause the assertion to
    // fail. It must both have a property with the given name, and the value of
    // that property must equal the given val. Therefore, skip this assertion in
    // favor of the next.
    if (!negate || arguments.length === 1) {
      this.assert(
          hasProperty
        , 'expected #{this} to have ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(
          hasProperty && (isDeep ? _.eql(val, value) : val === value)
        , 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  }

  Assertion.addMethod('property', assertProperty);

  function assertOwnProperty (name, value, msg) {
    flag(this, 'own', true);
    assertProperty.apply(this, arguments);
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
   *
   * Asserts that the target has its own property descriptor with the given key
   * `name`. Enumerable and non-enumerable properties are included in the
   * search.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
   *
   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
   * the property's descriptor is deeply equal to the given `descriptor`. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.
   *
   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
   *
   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing
   * a `descriptor`. The problem is that it creates uncertain expectations by
   * asserting that the target either doesn't have a property descriptor with
   * the given key `name`, or that it does have a property descriptor with the
   * given key `name` but its not deeply equal to the given `descriptor`. It's
   * often best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property descriptor with the given
   * key `name`, it's often best to assert exactly that.
   *
   *     // Recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
   *
   *     // Not recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * When the target is expected to have a property descriptor with the given
   * key `name`, it's often best to assert that the property has its expected
   * descriptor, rather than asserting that it doesn't have one of many
   * unexpected descriptors.
   *
   *     // Recommended
   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 3,
   *     });
   *
   *     // Not recommended
   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * `.ownPropertyDescriptor` changes the target of any assertions that follow
   * in the chain to be the value of the property descriptor from the original
   * target object.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
   *       .that.has.property('enumerable', true);
   *
   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a
   * custom error message to show when the assertion fails. The message can also
   * be given as the second argument to `expect`. When not providing
   * `descriptor`, only use the second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     }, 'nooo why fail??');
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     });
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
   *
   *     // Not recommended
   *     expect({a: 1})
   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `descriptor`.
   * Instead, it's asserting that the target object has a `b` property
   * descriptor that's deeply equal to `undefined`.
   *
   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
   * `.ownPropertyDescriptor`.
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor (name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    if (actualDescriptor && descriptor) {
      this.assert(
          _.eql(descriptor, actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
        , descriptor
        , actualDescriptor
        , true
      );
    } else {
      this.assert(
          actualDescriptor
        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
      );
    }
    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

  /**
   * ### .lengthOf(n[, msg])
   *
   * Asserts that the target's `length` or `size` is equal to the given number
   * `n`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *     expect('foo').to.have.lengthOf(3);
   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);
   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
   *
   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
   * best to assert that the target's `length` property is equal to its expected
   * value, rather than not equal to one of many unexpected values.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
   *
   * `.lengthOf` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
   *
   * `.lengthOf` can also be used as a language chain, causing all `.above`,
   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the
   * chain to use the target's `length` property as the target. However, it's
   * often best to assert that the target's `length` property is equal to its
   * expected length, rather than asserting that its `length` property falls
   * within some range of values.
   *
   *     // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *
   *     // Not recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
   *
   * Due to a compatibility issue, the alias `.length` can't be chained directly
   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
   * interchangeably with `.lengthOf` in every situation. It's recommended to
   * always use `.lengthOf` instead of `.length`.
   *
   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
   *
   * @name lengthOf
   * @alias length
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , objType = _.type(obj).toLowerCase()
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi')
      , descriptor = 'length'
      , itemsCount;

    switch (objType) {
      case 'map':
      case 'set':
        descriptor = 'size';
        itemsCount = obj.size;
        break;
      default:
        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        itemsCount = obj.length;
    }

    this.assert(
        itemsCount == n
      , 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}'
      , 'expected #{this} to not have a ' + descriptor + ' of #{act}'
      , n
      , itemsCount
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);

  /**
   * ### .match(re[, msg])
   *
   * Asserts that the target matches the given regular expression `re`.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * Add `.not` earlier in the chain to negate `.match`.
   *
   *     expect('foobar').to.not.match(/taco/);
   *
   * `.match` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
   *
   * The alias `.matches` can be used interchangeably with `.match`.
   *
   * @name match
   * @alias matches
   * @param {RegExp} re
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */
  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);

  /**
   * ### .string(str[, msg])
   *
   * Asserts that the target string contains the given substring `str`.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * Add `.not` earlier in the chain to negate `.string`.
   *
   *     expect('foobar').to.not.have.string('taco');
   *
   * `.string` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect('foobar').to.have.string('taco', 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.have.string('taco');
   *
   * @name string
   * @param {String} str
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });

  /**
   * ### .keys(key1[, key2[, ...]])
   *
   * Asserts that the target object, array, map, or set has the given keys. Only
   * the target's own inherited properties are included in the search.
   *
   * When the target is an object or array, keys can be provided as one or more
   * string arguments, a single array argument, or a single object argument. In
   * the latter case, only the keys in the given object matter; the values are
   * ignored.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *     expect(['x', 'y']).to.have.all.keys(0, 1);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
   *
   * When the target is a map or set, each key must be provided as a separate
   * argument.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
   *
   * Because `.keys` does different things based on the target's type, it's
   * important to check the target's type before using `.keys`. See the `.a` doc
   * for info on testing a target's type.
   *
   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
   *
   * By default, strict (`===`) equality is used to compare keys of maps and
   * sets. Add `.deep` earlier in the chain to use deep equality instead. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
   *
   * By default, the target must have all of the given keys and no more. Add
   * `.any` earlier in the chain to only require that the target have at least
   * one of the given keys. Also, add `.not` earlier in the chain to negate
   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use
   * `.all` when asserting `.keys` without negation.
   *
   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
   * exactly what's expected of the output, whereas `.not.all.keys` creates
   * uncertain expectations.
   *
   *     // Recommended; asserts that target doesn't have any of the given keys
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   *     // Not recommended; asserts that target doesn't have all of the given
   *     // keys but may or may not have some of them
   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
   *
   * When asserting `.keys` without negation, `.all` is preferred because
   * `.all.keys` asserts exactly what's expected of the output, whereas
   * `.any.keys` creates uncertain expectations.
   *
   *     // Recommended; asserts that target has all the given keys
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   *     // Not recommended; asserts that target has at least one of the given
   *     // keys but may or may not have more of them
   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` appear
   * earlier in the chain. However, it's often best to add `.all` anyway because
   * it improves readability.
   *
   *     // Both assertions are identical
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
   *
   * Add `.include` earlier in the chain to require that the target's keys be a
   * superset of the expected keys, rather than identical sets.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   * However, if `.any` and `.include` are combined, only the `.any` takes
   * effect. The `.include` is ignored in this case.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
   *
   * The alias `.key` can be used interchangeably with `.keys`.
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , objType = _.type(obj)
      , keysType = _.type(keys)
      , ssfi = flag(this, 'ssfi')
      , isDeep = flag(this, 'deep')
      , str
      , deepStr = ''
      , actual
      , ok = true
      , flagMsg = flag(this, 'message');

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';

    if (objType === 'Map' || objType === 'Set') {
      deepStr = isDeep ? 'deeply ' : '';
      actual = [];

      // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.
      obj.forEach(function (val, key) { actual.push(key); });

      if (keysType !== 'Array') {
        keys = Array.prototype.slice.call(arguments);
      }
    } else {
      actual = _.getOwnEnumerableProperties(obj);

      switch (keysType) {
        case 'Array':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }
          break;
        case 'Object':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }
          keys = Object.keys(keys);
          break;
        default:
          keys = Array.prototype.slice.call(arguments);
      }

      // Only stringify non-Symbols because Symbols would become "Symbol()"
      keys = keys.map(function (val) {
        return typeof val === 'symbol' ? val : String(val);
      });
    }

    if (!keys.length) {
      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);
    }

    var len = keys.length
      , any = flag(this, 'any')
      , all = flag(this, 'all')
      , expected = keys;

    if (!any && !all) {
      all = true;
    }

    // Has any
    if (any) {
      ok = expected.some(function(expectedKey) {
        return actual.some(function(actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });
    }

    // Has all
    if (all) {
      ok = expected.every(function(expectedKey) {
        return actual.some(function(actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });

      if (!flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key) {
        return _.inspect(key);
      });
      var last = keys.pop();
      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }
      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + deepStr + str
      , 'expected #{this} to not ' + deepStr + str
      , expected.slice(0).sort(_.compareByInspect)
      , actual.sort(_.compareByInspect)
      , true
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw([errorLike], [errMsgMatcher], [msg])
   *
   * When no arguments are provided, `.throw` invokes the target function and
   * asserts that an error is thrown.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw();
   *
   * When one argument is provided, and it's an error constructor, `.throw`
   * invokes the target function and asserts that an error is thrown that's an
   * instance of that error constructor.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError);
   *
   * When one argument is provided, and it's an error instance, `.throw` invokes
   * the target function and asserts that an error is thrown that's strictly
   * (`===`) equal to that error instance.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(err);
   *
   * When one argument is provided, and it's a string, `.throw` invokes the
   * target function and asserts that an error is thrown with a message that
   * contains that string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw('salmon');
   *
   * When one argument is provided, and it's a regular expression, `.throw`
   * invokes the target function and asserts that an error is thrown with a
   * message that matches that regular expression.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(/salmon/);
   *
   * When two arguments are provided, and the first is an error instance or
   * constructor, and the second is a string or regular expression, `.throw`
   * invokes the function and asserts that an error is thrown that fulfills both
   * conditions as described above.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon');
   *     expect(badFn).to.throw(TypeError, /salmon/);
   *     expect(badFn).to.throw(err, 'salmon');
   *     expect(badFn).to.throw(err, /salmon/);
   *
   * Add `.not` earlier in the chain to negate `.throw`.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw();
   *
   * However, it's dangerous to negate `.throw` when providing any arguments.
   * The problem is that it creates uncertain expectations by asserting that the
   * target either doesn't throw an error, or that it throws an error but of a
   * different type than the given type, or that it throws an error of the given
   * type but with a message that doesn't include the given string. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to throw an error, it's often best to assert
   * exactly that.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw(); // Recommended
   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * When the target is expected to throw an error, it's often best to assert
   * that the error is of its expected type, and has a message that includes an
   * expected string, rather than asserting that it doesn't have one of many
   * unexpected types, and doesn't have a message that includes some string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * `.throw` changes the target of any assertions that follow in the chain to
   * be the error object that's thrown.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     err.code = 42;
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
   *
   * `.throw` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`. When not providing two arguments, always use
   * the second form.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
   *     expect(goodFn, 'nooo why fail??').to.throw();
   *
   * Due to limitations in ES5, `.throw` may not always work as expected when
   * using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing the built-in `Error` object and
   * then passing the subclassed constructor to `.throw`. See your transpiler's
   * docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * Beware of some common mistakes when using the `throw` assertion. One common
   * mistake is to accidentally invoke the function yourself instead of letting
   * the `throw` assertion invoke the function for you. For example, when
   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as
   * the target for the assertion.
   *
   *     expect(fn).to.throw();     // Good! Tests `fn` as desired
   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
   *
   * If you need to assert that your function `fn` throws when passed certain
   * arguments, then wrap a call to `fn` inside of another function.
   *
   *     expect(function () { fn(42); }).to.throw();  // Function expression
   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
   *
   * Another common mistake is to provide an object method (or any stand-alone
   * function that relies on `this`) as the target of the assertion. Doing so is
   * problematic because the `this` context will be lost when the function is
   * invoked by `.throw`; there's no way for it to know what `this` is supposed
   * to be. There are two ways around this problem. One solution is to wrap the
   * method or function call inside of another function. Another solution is to
   * use `bind`.
   *
   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
   *
   * Finally, it's worth mentioning that it's a best practice in JavaScript to
   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,
   * `TypeError`, and user-defined objects that extend `Error`. No other type of
   * value will generate a stack trace when initialized. With that said, the
   * `throw` assertion does technically support any type of value being thrown,
   * not just `Error` and its derivatives.
   *
   * The aliases `.throws` and `.Throw` can be used interchangeably with
   * `.throw`.
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {Error|ErrorConstructor} errorLike
   * @param {String|RegExp} errMsgMatcher error message
   * @param {String} msg _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows (errorLike, errMsgMatcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , ssfi = flag(this, 'ssfi')
      , flagMsg = flag(this, 'message')
      , negate = flag(this, 'negate') || false;
    new Assertion(obj, flagMsg, ssfi, true).is.a('function');

    if (errorLike instanceof RegExp || typeof errorLike === 'string') {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var caughtErr;
    try {
      obj();
    } catch (err) {
      caughtErr = err;
    }

    // If we have the negate flag enabled and at least one valid argument it means we do expect an error
    // but we want it to match a given set of criteria
    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined;

    // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
    // See Issue #551 and PR #683@GitHub
    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
    var errorLikeFail = false;
    var errMsgMatcherFail = false;

    // Checking if error was thrown
    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
      // We need this to display results correctly according to their types
      var errorLikeString = 'an error';
      if (errorLike instanceof Error) {
        errorLikeString = '#{exp}';
      } else if (errorLike) {
        errorLikeString = _.checkError.getConstructorName(errorLike);
      }

      this.assert(
          caughtErr
        , 'expected #{this} to throw ' + errorLikeString
        , 'expected #{this} to not throw an error but #{act} was thrown'
        , errorLike && errorLike.toString()
        , (caughtErr instanceof Error ?
            caughtErr.toString() : (typeof caughtErr === 'string' ? caughtErr : caughtErr &&
                                    _.checkError.getConstructorName(caughtErr)))
      );
    }

    if (errorLike && caughtErr) {
      // We should compare instances only if `errorLike` is an instance of `Error`
      if (errorLike instanceof Error) {
        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);

        if (isCompatibleInstance === negate) {
          // These checks were created to ensure we won't fail too soon when we've got both args and a negate
          // See Issue #551 and PR #683@GitHub
          if (everyArgIsDefined && negate) {
            errorLikeFail = true;
          } else {
            this.assert(
                negate
              , 'expected #{this} to throw #{exp} but #{act} was thrown'
              , 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : '')
              , errorLike.toString()
              , caughtErr.toString()
            );
          }
        }
      }

      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);
      if (isCompatibleConstructor === negate) {
        if (everyArgIsDefined && negate) {
            errorLikeFail = true;
        } else {
          this.assert(
              negate
            , 'expected #{this} to throw #{exp} but #{act} was thrown'
            , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')
            , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))
            , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))
          );
        }
      }
    }

    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
      // Here we check compatible messages
      var placeholder = 'including';
      if (errMsgMatcher instanceof RegExp) {
        placeholder = 'matching';
      }

      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);
      if (isCompatibleMessage === negate) {
        if (everyArgIsDefined && negate) {
            errMsgMatcherFail = true;
        } else {
          this.assert(
            negate
            , 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}'
            , 'expected #{this} to throw error not ' + placeholder + ' #{exp}'
            ,  errMsgMatcher
            ,  _.checkError.getMessage(caughtErr)
          );
        }
      }
    }

    // If both assertions failed and both should've matched we throw an error
    if (errorLikeFail && errMsgMatcherFail) {
      this.assert(
        negate
        , 'expected #{this} to throw #{exp} but #{act} was thrown'
        , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')
        , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))
        , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))
      );
    }

    flag(this, 'object', caughtErr);
  }
  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method[, msg])
   *
   * When the target is a non-function object, `.respondTo` asserts that the
   * target has a method with the given name `method`. The method can be own or
   * inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.respondTo('meow');
   *
   * When the target is a function, `.respondTo` asserts that the target's
   * `prototype` property has a method with the given name `method`. Again, the
   * method can be own or inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(Cat).to.respondTo('meow');
   *
   * Add `.itself` earlier in the chain to force `.respondTo` to treat the
   * target as a non-function object, even if it's a function. Thus, it asserts
   * that the target has a method with the given name `method`, rather than
   * asserting that the target's `prototype` property has a method with the
   * given name `method`.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * When not adding `.itself`, it's important to check the target's type before
   * using `.respondTo`. See the `.a` doc for info on checking a target's type.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
   *
   * Add `.not` earlier in the chain to negate `.respondTo`.
   *
   *     function Dog () {}
   *     Dog.prototype.bark = function () {};
   *
   *     expect(new Dog()).to.not.respondTo('meow');
   *
   * `.respondTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect({}).to.respondTo('meow', 'nooo why fail??');
   *     expect({}, 'nooo why fail??').to.respondTo('meow');
   *
   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === typeof obj && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);

  /**
   * ### .itself
   *
   * Forces all `.respondTo` assertions that follow in the chain to behave as if
   * the target is a non-function object, even if it's a function. Thus, it
   * causes `.respondTo` to assert that the target has a method with the given
   * name, rather than asserting that the target's `prototype` property has a
   * method with the given name.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(matcher[, msg])
   *
   * Invokes the given `matcher` function with the target being passed as the
   * first argument, and asserts that the value returned is truthy.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 0;
   *     });
   *
   * Add `.not` earlier in the chain to negate `.satisfy`.
   *
   *     expect(1).to.not.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * `.satisfy` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 2;
   *     }, 'nooo why fail??');
   *
   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * The alias `.satisfies` can be used interchangeably with `.satisfy`.
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(
        result
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , flag(this, 'negate') ? false : true
      , result
    );
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);

  /**
   * ### .closeTo(expected, delta[, msg])
   *
   * Asserts that the target is a number that's within a given +/- `delta` range
   * of the given number `expected`. However, it's often best to assert that the
   * target is equal to its expected value.
   *
   *     // Recommended
   *     expect(1.5).to.equal(1.5);
   *
   *     // Not recommended
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *     expect(1.5).to.be.closeTo(2, 0.5);
   *     expect(1.5).to.be.closeTo(1, 1);
   *
   * Add `.not` earlier in the chain to negate `.closeTo`.
   *
   *     expect(1.5).to.equal(1.5); // Recommended
   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
   *
   * `.closeTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
   *
   * The alias `.approximately` can be used interchangeably with `.closeTo`.
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');

    new Assertion(obj, flagMsg, ssfi, true).is.a('number');
    if (typeof expected !== 'number' || typeof delta !== 'number') {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(
          flagMsg + 'the arguments to closeTo or approximately must be numbers',
          undefined,
          ssfi
      );
    }

    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo);

  // Note: Duplicates are ignored if testing for inclusion instead of sameness.
  function isSubsetOf(subset, superset, cmp, contains, ordered) {
    if (!contains) {
      if (subset.length !== superset.length) return false;
      superset = superset.slice();
    }

    return subset.every(function(elem, idx) {
      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];

      if (!cmp) {
        var matchIdx = superset.indexOf(elem);
        if (matchIdx === -1) return false;

        // Remove match from superset so not counted twice if duplicate in subset.
        if (!contains) superset.splice(matchIdx, 1);
        return true;
      }

      return superset.some(function(elem2, matchIdx) {
        if (!cmp(elem, elem2)) return false;

        // Remove match from superset so not counted twice if duplicate in subset.
        if (!contains) superset.splice(matchIdx, 1);
        return true;
      });
    });
  }

  /**
   * ### .members(set[, msg])
   *
   * Asserts that the target array has the same members as the given array
   * `set`.
   *
   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
   *
   * By default, members are compared using strict (`===`) equality. Add `.deep`
   * earlier in the chain to use deep equality instead. See the `deep-eql`
   * project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   * By default, order doesn't matter. Add `.ordered` earlier in the chain to
   * require that members appear in the same order.
   *
   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
   *       .but.not.ordered.members([2, 1, 3]);
   *
   * By default, both arrays must be the same size. Add `.include` earlier in
   * the chain to require that the target's members be a superset of the
   * expected members. Note that duplicates are ignored in the subset when
   * `.include` is added.
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * `.deep`, `.ordered`, and `.include` can all be combined. However, if
   * `.include` and `.ordered` are combined, the ordering begins at the start of
   * both arrays.
   *
   *     expect([{a: 1}, {b: 2}, {c: 3}])
   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
   *
   * Add `.not` earlier in the chain to negate `.members`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the target array doesn't have all of the same members as
   * the given array `set` but may or may not have some of them. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
   *
   * `.members` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
   *
   * @name members
   * @param {Array} set
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');

    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');
    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');

    var contains = flag(this, 'contains');
    var ordered = flag(this, 'ordered');

    var subject, failMsg, failNegateMsg;

    if (contains) {
      subject = ordered ? 'an ordered superset' : 'a superset';
      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';
    } else {
      subject = ordered ? 'ordered members' : 'members';
      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';
    }

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    this.assert(
        isSubsetOf(subset, obj, cmp, contains, ordered)
      , failMsg
      , failNegateMsg
      , subset
      , obj
      , true
    );
  });

  /**
   * ### .oneOf(list[, msg])
   *
   * Asserts that the target is a member of the given array `list`. However,
   * it's often best to assert that the target is equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
   *
   * Comparisons are performed using strict (`===`) equality.
   *
   * Add `.not` earlier in the chain to negate `.oneOf`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
   *
   * `.oneOf` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf (list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');
    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');

    this.assert(
        list.indexOf(expected) > -1
      , 'expected #{this} to be one of #{exp}'
      , 'expected #{this} to not be one of #{exp}'
      , list
      , expected
    );
  }

  Assertion.addMethod('oneOf', oneOf);

  /**
   * ### .change(subject[, prop[, msg]])
   *
   * When one argument is provided, `.change` asserts that the given function
   * `subject` returns a different value when it's invoked before the target
   * function compared to when it's invoked afterward. However, it's often best
   * to assert that `subject` is equal to its expected value.
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     // Recommended
   *     expect(getDots()).to.equal('');
   *     addDot();
   *     expect(getDots()).to.equal('.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(getDots);
   *
   * When two arguments are provided, `.change` asserts that the value of the
   * given object `subject`'s `prop` property is different before invoking the
   * target function compared to afterward.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     // Recommended
   *     expect(myObj).to.have.property('dots', '');
   *     addDot();
   *     expect(myObj).to.have.property('dots', '.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(myObj, 'dots');
   *
   * Strict (`===`) equality is used to compare before and after values.
   *
   * Add `.not` earlier in the chain to negate `.change`.
   *
   *     var dots = ''
   *       , noop = function () {}
   *       , getDots = function () { return dots; };
   *
   *     expect(noop).to.not.change(getDots);
   *
   *     var myObj = {dots: ''}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'dots');
   *
   * `.change` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
   *
   * `.change` also causes all `.by` assertions that follow in the chain to
   * assert how much a numeric subject was increased or decreased by. However,
   * it's dangerous to use `.change.by`. The problem is that it creates
   * uncertain expectations by asserting that the subject either increases by
   * the given delta, or that it decreases by the given delta. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * The alias `.changes` can be used interchangeably with `.change`.
   *
   * @name change
   * @alias changes
   * @param {String} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges (subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');

    var initial;
    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    fn();

    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

    // This gets flagged because of the .by(delta) assertion
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'change');
    flag(this, 'realDelta', final !== initial);

    this.assert(
      initial !== final
      , 'expected ' + msgObj + ' to change'
      , 'expected ' + msgObj + ' to not change'
    );
  }

  Assertion.addMethod('change', assertChanges);
  Assertion.addMethod('changes', assertChanges);

  /**
   * ### .increase(subject[, prop[, msg]])
   *
   * When one argument is provided, `.increase` asserts that the given function
   * `subject` returns a greater number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.increase` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * greater of a number is returned. It's often best to assert that the return
   * value increased by the expected amount, rather than asserting it increased
   * by any amount.
   *
   *     var val = 1
   *       , addTwo = function () { val += 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
   *     expect(addTwo).to.increase(getVal); // Not recommended
   *
   * When two arguments are provided, `.increase` asserts that the value of the
   * given object `subject`'s `prop` property is greater after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.increase`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either decreases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to decrease, it's often best to assert that it
   * decreased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
   *
   * `.increase` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.increase(getVal);
   *
   * The alias `.increases` can be used interchangeably with `.increase`.
   *
   * @name increase
   * @alias increases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases (subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');

    var initial;
    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    // Make sure that the target is a number
    new Assertion(initial, flagMsg, ssfi, true).is.a('number');

    fn();

    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'increase');
    flag(this, 'realDelta', final - initial);

    this.assert(
      final - initial > 0
      , 'expected ' + msgObj + ' to increase'
      , 'expected ' + msgObj + ' to not increase'
    );
  }

  Assertion.addMethod('increase', assertIncreases);
  Assertion.addMethod('increases', assertIncreases);

  /**
   * ### .decrease(subject[, prop[, msg]])
   *
   * When one argument is provided, `.decrease` asserts that the given function
   * `subject` returns a lesser number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.decrease` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * lesser of a number is returned. It's often best to assert that the return
   * value decreased by the expected amount, rather than asserting it decreased
   * by any amount.
   *
   *     var val = 1
   *       , subtractTwo = function () { val -= 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
   *
   * When two arguments are provided, `.decrease` asserts that the value of the
   * given object `subject`'s `prop` property is lesser after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.decrease`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either increases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to increase, it's often best to assert that it
   * increased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * `.decrease` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
   *
   * The alias `.decreases` can be used interchangeably with `.decrease`.
   *
   * @name decrease
   * @alias decreases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases (subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');

    var initial;
    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    // Make sure that the target is a number
    new Assertion(initial, flagMsg, ssfi, true).is.a('number');

    fn();

    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'decrease');
    flag(this, 'realDelta', initial - final);

    this.assert(
      final - initial < 0
      , 'expected ' + msgObj + ' to decrease'
      , 'expected ' + msgObj + ' to not decrease'
    );
  }

  Assertion.addMethod('decrease', assertDecreases);
  Assertion.addMethod('decreases', assertDecreases);

  /**
   * ### .by(delta[, msg])
   *
   * When following an `.increase` assertion in the chain, `.by` asserts that
   * the subject of the `.increase` assertion increased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   * When following a `.decrease` assertion in the chain, `.by` asserts that the
   * subject of the `.decrease` assertion decreased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
   *
   * When following a `.change` assertion in the chain, `.by` asserts that the
   * subject of the `.change` assertion either increased or decreased by the
   * given `delta`. However, it's dangerous to use `.change.by`. The problem is
   * that it creates uncertain expectations. It's often best to identify the
   * exact output that's expected, and then write an assertion that only accepts
   * that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.by`. However, it's often best
   * to assert that the subject changed by its expected delta, rather than
   * asserting that it didn't change by one of countless unexpected deltas.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     // Recommended
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   *     // Not recommended
   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
   *
   * `.by` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
   *
   * @name by
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDelta(delta, msg) {
    if (msg) flag(this, 'message', msg);

    var msgObj = flag(this, 'deltaMsgObj');
    var initial = flag(this, 'initialDeltaValue');
    var final = flag(this, 'finalDeltaValue');
    var behavior = flag(this, 'deltaBehavior');
    var realDelta = flag(this, 'realDelta');

    var expression;
    if (behavior === 'change') {
      expression = Math.abs(final - initial) === Math.abs(delta);
    } else {
      expression = realDelta === Math.abs(delta);
    }

    this.assert(
      expression
      , 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta
      , 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta
    );
  }

  Assertion.addMethod('by', assertDelta);

  /**
   * ### .extensible
   *
   * Asserts that the target is extensible, which means that new properties can
   * be added to it. Primitives are never extensible.
   *
   *     expect({a: 1}).to.be.extensible;
   *
   * Add `.not` earlier in the chain to negate `.extensible`.
   *
   *     var nonExtensibleObject = Object.preventExtensions({})
   *       , sealedObject = Object.seal({})
   *       , frozenObject = Object.freeze({});
   *
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *     expect(1).to.not.be.extensible;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(1, 'nooo why fail??').to.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior for ES5 environments.

    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);

    this.assert(
      isExtensible
      , 'expected #{this} to be extensible'
      , 'expected #{this} to not be extensible'
    );
  });

  /**
   * ### .sealed
   *
   * Asserts that the target is sealed, which means that new properties can't be
   * added to it, and its existing properties can't be reconfigured or deleted.
   * However, it's possible that its existing properties can still be reassigned
   * to different values. Primitives are always sealed.
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect(1).to.be.sealed;
   *
   * Add `.not` earlier in the chain to negate `.sealed`.
   *
   *     expect({a: 1}).to.not.be.sealed;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior for ES5 environments.

    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;

    this.assert(
      isSealed
      , 'expected #{this} to be sealed'
      , 'expected #{this} to not be sealed'
    );
  });

  /**
   * ### .frozen
   *
   * Asserts that the target is frozen, which means that new properties can't be
   * added to it, and its existing properties can't be reassigned to different
   * values, reconfigured, or deleted. Primitives are always frozen.
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect(1).to.be.frozen;
   *
   * Add `.not` earlier in the chain to negate `.frozen`.
   *
   *     expect({a: 1}).to.not.be.frozen;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior for ES5 environments.

    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;

    this.assert(
      isFrozen
      , 'expected #{this} to be frozen'
      , 'expected #{this} to not be frozen'
    );
  });

  /**
   * ### .finite
   *
   * Asserts that the target is a number, and isn't `NaN` or positive/negative
   * `Infinity`.
   *
   *     expect(1).to.be.finite;
   *
   * Add `.not` earlier in the chain to negate `.finite`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either isn't a number, or that it's `NaN`, or
   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to be a number, it's often best to assert
   * that it's the expected type, rather than asserting that it isn't one of
   * many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.finite; // Not recommended
   *
   * When the target is expected to be `NaN`, it's often best to assert exactly
   * that.
   *
   *     expect(NaN).to.be.NaN; // Recommended
   *     expect(NaN).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be positive infinity, it's often best to
   * assert exactly that.
   *
   *     expect(Infinity).to.equal(Infinity); // Recommended
   *     expect(Infinity).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be negative infinity, it's often best to
   * assert exactly that.
   *
   *     expect(-Infinity).to.equal(-Infinity); // Recommended
   *     expect(-Infinity).to.not.be.finite; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect('foo', 'nooo why fail??').to.be.finite;
   *
   * @name finite
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('finite', function(msg) {
    var obj = flag(this, 'object');

    this.assert(
        typeof obj === 'number' && isFinite(obj)
      , 'expected #{this} to be a finite number'
      , 'expected #{this} to not be a finite number'
    );
  });
};

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var expect = function (chai, util$$1) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };

  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   *     expect.fail();
   *     expect.fail("custom error message");
   *     expect.fail(1, 2);
   *     expect.fail(1, 2, "custom error message");
   *     expect.fail(1, 2, "custom error message", ">");
   *     expect.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace BDD
   * @api public
   */

  chai.expect.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
        message = actual;
        actual = undefined;
    }

    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, chai.expect.fail);
  };
};

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var should = function (chai, util$$1) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String
          || this instanceof Number
          || this instanceof Boolean
          || typeof Symbol === 'function' && this instanceof Symbol) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    /**
     * ### .fail([message])
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     *     should.fail();
     *     should.fail("custom error message");
     *     should.fail(1, 2);
     *     should.fail(1, 2, "custom error message");
     *     should.fail(1, 2, "custom error message", ">");
     *     should.fail(1, 2, undefined, ">");
     *
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace BDD
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      if (arguments.length < 2) {
          message = actual;
          actual = undefined;
      }

      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
          actual: actual
        , expected: expected
        , operator: operator
      }, should.fail);
    };

    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    };

    // negation
    should.not = {};

    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    };

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  }
  chai.should = loadShould;
  chai.Should = loadShould;
};

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var assert = function (chai, util$$1) {
  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util$$1.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert, true);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   *     assert.fail();
   *     assert.fail("custom error message");
   *     assert.fail(1, 2);
   *     assert.fail(1, 2, "custom error message");
   *     assert.fail(1, 2, "custom error message", ">");
   *     assert.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
        // Comply with Node's fail([message]) interface

        message = actual;
        actual = undefined;
    }

    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isOk = function (val, msg) {
    new Assertion(val, msg, assert.isOk, true).is.ok;
  };

  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal, true);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
      , true
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual, true);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
      , true
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @alias deepStrictEqual
   * @namespace Assert
   * @api public
   */

  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
  };

   /**
   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
   *
   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.
   *
   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
   *
   * @name isAbove
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAbove
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
  };

   /**
   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
   *
   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.
   *
   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
   *
   * @name isAtLeast
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtLeast
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
  };

   /**
   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
   *
   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.
   *
   *     assert.isBelow(3, 6, '3 is strictly less than 6');
   *
   * @name isBelow
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeBelow
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
  };

   /**
   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
   *
   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.
   *
   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
   *
   * @name isAtMost
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtMost
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg, assert.isTrue, true).is['true'];
  };

  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg, assert.isFalse, true).is['false'];
  };

  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg, assert.isNull, true).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
  };

  /**
   * ### .isNaN
   *
   * Asserts that value is NaN.
   *
   *     assert.isNaN(NaN, 'NaN is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
  };

  /**
   * ### .isNotNaN
   *
   * Asserts that value is not NaN.
   *
   *     assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */
  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;
  };

  /**
   * ### .exists
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi';
   *
   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');
   *
   * @name exists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.exists = function (val, msg) {
    new Assertion(val, msg, assert.exists, true).to.exist;
  };

  /**
   * ### .notExists
   *
   * Asserts that the target is either `null` or `undefined`.
   *
   *     var bar = null
   *       , baz;
   *
   *     assert.notExists(bar);
   *     assert.notExists(baz, 'baz is either null or undefined');
   *
   * @name notExists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notExists = function (val, msg) {
    new Assertion(val, msg, assert.notExists, true).to.not.exist;
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg, assert.isObject, true).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg, assert.isArray, true).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg, assert.isString, true).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');
  };

   /**
   * ### .isFinite(value, [message])
   *
   * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
   *
   *     var cups = 2;
   *     assert.isFinite(cups, 'how many cups');
   *
   *     assert.isFinite(NaN); // throws
   *
   * @name isFinite
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFinite = function (val, msg) {
    new Assertion(val, msg, assert.isFinite, true).to.be.finite;
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notInstanceOf, true)
      .to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.include([1,2,3], 2, 'array contains value');
   *     assert.include('foobar', 'foo', 'string contains substring');
   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
   *
   * Strict equality (===) is used. When asserting the inclusion of a value in
   * an array, the array is searched for an element that's strictly equal to the
   * given value. When asserting a subset of properties in an object, the object
   * is searched for the given property keys, checking that each one is present
   * and strictly equal to the given property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.include([obj1, obj2], obj1);
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include, true).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.notInclude([1,2,3], 4, "array doesn't contain value");
   *     assert.notInclude('foobar', 'baz', "string doesn't contain substring");
   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
   *
   * Strict equality (===) is used. When asserting the absence of a value in an
   * array, the array is searched to confirm the absence of an element that's
   * strictly equal to the given value. When asserting a subset of properties in
   * an object, the object is searched to confirm that at least one of the given
   * property keys is either not present or not strictly equal to the given
   * property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notInclude([obj1, obj2], {a: 1});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
  };

  /**
   * ### .deepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.deepInclude([obj1, obj2], {a: 1});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
   *
   * @name deepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
  };

  /**
   * ### .notDeepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notDeepInclude([obj1, obj2], {a: 9});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
   *
   * @name notDeepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
  };

  /**
   * ### .nestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
   *
   * @name nestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.nestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
  };

  /**
   * ### .notNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
   *
   * @name notNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notNestedInclude, true)
      .not.nested.include(inc);
  };

  /**
   * ### .deepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
   *
   * @name deepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepNestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.deepNestedInclude, true)
      .deep.nested.include(inc);
  };

  /**
   * ### .notDeepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
   *
   * @name notDeepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepNestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepNestedInclude, true)
      .not.deep.nested.include(inc);
  };

  /**
   * ### .ownInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     assert.ownInclude({ a: 1 }, { a: 1 });
   *
   * @name ownInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.ownInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
  };

  /**
   * ### .notOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
   *
   * @name notOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
  };

  /**
   * ### .deepOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties and checking for deep equality.
   *
   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
   *
   * @name deepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.deepOwnInclude, true)
      .deep.own.include(inc);
  };

   /**
   * ### .notDeepOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while ignoring inherited properties and checking for deep equality.
   *
   *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
   *
   * @name notDeepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepOwnInclude, true)
      .not.deep.own.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg, assert.match, true).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.property, true).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notProperty, true)
      .to.not.have.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.propertyVal, true)
      .to.have.property(prop, val);
  };

  /**
   * ### .notPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
   *
   * @name notPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notPropertyVal, true)
      .to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a deep equality check.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepPropertyVal, true)
      .to.have.deep.property(prop, val);
  };

  /**
   * ### .notDeepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a deep equality check.
   *
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *
   * @name notDeepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepPropertyVal, true)
      .to.not.have.deep.property(prop, val);
  };

  /**
   * ### .ownProperty(object, property, [message])
   *
   * Asserts that `object` has a direct property named by `property`. Inherited
   * properties aren't checked.
   *
   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name ownProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.ownProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.ownProperty, true)
      .to.have.own.property(prop);
  };

  /**
   * ### .notOwnProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by
   * `property`. Inherited properties aren't checked.
   *
   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
   *     assert.notOwnProperty({}, 'toString');
   *
   * @name notOwnProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notOwnProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notOwnProperty, true)
      .to.not.have.own.property(prop);
  };

  /**
   * ### .ownPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a strict equality check (===).
   * Inherited properties aren't checked.
   *
   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
   *
   * @name ownPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.ownPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.ownPropertyVal, true)
      .to.have.own.property(prop, value);
  };

  /**
   * ### .notOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a strict equality check
   * (===). Inherited properties aren't checked.
   *
   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.notOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notOwnPropertyVal, true)
      .to.not.have.own.property(prop, value);
  };

  /**
   * ### .deepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a deep equality check. Inherited
   * properties aren't checked.
   *
   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.deepOwnPropertyVal, true)
      .to.have.deep.own.property(prop, value);
  };

  /**
   * ### .notDeepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a deep equality check.
   * Inherited properties aren't checked.
   *
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notDeepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true)
      .to.not.have.deep.own.property(prop, value);
  };

  /**
   * ### .nestedProperty(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`, which can be a string using dot- and bracket-notation for
   * nested reference.
   *
   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name nestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.nestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.nestedProperty, true)
      .to.have.nested.property(prop);
  };

  /**
   * ### .notNestedProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for nested reference. The
   * property cannot exist on the object nor anywhere in its prototype chain.
   *
   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notNestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notNestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notNestedProperty, true)
      .to.not.have.nested.property(prop);
  };

  /**
   * ### .nestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a strict equality check (===).
   *
   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name nestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.nestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.nestedPropertyVal, true)
      .to.have.nested.property(prop, val);
  };

  /**
   * ### .notNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a strict equality check (===).
   *
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
   *
   * @name notNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notNestedPropertyVal, true)
      .to.not.have.nested.property(prop, val);
  };

  /**
   * ### .deepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with a value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a deep equality check.
   *
   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
   *
   * @name deepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepNestedPropertyVal, true)
      .to.have.deep.nested.property(prop, val);
  };

  /**
   * ### .notDeepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a deep equality check.
   *
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
   *
   * @name notDeepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true)
      .to.not.have.deep.nested.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` or `size` with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');
   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
  };

  /**
   * ### .hasAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAnyKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.hasAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
  };

  /**
   * ### .hasAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all and only all of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.hasAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
  };

  /**
   * ### .containsAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name containsAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.containsAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllKeys, true)
      .to.contain.all.keys(keys);
  };

  /**
   * ### .doesNotHaveAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has none of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAnyKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true)
      .to.not.have.any.keys(keys);
  };

  /**
   * ### .doesNotHaveAllKeys(object, [keys], [message])
   *
   * Asserts that `object` does not have at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.doesNotHaveAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true)
      .to.not.have.all.keys(keys);
  };

  /**
   * ### .hasAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.hasAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyDeepKeys, true)
      .to.have.any.deep.keys(keys);
  };

 /**
   * ### .hasAllDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has all and only all of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
   *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name hasAllDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.hasAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllDeepKeys, true)
      .to.have.all.deep.keys(keys);
  };

 /**
   * ### .containsAllDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` contains all of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name containsAllDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.containsAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllDeepKeys, true)
      .to.contain.all.deep.keys(keys);
  };

 /**
   * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has none of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
   *
   * @name doesNotHaveAnyDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true)
      .to.not.have.any.deep.keys(keys);
  };

 /**
   * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` does not have at least one of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
   *
   * @name doesNotHaveAllDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true)
      .to.not.have.all.deep.keys(keys);
  };

 /**
   * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
   * instance of `errorLike`.
   * If `errorLike` is an `Error` instance, asserts that the error thrown is the same
   * instance as `errorLike`.
   * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
   * message matching `errMsgMatcher`.
   *
   *     assert.throws(fn, 'Error thrown must have this msg');
   *     assert.throws(fn, /Error thrown must have a msg that matches this/);
   *     assert.throws(fn, ReferenceError);
   *     assert.throws(fn, errorInstance);
   *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
   *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
   *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
   *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} fn
   * @param {ErrorConstructor|Error} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var assertErr = new Assertion(fn, msg, assert.throws, true)
      .to.throw(errorLike, errMsgMatcher);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
   * instance of `errorLike`.
   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
   * instance as `errorLike`.
   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
   * message matching `errMsgMatcher`.
   *
   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
   *     assert.doesNotThrow(fn, Error);
   *     assert.doesNotThrow(fn, errorInstance);
   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
   *
   * @name doesNotThrow
   * @param {Function} fn
   * @param {ErrorConstructor} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    new Assertion(fn, msg, assert.doesNotThrow, true)
      .to.not.throw(errorLike, errMsgMatcher);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    var ok;
    switch(operator) {
      case '==':
        ok = val == val2;
        break;
      case '===':
        ok = val === val2;
        break;
      case '>':
        ok = val > val2;
        break;
      case '>=':
        ok = val >= val2;
        break;
      case '<':
        ok = val < val2;
        break;
      case '<=':
        ok = val <= val2;
        break;
      case '!=':
        ok = val != val2;
        break;
      case '!==':
        ok = val !== val2;
        break;
      default:
        msg = msg ? msg + ': ' : msg;
        throw new chai.AssertionError(
          msg + 'Invalid operator "' + operator + '"',
          undefined,
          assert.operator
        );
    }
    var test = new Assertion(ok, msg, assert.operator, true);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util$$1.inspect(val) + ' to be ' + operator + ' ' + util$$1.inspect(val2)
      , 'expected ' + util$$1.inspect(val) + ' to not be ' + operator + ' ' + util$$1.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
  };

  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.approximately, true)
      .to.be.approximately(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * strict equality check (===).
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameMembers, true)
      .to.have.same.members(set2);
  };

  /**
   * ### .notSameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a strict equality check (===).
   *
   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
   *
   * @name notSameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notSameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameMembers, true)
      .to.not.have.same.members(set2);
  };

  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * deep equality check.
   *
   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepMembers, true)
      .to.have.same.deep.members(set2);
  };

  /**
   * ### .notSameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a deep equality check.
   *
   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
   *
   * @name notSameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notSameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepMembers, true)
      .to.not.have.same.deep.members(set2);
  };

  /**
   * ### .sameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a strict equality check (===).
   *
   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
   *
   * @name sameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameOrderedMembers, true)
      .to.have.same.ordered.members(set2);
  };

  /**
   * ### .notSameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a strict equality check (===).
   *
   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
   *
   * @name notSameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notSameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameOrderedMembers, true)
      .to.not.have.same.ordered.members(set2);
  };

  /**
   * ### .sameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a deep equality check.
   *
   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
   *
   * @name sameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true)
      .to.have.same.deep.ordered.members(set2);
  };

  /**
   * ### .notSameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a deep equality check.
   *
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
   *
   * @name notSameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true)
      .to.not.have.same.deep.ordered.members(set2);
  };

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeMembers, true)
      .to.include.members(subset);
  };

  /**
   * ### .notIncludeMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
   *
   * @name notIncludeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notIncludeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeMembers, true)
      .to.not.include.members(subset);
  };

  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a deep
   * equality check. Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepMembers, true)
      .to.include.deep.members(subset);
  };

  /**
   * ### .notIncludeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * deep equality check. Duplicates are ignored.
   *
   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
   *
   * @name notIncludeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notIncludeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepMembers, true)
      .to.not.include.deep.members(subset);
  };

  /**
   * ### .includeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
   *
   * @name includeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeOrderedMembers, true)
      .to.include.ordered.members(subset);
  };

  /**
   * ### .notIncludeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
   *
   * @name notIncludeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notIncludeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true)
      .to.not.include.ordered.members(subset);
  };

  /**
   * ### .includeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
   *
   * @name includeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true)
      .to.include.deep.ordered.members(subset);
  };

  /**
   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
   *
   * @name notIncludeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true)
      .to.not.include.deep.ordered.members(subset);
  };

  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
  };

  /**
   * ### .changes(function, object, property, [message])
   *
   * Asserts that a function changes the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.changes = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
  };

   /**
   * ### .changesBy(function, object, property, delta, [message])
   *
   * Asserts that a function changes the value of a property by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 2 };
   *     assert.changesBy(fn, obj, 'val', 2);
   *
   * @name changesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.changesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesBy, true)
      .to.change(obj, prop).by(delta);
  };

   /**
   * ### .doesNotChange(function, object, property, [message])
   *
   * Asserts that a function does not change the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { console.log('foo'); };
   *     assert.doesNotChange(fn, obj, 'val');
   *
   * @name doesNotChange
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotChange = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotChange, true)
      .to.not.change(obj, prop);
  };

  /**
   * ### .changesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.changesButNotBy(fn, obj, 'val', 5);
   *
   * @name changesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesButNotBy, true)
      .to.change(obj, prop).but.not.by(delta);
  };

  /**
   * ### .increases(function, object, property, [message])
   *
   * Asserts that a function increases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.increases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.increases, true)
      .to.increase(obj, prop);
  };

  /**
   * ### .increasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.increasesBy(fn, obj, 'val', 10);
   *
   * @name increasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.increasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesBy, true)
      .to.increase(obj, prop).by(delta);
  };

  /**
   * ### .doesNotIncrease(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotIncrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotIncrease, true)
      .to.not.increase(obj, prop);
  };

  /**
   * ### .increasesButNotBy(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.increasesButNotBy(fn, obj, 'val', 10);
   *
   * @name increasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesButNotBy, true)
      .to.increase(obj, prop).but.not.by(delta);
  };

  /**
   * ### .decreases(function, object, property, [message])
   *
   * Asserts that a function decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.decreases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.decreases, true)
      .to.decrease(obj, prop);
  };

  /**
   * ### .decreasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val -= 5 };
   *     assert.decreasesBy(fn, obj, 'val', 5);
   *
   * @name decreasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.decreasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesBy, true)
      .to.decrease(obj, prop).by(delta);
  };

  /**
   * ### .doesNotDecrease(function, object, property, [message])
   *
   * Asserts that a function does not decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotDecrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecrease, true)
      .to.not.decrease(obj, prop);
  };

  /**
   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true)
      .to.not.decrease(obj, prop).by(delta);
  };

  /**
   * ### .decreasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
   *
   * @name decreasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesButNotBy, true)
      .to.decrease(obj, prop).but.not.by(delta);
  };

  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */

  assert.ifError = function (val) {
    if (val) {
      throw(val);
    }
  };

  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
  };

  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
  };

  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
  };

  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
  };

  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
  };

  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
  };

  /**
   * ### .isEmpty(target)
   *
   * Asserts that the target does not contain any values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isEmpty([]);
   *     assert.isEmpty('');
   *     assert.isEmpty(new Map);
   *     assert.isEmpty({});
   *
   * @name isEmpty
   * @alias empty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isEmpty = function(val, msg) {
    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
  };

  /**
   * ### .isNotEmpty(target)
   *
   * Asserts that the target contains values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isNotEmpty([1, 2]);
   *     assert.isNotEmpty('34');
   *     assert.isNotEmpty(new Set([5, 6]));
   *     assert.isNotEmpty({ key: 7 });
   *
   * @name isNotEmpty
   * @alias notEmpty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotEmpty = function(val, msg) {
    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('isOk', 'ok')
  ('isNotOk', 'notOk')
  ('throws', 'throw')
  ('throws', 'Throw')
  ('isExtensible', 'extensible')
  ('isNotExtensible', 'notExtensible')
  ('isSealed', 'sealed')
  ('isNotSealed', 'notSealed')
  ('isFrozen', 'frozen')
  ('isNotFrozen', 'notFrozen')
  ('isEmpty', 'empty')
  ('isNotEmpty', 'notEmpty');
};

var chai = createCommonjsModule(function (module, exports) {
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = [];

/*!
 * Chai version
 */

exports.version = '4.2.0';

/*!
 * Assertion Error
 */

exports.AssertionError = assertionError;

/*!
 * Utils for plugins (not exported)
 */



/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai.
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(exports, utils);
    used.push(fn);
  }

  return exports;
};

/*!
 * Utility Functions
 */

exports.util = utils;

/*!
 * Configuration
 */


exports.config = config;

/*!
 * Primary `Assertion` prototype
 */


exports.use(assertion);

/*!
 * Core Assertions
 */


exports.use(assertions);

/*!
 * Expect interface
 */


exports.use(expect);

/*!
 * Should interface
 */


exports.use(should);

/*!
 * Assert interface
 */


exports.use(assert);
});
var chai_1 = chai.version;
var chai_2 = chai.AssertionError;
var chai_3 = chai.use;
var chai_4 = chai.util;
var chai_5 = chai.config;

var chai$1 = chai;

var chaiAsPromised = createCommonjsModule(function (module) {
/* eslint-disable no-invalid-this */
let checkError$$1 = checkError;

module.exports = (chai, utils) => {
    const Assertion = chai.Assertion;
    const assert = chai.assert;
    const proxify = utils.proxify;

    // If we are using a version of Chai that has checkError on it,
    // we want to use that version to be consistent. Otherwise, we use
    // what was passed to the factory.
    if (utils.checkError) {
        checkError$$1 = utils.checkError;
    }

    function isLegacyJQueryPromise(thenable) {
        // jQuery promises are Promises/A+-compatible since 3.0.0. jQuery 3.0.0 is also the first version
        // to define the catch method.
        return typeof thenable.catch !== "function" &&
               typeof thenable.always === "function" &&
               typeof thenable.done === "function" &&
               typeof thenable.fail === "function" &&
               typeof thenable.pipe === "function" &&
               typeof thenable.progress === "function" &&
               typeof thenable.state === "function";
    }

    function assertIsAboutPromise(assertion) {
        if (typeof assertion._obj.then !== "function") {
            throw new TypeError(utils.inspect(assertion._obj) + " is not a thenable.");
        }
        if (isLegacyJQueryPromise(assertion._obj)) {
            throw new TypeError("Chai as Promised is incompatible with thenables of jQuery<3.0.0, sorry! Please " +
                                "upgrade jQuery or use another Promises/A+ compatible library (see " +
                                "http://promisesaplus.com/).");
        }
    }

    function proxifyIfSupported(assertion) {
        return proxify === undefined ? assertion : proxify(assertion);
    }

    function method(name, asserter) {
        utils.addMethod(Assertion.prototype, name, function () {
            assertIsAboutPromise(this);
            return asserter.apply(this, arguments);
        });
    }

    function property(name, asserter) {
        utils.addProperty(Assertion.prototype, name, function () {
            assertIsAboutPromise(this);
            return proxifyIfSupported(asserter.apply(this, arguments));
        });
    }

    function doNotify(promise, done) {
        promise.then(() => done(), done);
    }

    // These are for clarity and to bypass Chai refusing to allow `undefined` as actual when used with `assert`.
    function assertIfNegated(assertion, message, extra) {
        assertion.assert(true, null, message, extra.expected, extra.actual);
    }

    function assertIfNotNegated(assertion, message, extra) {
        assertion.assert(false, message, null, extra.expected, extra.actual);
    }

    function getBasePromise(assertion) {
        // We need to chain subsequent asserters on top of ones in the chain already (consider
        // `eventually.have.property("foo").that.equals("bar")`), only running them after the existing ones pass.
        // So the first base-promise is `assertion._obj`, but after that we use the assertions themselves, i.e.
        // previously derived promises, to chain off of.
        return typeof assertion.then === "function" ? assertion : assertion._obj;
    }

    function getReasonName(reason) {
        return reason instanceof Error ? reason.toString() : checkError$$1.getConstructorName(reason);
    }

    // Grab these first, before we modify `Assertion.prototype`.

    const propertyNames = Object.getOwnPropertyNames(Assertion.prototype);

    const propertyDescs = {};
    for (const name of propertyNames) {
        propertyDescs[name] = Object.getOwnPropertyDescriptor(Assertion.prototype, name);
    }

    property("fulfilled", function () {
        const derivedPromise = getBasePromise(this).then(
            value => {
                assertIfNegated(this,
                                "expected promise not to be fulfilled but it was fulfilled with #{act}",
                                { actual: value });
                return value;
            },
            reason => {
                assertIfNotNegated(this,
                                   "expected promise to be fulfilled but it was rejected with #{act}",
                                   { actual: getReasonName(reason) });
                return reason;
            }
        );

        module.exports.transferPromiseness(this, derivedPromise);
        return this;
    });

    property("rejected", function () {
        const derivedPromise = getBasePromise(this).then(
            value => {
                assertIfNotNegated(this,
                                   "expected promise to be rejected but it was fulfilled with #{act}",
                                   { actual: value });
                return value;
            },
            reason => {
                assertIfNegated(this,
                                "expected promise not to be rejected but it was rejected with #{act}",
                                { actual: getReasonName(reason) });

                // Return the reason, transforming this into a fulfillment, to allow further assertions, e.g.
                // `promise.should.be.rejected.and.eventually.equal("reason")`.
                return reason;
            }
        );

        module.exports.transferPromiseness(this, derivedPromise);
        return this;
    });

    method("rejectedWith", function (errorLike, errMsgMatcher, message) {
        let errorLikeName = null;
        const negate = utils.flag(this, "negate") || false;

        // rejectedWith with that is called without arguments is
        // the same as a plain ".rejected" use.
        if (errorLike === undefined && errMsgMatcher === undefined &&
            message === undefined) {
            /* eslint-disable no-unused-expressions */
            return this.rejected;
            /* eslint-enable no-unused-expressions */
        }

        if (message !== undefined) {
            utils.flag(this, "message", message);
        }

        if (errorLike instanceof RegExp || typeof errorLike === "string") {
            errMsgMatcher = errorLike;
            errorLike = null;
        } else if (errorLike && errorLike instanceof Error) {
            errorLikeName = errorLike.toString();
        } else if (typeof errorLike === "function") {
            errorLikeName = checkError$$1.getConstructorName(errorLike);
        } else {
            errorLike = null;
        }
        const everyArgIsDefined = Boolean(errorLike && errMsgMatcher);

        let matcherRelation = "including";
        if (errMsgMatcher instanceof RegExp) {
            matcherRelation = "matching";
        }

        const derivedPromise = getBasePromise(this).then(
            value => {
                let assertionMessage = null;
                let expected = null;

                if (errorLike) {
                    assertionMessage = "expected promise to be rejected with #{exp} but it was fulfilled with #{act}";
                    expected = errorLikeName;
                } else if (errMsgMatcher) {
                    assertionMessage = `expected promise to be rejected with an error ${matcherRelation} #{exp} but ` +
                                       `it was fulfilled with #{act}`;
                    expected = errMsgMatcher;
                }

                assertIfNotNegated(this, assertionMessage, { expected, actual: value });
                return value;
            },
            reason => {
                const errorLikeCompatible = errorLike && (errorLike instanceof Error ?
                                                        checkError$$1.compatibleInstance(reason, errorLike) :
                                                        checkError$$1.compatibleConstructor(reason, errorLike));

                const errMsgMatcherCompatible = errMsgMatcher && checkError$$1.compatibleMessage(reason, errMsgMatcher);

                const reasonName = getReasonName(reason);

                if (negate && everyArgIsDefined) {
                    if (errorLikeCompatible && errMsgMatcherCompatible) {
                        this.assert(true,
                                    null,
                                    "expected promise not to be rejected with #{exp} but it was rejected " +
                                    "with #{act}",
                                    errorLikeName,
                                    reasonName);
                    }
                } else {
                    if (errorLike) {
                        this.assert(errorLikeCompatible,
                                    "expected promise to be rejected with #{exp} but it was rejected with #{act}",
                                    "expected promise not to be rejected with #{exp} but it was rejected " +
                                    "with #{act}",
                                    errorLikeName,
                                    reasonName);
                    }

                    if (errMsgMatcher) {
                        this.assert(errMsgMatcherCompatible,
                                    `expected promise to be rejected with an error ${matcherRelation} #{exp} but got ` +
                                    `#{act}`,
                                    `expected promise not to be rejected with an error ${matcherRelation} #{exp}`,
                                    errMsgMatcher,
                                    checkError$$1.getMessage(reason));
                    }
                }

                return reason;
            }
        );

        module.exports.transferPromiseness(this, derivedPromise);
        return this;
    });

    property("eventually", function () {
        utils.flag(this, "eventually", true);
        return this;
    });

    method("notify", function (done) {
        doNotify(getBasePromise(this), done);
        return this;
    });

    method("become", function (value, message) {
        return this.eventually.deep.equal(value, message);
    });

    // ### `eventually`

    // We need to be careful not to trigger any getters, thus `Object.getOwnPropertyDescriptor` usage.
    const methodNames = propertyNames.filter(name => {
        return name !== "assert" && typeof propertyDescs[name].value === "function";
    });

    methodNames.forEach(methodName => {
        Assertion.overwriteMethod(methodName, originalMethod => function () {
            return doAsserterAsyncAndAddThen(originalMethod, this, arguments);
        });
    });

    const getterNames = propertyNames.filter(name => {
        return name !== "_obj" && typeof propertyDescs[name].get === "function";
    });

    getterNames.forEach(getterName => {
        // Chainable methods are things like `an`, which can work both for `.should.be.an.instanceOf` and as
        // `should.be.an("object")`. We need to handle those specially.
        const isChainableMethod = Assertion.prototype.__methods.hasOwnProperty(getterName);

        if (isChainableMethod) {
            Assertion.overwriteChainableMethod(
                getterName,
                originalMethod => function () {
                    return doAsserterAsyncAndAddThen(originalMethod, this, arguments);
                },
                originalGetter => function () {
                    return doAsserterAsyncAndAddThen(originalGetter, this);
                }
            );
        } else {
            Assertion.overwriteProperty(getterName, originalGetter => function () {
                return proxifyIfSupported(doAsserterAsyncAndAddThen(originalGetter, this));
            });
        }
    });

    function doAsserterAsyncAndAddThen(asserter, assertion, args) {
        // Since we're intercepting all methods/properties, we need to just pass through if they don't want
        // `eventually`, or if we've already fulfilled the promise (see below).
        if (!utils.flag(assertion, "eventually")) {
            asserter.apply(assertion, args);
            return assertion;
        }

        const derivedPromise = getBasePromise(assertion).then(value => {
            // Set up the environment for the asserter to actually run: `_obj` should be the fulfillment value, and
            // now that we have the value, we're no longer in "eventually" mode, so we won't run any of this code,
            // just the base Chai code that we get to via the short-circuit above.
            assertion._obj = value;
            utils.flag(assertion, "eventually", false);

            return args ? module.exports.transformAsserterArgs(args) : args;
        }).then(newArgs => {
            asserter.apply(assertion, newArgs);

            // Because asserters, for example `property`, can change the value of `_obj` (i.e. change the "object"
            // flag), we need to communicate this value change to subsequent chained asserters. Since we build a
            // promise chain paralleling the asserter chain, we can use it to communicate such changes.
            return assertion._obj;
        });

        module.exports.transferPromiseness(assertion, derivedPromise);
        return assertion;
    }

    // ### Now use the `Assertion` framework to build an `assert` interface.
    const originalAssertMethods = Object.getOwnPropertyNames(assert).filter(propName => {
        return typeof assert[propName] === "function";
    });

    assert.isFulfilled = (promise, message) => (new Assertion(promise, message)).to.be.fulfilled;

    assert.isRejected = (promise, errorLike, errMsgMatcher, message) => {
        const assertion = new Assertion(promise, message);
        return assertion.to.be.rejectedWith(errorLike, errMsgMatcher, message);
    };

    assert.becomes = (promise, value, message) => assert.eventually.deepEqual(promise, value, message);

    assert.doesNotBecome = (promise, value, message) => assert.eventually.notDeepEqual(promise, value, message);

    assert.eventually = {};
    originalAssertMethods.forEach(assertMethodName => {
        assert.eventually[assertMethodName] = function (promise) {
            const otherArgs = Array.prototype.slice.call(arguments, 1);

            let customRejectionHandler;
            const message = arguments[assert[assertMethodName].length - 1];
            if (typeof message === "string") {
                customRejectionHandler = reason => {
                    throw new chai.AssertionError(`${message}\n\nOriginal reason: ${utils.inspect(reason)}`);
                };
            }

            const returnedPromise = promise.then(
                fulfillmentValue => assert[assertMethodName].apply(assert, [fulfillmentValue].concat(otherArgs)),
                customRejectionHandler
            );

            returnedPromise.notify = done => {
                doNotify(returnedPromise, done);
            };

            return returnedPromise;
        };
    });
};

module.exports.transferPromiseness = (assertion, promise) => {
    assertion.then = promise.then.bind(promise);
};

module.exports.transformAsserterArgs = values => values;
});
var chaiAsPromised_1 = chaiAsPromised.transferPromiseness;
var chaiAsPromised_2 = chaiAsPromised.transformAsserterArgs;

/* @flow */
/*::

type DotenvParseOptions = {
  debug?: boolean
}

// keys and values from src
type DotenvParseOutput = { [string]: string }

type DotenvConfigOptions = {
  path?: string, // path to .env file
  encoding?: string, // encoding of .env file
  debug?: string // turn on logging for debugging purposes
}

type DotenvConfigOutput = {
  parsed?: DotenvParseOutput,
  error?: Error
}

*/




function log (message /*: string */) {
  console.log(`[dotenv][DEBUG] ${message}`);
}

// Parses src into an Object
function parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {
  const debug = Boolean(options && options.debug);
  const obj = {};

  // convert Buffers before splitting into lines and processing
  src.toString().split('\n').forEach(function (line, idx) {
    // matching "KEY' and 'VAL' in 'KEY=VAL'
    const keyValueArr = line.match(/^\s*([\w.-]+)\s*=\s*(.*)?\s*$/);
    // matched?
    if (keyValueArr != null) {
      const key = keyValueArr[1];

      // default undefined or missing values to empty string
      let value = keyValueArr[2] || '';

      // expand newlines in quoted values
      const len = value ? value.length : 0;
      if (len > 0 && value.charAt(0) === '"' && value.charAt(len - 1) === '"') {
        value = value.replace(/\\n/gm, '\n');
      }

      // remove any surrounding quotes and extra spaces
      value = value.replace(/(^['"]|['"]$)/g, '').trim();

      obj[key] = value;
    } else if (debug) {
      log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
    }
  });

  return obj
}

// Populates process.env from .env file
function config$1 (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {
  let dotenvPath = path.resolve(process.cwd(), '.env');
  let encoding /*: string */ = 'utf8';
  let debug = false;

  if (options) {
    if (options.path != null) {
      dotenvPath = options.path;
    }
    if (options.encoding != null) {
      encoding = options.encoding;
    }
    if (options.debug != null) {
      debug = true;
    }
  }

  try {
    // specifying an encoding returns a string instead of a buffer
    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug });

    Object.keys(parsed).forEach(function (key) {
      if (!process.env.hasOwnProperty(key)) {
        process.env[key] = parsed[key];
      } else if (debug) {
        log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
      }
    });

    return { parsed }
  } catch (e) {
    return { error: e }
  }
}

var config_1$1 = config$1;
var load = config$1;
var parse_1 = parse;

var main = {
	config: config_1$1,
	load: load,
	parse: parse_1
};

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * log statements for linkEntity
 */
const link = debugModule("azure:service-bus:linkEntity");
/**
 * @internal
 * log statements for error
 */
const error = debugModule("azure:service-bus:error");
/**
 * @internal
 * log statements for management
 */
const mgmt = debugModule("azure:service-bus:management");
/**
 * @internal
 * log statements for sender
 */
const sender = debugModule("azure:service-bus:sender");
/**
 * @internal
 * log statements for receiver
 */
const receiver = debugModule("azure:service-bus:receiver");
/**
 * @internal
 * log statements for receiverbatching
 */
const batching = debugModule("azure:service-bus:receiverbatching");
/**
 * @internal
 * log statements for receiverstreaming
 */
const streaming = debugModule("azure:service-bus:receiverstreaming");
/**
 * @internal
 * log statements for connectionContext
 */
const connectionCtxt = debugModule("azure:service-bus:connectionContext");
/**
 * @internal
 * log statements for clientEntityContext
 */
const entityCtxt = debugModule("azure:service-bus:clientEntityContext");
/**
 * @internal
 * log statements for queue client
 */
const qClient = debugModule("azure:service-bus:queueClient");
/**
 * @internal
 * log statements for topic client
 */
const topicClient = debugModule("azure:service-bus:topicClient");
/**
 * @internal
 * log statements for subscription client
 */
const subscriptionClient = debugModule("azure:service-bus:subscriptionClient");
/**
 * @internal
 * log statements for namespace
 */
const ns = debugModule("azure:service-bus:namespace");
/**
 * @internal
 * log statements for servicebusMessage
 */
const message = debugModule("azure:service-bus:servicebusMessage");
/**
 * @internal
 * log statements for map
 */
const map = debugModule("azure:service-bus:concurrentMap");
/**
 * @internal
 * log statements for utils
 */
const utils$1 = debugModule("azure:service-bus:utils");
/**
 * @internal
 * log statements for messageSession
 */
const messageSession = debugModule("azure:service-bus:messageSession");
/**
 * @internal
 * log statements for semaphore
 */
const semaphore = debugModule("azure:service-bus:semaphore");
/**
 * @internal
 * log statements for sessionManager
 */
const sessionManager = debugModule("azure:service-bus:sessionManager");

var log$1 = /*#__PURE__*/Object.freeze({
	link: link,
	error: error,
	mgmt: mgmt,
	sender: sender,
	receiver: receiver,
	batching: batching,
	streaming: streaming,
	connectionCtxt: connectionCtxt,
	entityCtxt: entityCtxt,
	qClient: qClient,
	topicClient: topicClient,
	subscriptionClient: subscriptionClient,
	ns: ns,
	message: message,
	map: map,
	utils: utils$1,
	messageSession: messageSession,
	semaphore: semaphore,
	sessionManager: sessionManager
});

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const packageJsonInfo = {
    name: "@azure/service-bus",
    version: "1.0.0-preview.1"
};
const messageDispositionTimeout = 20000;
const max32BitNumber = Math.pow(2, 31) - 1;

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 */
var ConnectionContext;
(function (ConnectionContext) {
    /**
     * @property {string} userAgent The user agent string for the ServiceBus client.
     * azure-sdk-for-js/azure-<package-name>/<package-version> (NODE-VERSION <node-version>; <os-type> <os-version>)
     */
    ConnectionContext.userAgent = `azure-sdk-for-js/azure-service-bus/${packageJsonInfo.version} (NODE-VERSION ${process.version}; ${os.type()} ${os.release()})`;
    function create(config, tokenProvider, options) {
        if (!options)
            options = {};
        const parameters = {
            config: config,
            tokenProvider: tokenProvider,
            dataTransformer: options.dataTransformer,
            isEntityPathRequired: false,
            connectionProperties: {
                product: "MSJSClient",
                userAgent: ConnectionContext.userAgent,
                version: packageJsonInfo.version
            }
        };
        // Let us create the base context and then add ServiceBus specific ConnectionContext properties.
        const connectionContext = amqpCommon.ConnectionContextBase.create(parameters);
        connectionContext.clients = {};
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = (context) => {
            connectionContext.wasConnectionCloseCalled = false;
            connectionCtxt("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionError = context.connection && context.connection.error ? context.connection.error : undefined;
            if (connectionError) {
                error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, connectionError);
            }
            const contextError = context.error;
            if (contextError) {
                error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, contextError);
            }
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numClients: Object.keys(connectionContext.clients).length
            };
            // The connection should always be brought back up if the sdk did not call connection.close()
            // and there was atleast one sender/receiver link on the connection before it went down.
            error("[%s] state: %O", connectionContext.connectionId, state);
            if (!state.wasConnectionCloseCalled && state.numClients) {
                error("[%s] connection.close() was not called from the sdk and there were some " +
                    "clients. We should reconnect.", connectionContext.connection.id);
                yield amqpCommon.delay(amqpCommon.Constants.connectionReconnectDelay);
                // reconnect clients if any
                for (const id of Object.keys(connectionContext.clients)) {
                    const client = connectionContext.clients[id];
                    error("[%s] calling detached on client '%s'.", connectionContext.connection.id, client.id);
                    client.detached(connectionError || contextError).catch((err) => {
                        error("[%s] An error occurred while reconnecting the sender '%s': %O.", connectionContext.connection.id, client.id, err);
                    });
                }
            }
        });
        // Add listeners on the connection object.
        connectionContext.connection.on(rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.disconnected, disconnected);
        connectionCtxt("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
})(ConnectionContext || (ConnectionContext = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Provides a uniue name by appending a string guid to the given string in the following format:
 * `{name}-{uuid}`.
 * @param name The nme of the entity
 */
function getUniqueName(name) {
    if (typeof name !== "string") {
        throw new Error("name is a required parameter of type 'string'.");
    }
    return `${name}-${rheaPromise.generate_uuid()}`;
}
/**
 * If you try to turn a Guid into a Buffer in .NET, the bytes of the first three groups get
 * flipped within the group, but the last two groups don't get flipped, so we end up with a
 * different byte order. This is the order of bytes needed to make Service Bus recognize the token.
 *
 * @param lockToken The lock token whose bytes need to be reorded.
 * @returns Buffer - Buffer representing reordered bytes.
 */
function reorderLockToken(lockTokenBytes) {
    if (!lockTokenBytes || !Buffer.isBuffer(lockTokenBytes)) {
        throw new Error("'lockToken' is a required parameter and must be of type 'Buffer'.");
    }
    return Buffer.from([
        lockTokenBytes[3],
        lockTokenBytes[2],
        lockTokenBytes[1],
        lockTokenBytes[0],
        lockTokenBytes[5],
        lockTokenBytes[4],
        lockTokenBytes[7],
        lockTokenBytes[6],
        lockTokenBytes[8],
        lockTokenBytes[9],
        lockTokenBytes[10],
        lockTokenBytes[11],
        lockTokenBytes[12],
        lockTokenBytes[13],
        lockTokenBytes[14],
        lockTokenBytes[15]
    ]);
}
/**
 * @internal
 * Provides the time in milliseconds after which the lock renewal should occur.
 * @param lockedUntilUtc - The time until which the message is locked.
 */
function calculateRenewAfterDuration(lockedUntilUtc) {
    const now = Date.now();
    const lockedUntil = lockedUntilUtc.getTime();
    const remainingTime = lockedUntil - now;
    utils$1("Locked until utc  : %d", lockedUntil);
    utils$1("Current time is   : %d", now);
    utils$1("Remaining time is : %d", remainingTime);
    if (remainingTime < 1000) {
        return 0;
    }
    const buffer = Math.min(remainingTime / 2, 10000); // 10 seconds
    const renewAfter = remainingTime - buffer;
    utils$1("Renew after       : %d", renewAfter);
    return renewAfter;
}
/**
 * @internal
 * Converts the .net ticks to a JS Date object.
 *
 * - The epoch for the DateTimeOffset type is `0000-01-01`, while the epoch for JS Dates is
 * `1970-01-01`.
 * - The DateTimeOffset ticks value for the date `1970-01-01` is `621355968000000000`.
 *   - Hence, to convert it to the JS epoch; we `subtract` the delta from the given value.
 * - Ticks in DateTimeOffset is `1/10000000` second, while ticks in JS Date is `1/1000` second.
 *   - Thus, we `divide` the value by `10000` to convert it to JS Date ticks.
 *
 * @param buf Input as a Buffer
 * @returns Date The JS Date object.
 */
function convertTicksToDate(buf) {
    const epochMicroDiff = 621355968000000000;
    const longValue = Long.fromBytesBE(buf);
    const timeInMS = longValue
        .sub(epochMicroDiff)
        .div(10000)
        .toNumber();
    const result = new Date(timeInMS);
    utils$1("The converted date is: %s", result.toString());
    return result;
}
/**
 * @internal
 * Returns the number of logical processors in the system.
 */
function getProcessorCount() {
    {
        const os$$1 = require("os");
        return os$$1.cpus().length;
    }
}
/**
 * @internal
 * Converts any given input to a Buffer.
 * @param input The input that needs to be converted to a Buffer.
 */
function toBuffer(input) {
    let result;
    utils$1("[utils.toBuffer] The given message body that needs to be converted to buffer is: ", input);
    if (util.isBuffer(input)) {
        result = input;
    }
    else {
        // string, undefined, null, boolean, array, object, number should end up here
        // coercing undefined to null as that will ensure that null value will be given to the
        // customer on receive.
        if (input === undefined)
            input = null; // tslint:disable-line
        try {
            const inputStr = JSON.stringify(input);
            result = Buffer.from(inputStr, "utf8");
        }
        catch (err) {
            const msg = `An error occurred while executing JSON.stringify() on the given input ` +
                input +
                `${err ? err.stack : JSON.stringify(err)}`;
            error("[utils.toBuffer] " + msg);
            throw new Error(msg);
        }
    }
    utils$1("[utils.toBuffer] The converted buffer is: %O.", result);
    return result;
}
/**
 * @internal
 * Throws InvalidOperationError if the current AMQP connection is closed.
 * @param context The ConnectionContext associated with the current AMQP connection.
 */
function throwErrorIfConnectionClosed(context) {
    if (context && context.wasConnectionCloseCalled) {
        throw new Error("The underlying AMQP connection is closed.");
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Describes the base class for entities like MessageSender, MessageReceiver and Management client.
 * @class ClientEntity
 */
class LinkEntity {
    /**
     * Creates a new ClientEntity instance.
     * @constructor
     * @param {ClientEntityContext} context The connection context.
     * @param {LinkEntityOptions} [options] Options that can be provided while creating the LinkEntity.
     */
    constructor(name, context, options) {
        /**
         * @property {boolean} isConnecting Indicates whether the link is in the process of connecting
         * (establishing) itself. Default value: `false`.
         */
        this.isConnecting = false;
        if (!options)
            options = {};
        this._context = context;
        this.address = options.address || "";
        this.audience = options.audience || "";
        this.name = getUniqueName(name);
    }
    /**
     * Negotiates the cbs claim for the ClientEntity.
     * @protected
     * @param {boolean} [setTokenRenewal] Set the token renewal timer. Default false.
     * @return {Promise<void>} Promise<void>
     */
    _negotiateClaim(setTokenRenewal) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Acquire the lock and establish a cbs session if it does not exist on the connection.
            // Although node.js is single threaded, we need a locking mechanism to ensure that a
            // race condition does not happen while creating a shared resource (in this case the
            // cbs session, since we want to have exactly 1 cbs session per connection).
            link("[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: " +
                "'%s' with address: '%s'.", this._context.namespace.connectionId, this._context.namespace.cbsSession.cbsLock, this._type, this.name, this.address);
            yield amqpCommon.defaultLock.acquire(this._context.namespace.cbsSession.cbsLock, () => {
                return this._context.namespace.cbsSession.init();
            });
            const tokenObject = yield this._context.namespace.tokenProvider.getToken(this.audience);
            link("[%s] %s: calling negotiateClaim for audience '%s'.", this._context.namespace.connectionId, this._type, this.audience);
            // Acquire the lock to negotiate the CBS claim.
            link("[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this._context.namespace.connectionId, this._context.namespace.negotiateClaimLock, this._type, this.name, this.address);
            yield amqpCommon.defaultLock.acquire(this._context.namespace.negotiateClaimLock, () => {
                return this._context.namespace.cbsSession.negotiateClaim(this.audience, tokenObject);
            });
            link("[%s] Negotiated claim for %s '%s' with with address: %s", this._context.namespace.connectionId, this._type, this.name, this.address);
            if (setTokenRenewal) {
                yield this._ensureTokenRenewal();
            }
        });
    }
    /**
     * Ensures that the token is renewed within the predefined renewal margin.
     * @protected
     * @returns {void}
     */
    _ensureTokenRenewal() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const tokenValidTimeInSeconds = this._context.namespace.tokenProvider.tokenValidTimeInSeconds;
            const tokenRenewalMarginInSeconds = this._context.namespace.tokenProvider
                .tokenRenewalMarginInSeconds;
            const nextRenewalTimeout = (tokenValidTimeInSeconds - tokenRenewalMarginInSeconds) * 1000;
            this._tokenRenewalTimer = setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield this._negotiateClaim(true);
                }
                catch (err) {
                    // TODO: May be add some retries over here before emitting the error.
                    error("[%s] %s '%s' with address %s, an error occurred while renewing the token: %O", this._context.namespace.connectionId, this._type, this.name, this.address, err);
                }
            }), nextRenewalTimeout);
            link("[%s] %s '%s' with address %s, has next token renewal in %d seconds @(%s).", this._context.namespace.connectionId, this._type, this.name, this.address, nextRenewalTimeout / 1000, new Date(Date.now() + nextRenewalTimeout).toString());
        });
    }
    /**
     * Closes the Sender|Receiver link and it's underlying session and also removes it from the
     * internal map.
     *
     * @param {Sender | Receiver} [link] The Sender or Receiver link that needs to be closed and
     * removed.
     */
    _closeLink(link$$1) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._tokenRenewalTimer);
            if (link$$1) {
                try {
                    // This should take care of closing the link and it's underlying session. This should also
                    // remove them from the internal map.
                    yield link$$1.close();
                    link("[%s] %s '%s' with address '%s' closed.", this._context.namespace.connectionId, this._type, this.name, this.address);
                }
                catch (err) {
                    error("[%s] An error occurred while closing the %s '%s': %O", this._context.namespace.connectionId, this._type, this.name, this.address, err);
                }
            }
        });
    }
    /**
     * Provides the current type of the ClientEntity.
     * @return {string} The entity type.
     */
    get _type() {
        let result = "LinkEntity";
        if (this.constructor && this.constructor.name) {
            result = this.constructor.name;
        }
        return result;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The mode in which messages should be received
 */
var ReceiveMode;
(function (ReceiveMode) {
    /**
     * Peek the message and lock it until it is settled or times out.
     * @type {Number}
     */
    ReceiveMode[ReceiveMode["peekLock"] = 1] = "peekLock";
    /**
     * Remove the message from the service bus upon delivery.
     * @type {Number}
     */
    ReceiveMode[ReceiveMode["receiveAndDelete"] = 2] = "receiveAndDelete";
})(ReceiveMode || (ReceiveMode = {}));
/**
 * @internal
 */
var DispositionType;
(function (DispositionType) {
    DispositionType["complete"] = "complete";
    DispositionType["deadletter"] = "deadletter";
    DispositionType["abandon"] = "abandon";
    DispositionType["defer"] = "defer";
})(DispositionType || (DispositionType = {}));
/**
 * @internal
 */
var DispositionStatus;
(function (DispositionStatus) {
    DispositionStatus["completed"] = "completed";
    DispositionStatus["defered"] = "defered";
    DispositionStatus["suspended"] = "suspended";
    DispositionStatus["abandoned"] = "abandoned";
    DispositionStatus["renewed"] = "renewed";
})(DispositionStatus || (DispositionStatus = {}));
/**
 * Describes the message to be sent to ServiceBus.
 */
var SendableMessageInfo;
(function (SendableMessageInfo) {
    /**
     * @ignore
     */
    function validate(msg) {
        if (!msg) {
            throw new Error("'msg' cannot be null or undefined.");
        }
        if (msg.contentType != undefined && typeof msg.contentType !== "string") {
            throw new Error("'contentType' must be of type 'string'.");
        }
        if (msg.label != undefined && typeof msg.label !== "string") {
            throw new Error("'label' must be of type 'string'.");
        }
        if (msg.to != undefined && typeof msg.to !== "string") {
            throw new Error("'to' must be of type 'string'.");
        }
        if (msg.replyToSessionId != undefined && typeof msg.replyToSessionId !== "string") {
            throw new Error("'replyToSessionId' must be of type 'string'.");
        }
        if (msg.timeToLive != undefined && typeof msg.timeToLive !== "number") {
            throw new Error("'timeToLive' must be of type 'number'.");
        }
        if (msg.scheduledEnqueueTimeUtc &&
            (!(msg.scheduledEnqueueTimeUtc instanceof Date) ||
                msg.scheduledEnqueueTimeUtc.toString() === "Invalid Date")) {
            throw new Error("'scheduledEnqueueTimeUtc' must be an instance of a valid 'Date'.");
        }
        if ((msg.partitionKey != undefined && typeof msg.partitionKey !== "string") ||
            (typeof msg.partitionKey === "string" &&
                msg.partitionKey.length > amqpCommon.Constants.maxPartitionKeyLength)) {
            throw new Error("'partitionKey' must be of type 'string' with a length less than 128 characters.");
        }
        if ((msg.viaPartitionKey != undefined && typeof msg.viaPartitionKey !== "string") ||
            (typeof msg.viaPartitionKey === "string" &&
                msg.viaPartitionKey.length > amqpCommon.Constants.maxPartitionKeyLength)) {
            throw new Error("'viaPartitionKey' must be of type 'string' with a length less than 128 characters.");
        }
        if (msg.sessionId != undefined && typeof msg.sessionId !== "string") {
            throw new Error("'sessionId' must be of type 'string'.");
        }
        if (msg.sessionId != undefined &&
            typeof msg.sessionId === "string" &&
            msg.sessionId.length > amqpCommon.Constants.maxSessionIdLength) {
            throw new Error("Length of 'sessionId' of type 'string' cannot be greater than 128 characters.");
        }
        if (msg.messageId != undefined &&
            typeof msg.messageId !== "string" &&
            typeof msg.messageId !== "number" &&
            !Buffer.isBuffer(msg.messageId)) {
            throw new Error("'messageId' must be of type 'string' | 'number' | Buffer.");
        }
        if (msg.messageId &&
            typeof msg.messageId === "number" &&
            Math.floor(msg.messageId) !== msg.messageId) {
            throw new Error("'messageId' must be a whole integer. Decimal points are not allowed.");
        }
        if (msg.messageId != undefined &&
            typeof msg.messageId === "string" &&
            msg.messageId.length > amqpCommon.Constants.maxMessageIdLength) {
            throw new Error("Length of 'messageId' of type 'string' cannot be greater than 128 characters.");
        }
        if (msg.correlationId != undefined &&
            typeof msg.correlationId !== "string" &&
            typeof msg.correlationId !== "number" &&
            !Buffer.isBuffer(msg.correlationId)) {
            throw new Error("'correlationId' must be of type 'string' | 'number' | Buffer.");
        }
    }
    SendableMessageInfo.validate = validate;
    /**
     * @ignore
     * Converts given SendableMessageInfo to AmqpMessage
     */
    function toAmqpMessage(msg) {
        validate(msg);
        const amqpMsg = {
            body: msg.body,
            message_annotations: {}
        };
        if (msg.userProperties != undefined) {
            amqpMsg.application_properties = msg.userProperties;
        }
        if (msg.contentType != undefined) {
            amqpMsg.content_type = msg.contentType;
        }
        if (msg.sessionId != undefined) {
            amqpMsg.group_id = msg.sessionId;
        }
        if (msg.replyTo != undefined) {
            amqpMsg.reply_to = msg.replyTo;
        }
        if (msg.to != undefined) {
            amqpMsg.to = msg.to;
        }
        if (msg.label != undefined) {
            amqpMsg.subject = msg.label;
        }
        if (msg.messageId != undefined) {
            amqpMsg.message_id = msg.messageId;
        }
        if (msg.correlationId != undefined) {
            amqpMsg.correlation_id = msg.correlationId;
        }
        if (msg.replyToSessionId != undefined) {
            amqpMsg.reply_to_group_id = msg.replyToSessionId;
        }
        if (msg.timeToLive != undefined && msg.timeToLive !== amqpCommon.Constants.maxDurationValue) {
            amqpMsg.ttl = msg.timeToLive;
            amqpMsg.creation_time = Date.now();
            if (amqpCommon.Constants.maxAbsoluteExpiryTime - amqpMsg.creation_time > amqpMsg.ttl) {
                amqpMsg.absolute_expiry_time = amqpMsg.creation_time + amqpMsg.ttl;
            }
            else {
                amqpMsg.absolute_expiry_time = amqpCommon.Constants.maxAbsoluteExpiryTime;
            }
        }
        if (msg.partitionKey != undefined) {
            amqpMsg.message_annotations[amqpCommon.Constants.partitionKey] = msg.partitionKey;
        }
        if (msg.viaPartitionKey != undefined) {
            amqpMsg.message_annotations[amqpCommon.Constants.viaPartitionKey] = msg.viaPartitionKey;
        }
        if (msg.scheduledEnqueueTimeUtc != undefined) {
            amqpMsg.message_annotations[amqpCommon.Constants.scheduledEnqueueTime] = msg.scheduledEnqueueTimeUtc;
        }
        message("SBMessage to AmqpMessage: %O", amqpMsg);
        return amqpMsg;
    }
    SendableMessageInfo.toAmqpMessage = toAmqpMessage;
    /**
     * @ignore
     * Converts given AmqpMessage to SendableMessageInfo
     */
    function fromAmqpMessage(msg) {
        if (!msg) {
            throw new Error("'msg' cannot be null or undefined.");
        }
        const sbmsg = {
            body: msg.body
        };
        if (msg.application_properties != undefined) {
            sbmsg.userProperties = msg.application_properties;
        }
        if (msg.content_type != undefined) {
            sbmsg.contentType = msg.content_type;
        }
        if (msg.group_id != undefined) {
            sbmsg.sessionId = msg.group_id;
        }
        if (msg.reply_to != undefined) {
            sbmsg.replyTo = msg.reply_to;
        }
        if (msg.to != undefined) {
            sbmsg.to = msg.to;
        }
        if (msg.ttl != undefined) {
            sbmsg.timeToLive = msg.ttl;
        }
        if (msg.subject != undefined) {
            sbmsg.label = msg.subject;
        }
        if (msg.message_id != undefined) {
            sbmsg.messageId = msg.message_id;
        }
        if (msg.correlation_id != undefined) {
            sbmsg.correlationId = msg.correlation_id;
        }
        if (msg.reply_to_group_id != undefined) {
            sbmsg.replyToSessionId = msg.reply_to_group_id;
        }
        if (msg.message_annotations != undefined) {
            if (msg.message_annotations[amqpCommon.Constants.partitionKey] != undefined) {
                sbmsg.partitionKey = msg.message_annotations[amqpCommon.Constants.partitionKey];
            }
            if (msg.message_annotations[amqpCommon.Constants.viaPartitionKey] != undefined) {
                sbmsg.viaPartitionKey = msg.message_annotations[amqpCommon.Constants.viaPartitionKey];
            }
            if (msg.message_annotations[amqpCommon.Constants.scheduledEnqueueTime] != undefined) {
                sbmsg.scheduledEnqueueTimeUtc = msg.message_annotations[amqpCommon.Constants.scheduledEnqueueTime];
            }
        }
        message("AmqpMessage to SBMessage: %O", sbmsg);
        return sbmsg;
    }
    SendableMessageInfo.fromAmqpMessage = fromAmqpMessage;
})(SendableMessageInfo || (SendableMessageInfo = {}));
/**
 * Describes the module that is responsible for converting the message received from ServiceBus
 * to/from AmqpMessage.
 */
var ReceivedMessageInfo;
(function (ReceivedMessageInfo) {
    /**
     * @ignore
     */
    function validate(msg) {
        SendableMessageInfo.validate(msg);
        if (msg.lockToken != undefined && typeof msg.lockToken !== "string") {
            throw new Error("'lockToken' must be of type 'string'.");
        }
        if (msg.deliveryCount != undefined && typeof msg.deliveryCount !== "number") {
            throw new Error("'deliveryCount' must be of type 'number'.");
        }
        if (msg.sequenceNumber != undefined && !Long.isLong(msg.sequenceNumber)) {
            throw new Error("'sequenceNumber' must be an instance of 'Long' .");
        }
        if (msg.enqueuedSequenceNumber != undefined && typeof msg.enqueuedSequenceNumber !== "number") {
            throw new Error("'enqueuedSequenceNumber' must be of type 'number'.");
        }
        if (msg.enqueuedTimeUtc &&
            !(msg.enqueuedTimeUtc instanceof Date) &&
            msg.enqueuedTimeUtc.toString() === "Invalid Date") {
            throw new Error("'enqueuedTimeUtc' must be an instance of a valid 'Date'.");
        }
        if (msg.expiresAtUtc &&
            !(msg.expiresAtUtc instanceof Date) &&
            msg.expiresAtUtc.toString() === "Invalid Date") {
            throw new Error("'expiresAtUtc' must be an instance of a valid 'Date'.");
        }
        if (msg.lockedUntilUtc &&
            !(msg.lockedUntilUtc instanceof Date) &&
            msg.lockedUntilUtc.toString() === "Invalid Date") {
            throw new Error("'lockedUntilUtc' must be an instance of a valid 'Date'.");
        }
    }
    ReceivedMessageInfo.validate = validate;
    /**
     * @ignore
     * Converts given ReceivedMessageInfo to AmqpMessage
     */
    function toAmqpMessage(msg) {
        ReceivedMessageInfo.validate(msg);
        const amqpMsg = SendableMessageInfo.toAmqpMessage(msg);
        if (msg.deliveryCount != undefined) {
            amqpMsg.delivery_count = msg.deliveryCount;
        }
        if (!amqpMsg.message_annotations) {
            amqpMsg.message_annotations = {};
        }
        if (msg.deadLetterSource != undefined) {
            amqpMsg.message_annotations[amqpCommon.Constants.deadLetterSource] = msg.deadLetterSource;
        }
        if (msg.enqueuedSequenceNumber != undefined) {
            amqpMsg.message_annotations[amqpCommon.Constants.enqueueSequenceNumber] = msg.enqueuedSequenceNumber;
        }
        if (msg.sequenceNumber != undefined) {
            amqpMsg.message_annotations[amqpCommon.Constants.sequenceNumber] = msg.sequenceNumber;
        }
        if (msg.enqueuedTimeUtc != undefined) {
            amqpMsg.message_annotations[amqpCommon.Constants.enqueuedTime] = msg.enqueuedTimeUtc;
        }
        if (msg.lockedUntilUtc != undefined) {
            amqpMsg.message_annotations[amqpCommon.Constants.lockedUntil] = msg.lockedUntilUtc;
        }
        message("ReceivedSBMessage to AmqpMessage: %O", amqpMsg);
        return amqpMsg;
    }
    ReceivedMessageInfo.toAmqpMessage = toAmqpMessage;
    /**
     * @ignore
     * Converts given AmqpMessage to ReceivedMessageInfo
     */
    function fromAmqpMessage(msg, delivery) {
        const sbmsg = SendableMessageInfo.fromAmqpMessage(msg);
        const props = {};
        if (msg.message_annotations != undefined) {
            if (msg.message_annotations[amqpCommon.Constants.deadLetterSource] != undefined) {
                props.deadLetterSource = msg.message_annotations[amqpCommon.Constants.deadLetterSource];
            }
            if (msg.message_annotations[amqpCommon.Constants.enqueueSequenceNumber] != undefined) {
                props.enqueuedSequenceNumber = msg.message_annotations[amqpCommon.Constants.enqueueSequenceNumber];
            }
            if (msg.message_annotations[amqpCommon.Constants.sequenceNumber] != undefined) {
                if (Buffer.isBuffer(msg.message_annotations[amqpCommon.Constants.sequenceNumber])) {
                    props.sequenceNumber = Long.fromBytesBE(msg.message_annotations[amqpCommon.Constants.sequenceNumber]);
                }
                else {
                    props.sequenceNumber = Long.fromNumber(msg.message_annotations[amqpCommon.Constants.sequenceNumber]);
                }
            }
            if (msg.message_annotations[amqpCommon.Constants.enqueuedTime] != undefined) {
                props.enqueuedTimeUtc = new Date(msg.message_annotations[amqpCommon.Constants.enqueuedTime]);
            }
            if (msg.message_annotations[amqpCommon.Constants.lockedUntil] != undefined) {
                props.lockedUntilUtc = new Date(msg.message_annotations[amqpCommon.Constants.lockedUntil]);
            }
        }
        if (msg.ttl != undefined &&
            msg.ttl >= amqpCommon.Constants.maxDurationValue - props.enqueuedTimeUtc.getTime()) {
            props.expiresAtUtc = new Date(amqpCommon.Constants.maxDurationValue);
        }
        else {
            props.expiresAtUtc = new Date(props.enqueuedTimeUtc.getTime() + msg.ttl);
        }
        const rcvdsbmsg = Object.assign({ _amqpMessage: msg, _delivery: delivery, deliveryCount: msg.delivery_count, lockToken: delivery && delivery.tag.length !== 0
                ? rheaPromise.uuid_to_string(reorderLockToken(typeof delivery.tag === "string" ? Buffer.from(delivery.tag) : delivery.tag))
                : undefined }, sbmsg, props);
        message("AmqpMessage to ReceivedSBMessage: %O", rcvdsbmsg);
        return rcvdsbmsg;
    }
    ReceivedMessageInfo.fromAmqpMessage = fromAmqpMessage;
})(ReceivedMessageInfo || (ReceivedMessageInfo = {}));
/**
 * Describes the message received from ServiceBus.
 * @class ServiceBusMessage
 */
class ServiceBusMessage {
    /**
     * @internal
     */
    constructor(context, msg, delivery) {
        Object.assign(this, ReceivedMessageInfo.fromAmqpMessage(msg, delivery));
        this._context = context;
        if (msg.body) {
            this.body = this._context.namespace.dataTransformer.decode(msg.body);
        }
        this._amqpMessage = msg;
        this.delivery = delivery;
    }
    /**
     * Completes a message using it's lock token. This will delete the message from ServiceBus.
     * @returns Promise<void>.
     */
    complete() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            message("[%s] Completing the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus([this.lockToken], DispositionStatus.completed, {
                    sessionId: this.sessionId
                });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver$$1 = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            if (receiver$$1.receiveMode !== ReceiveMode.peekLock) {
                throw new Error("The operation is only supported in 'PeekLock' receive mode.");
            }
            if (this.delivery.remote_settled) {
                throw new Error("This message has been already settled.");
            }
            return receiver$$1.settleMessage(this, DispositionType.complete);
        });
    }
    /**
     * Abandons a message using it's lock token. This will make the message available again in
     * Service Bus for processing.
     * @param {{ [key: string]: any }} propertiesToModify The properties of the message to modify while
     * abandoning the message. Abandoning a message will increase the delivery count on the message.
     * @return Promise<void>.
     */
    abandon(propertiesToModify) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // TODO: Figure out a mechanism to convert specified properties to message_annotations.
            message("[%s] Abandoning the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus([this.lockToken], DispositionStatus.abandoned, { propertiesToModify: propertiesToModify, sessionId: this.sessionId });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver$$1 = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            if (receiver$$1.receiveMode !== ReceiveMode.peekLock) {
                throw new Error("The operation is only supported in 'PeekLock' receive mode.");
            }
            if (this.delivery.remote_settled) {
                throw new Error("This message has been already settled.");
            }
            return receiver$$1.settleMessage(this, DispositionType.abandon, {
                propertiesToModify: propertiesToModify
            });
        });
    }
    /**
     * Defers the processing of the message. In order to receive this message again in the future,
     * you will need to save the `sequenceNumber` and receive it
     * using `receiveDeferredMessage(sequenceNumber)`. Deferring messages does not impact message's
     * expiration, meaning that deferred messages can still expire.
     * @param [propertiesToModify] The properties of the message to modify while
     * deferring the message
     * @returns Promise<void>
     */
    defer(propertiesToModify) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            message("[%s] Deferring the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus([this.lockToken], DispositionStatus.defered, { propertiesToModify: propertiesToModify, sessionId: this.sessionId });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver$$1 = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            if (receiver$$1.receiveMode !== ReceiveMode.peekLock) {
                throw new Error("The operation is only supported in 'PeekLock' receive mode.");
            }
            if (this.delivery.remote_settled) {
                throw new Error("This message has been already settled.");
            }
            return receiver$$1.settleMessage(this, DispositionType.defer, {
                propertiesToModify: propertiesToModify
            });
        });
    }
    /**
     * Moves the message to the deadletter sub-queue.
     * @param [options] The DeadLetter options that can be provided while
     * rejecting the message.
     * @returns Promise<void>
     */
    deadLetter(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const error$$1 = {
                condition: amqpCommon.Constants.deadLetterName
            };
            if (options) {
                error$$1.info = {
                    DeadLetterReason: options.deadletterReason,
                    DeadLetterErrorDescription: options.deadLetterErrorDescription
                };
            }
            message("[%s] Deadlettering the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus([this.lockToken], DispositionStatus.suspended, {
                    deadLetterReason: error$$1.condition,
                    deadLetterDescription: error$$1.description,
                    sessionId: this.sessionId
                });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver$$1 = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            if (receiver$$1.receiveMode !== ReceiveMode.peekLock) {
                throw new Error("The operation is only supported in 'PeekLock' receive mode.");
            }
            if (this.delivery.remote_settled) {
                throw new Error("This message has been already settled.");
            }
            return receiver$$1.settleMessage(this, DispositionType.deadletter, {
                error: error$$1
            });
        });
    }
    /**
     * Creates a clone of the current message to allow it to be re-sent to the queue
     * @returns ServiceBusMessage
     */
    clone() {
        // We are returning a SendableMessageInfo object because that object can then be sent to ServiceBus
        const clone = {
            body: this.body,
            contentType: this.contentType,
            correlationId: this.correlationId,
            label: this.label,
            messageId: this.messageId,
            partitionKey: this.partitionKey,
            replyTo: this.replyTo,
            replyToSessionId: this.replyToSessionId,
            scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,
            sessionId: this.sessionId,
            timeToLive: this.timeToLive,
            to: this.to,
            userProperties: this.userProperties,
            viaPartitionKey: this.viaPartitionKey
        };
        return clone;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Enum to denote who is calling the session receiver
 * @internal
 */
var SessionCallee;
(function (SessionCallee) {
    SessionCallee["standalone"] = "standalone";
    SessionCallee["sessionManager"] = "sessionManager";
})(SessionCallee || (SessionCallee = {}));
/**
 * @internal
 * Describes the receiver for a Message Session.
 */
class MessageSession extends LinkEntity {
    constructor(context, options) {
        super(context.entityPath, context, {
            address: context.entityPath,
            audience: `${context.namespace.config.endpoint}${context.entityPath}`
        });
        /**
         * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
         * processed concurrently in a session while in streaming mode. Once this limit has been reached,
         * more messages will not be received until the user's message handler has completed processing current message.
         * - **Default**: `1` (message in a session at a time).
         */
        this.maxConcurrentCalls = 1;
        /**
         * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */
        this._deliveryDispositionMap = new Map();
        this._context.isSessionEnabled = true;
        this.isReceivingMessages = false;
        if (!options)
            options = {};
        this.autoComplete = false;
        this.sessionId = options.sessionId;
        this.receiveMode = options.receiveMode || ReceiveMode.peekLock;
        this.callee = options.callee || SessionCallee.standalone;
        this.maxAutoRenewDurationInSeconds =
            options.maxSessionAutoRenewLockDurationInSeconds != undefined
                ? options.maxSessionAutoRenewLockDurationInSeconds
                : 300;
        this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
        this.autoRenewLock =
            this.maxAutoRenewDurationInSeconds > 0 && this.receiveMode === ReceiveMode.peekLock;
        // setting all the handlers
        this._onSettled = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const delivery = context.delivery;
            if (delivery) {
                const id = delivery.id;
                const state = delivery.remote_state;
                const settled = delivery.remote_settled;
                receiver("[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been " + "received.", connectionId, id, settled, state && state.error ? state.error : state);
                if (settled && this._deliveryDispositionMap.has(id)) {
                    const promise = this._deliveryDispositionMap.get(id);
                    clearTimeout(promise.timer);
                    receiver("[%s] Found the delivery with id %d in the map and cleared the timer.", connectionId, id);
                    const deleteResult = this._deliveryDispositionMap.delete(id);
                    receiver("[%s] Successfully deleted the delivery with id %d from the map.", connectionId, id, deleteResult);
                    if (state && state.error && (state.error.condition || state.error.description)) {
                        const error$$1 = amqpCommon.translate(state.error);
                        return promise.reject(error$$1);
                    }
                    return promise.resolve();
                }
            }
        };
        this._notifyError = (error$$1) => {
            if (this._onError) {
                this._onError(error$$1);
                error("[%s] Notified the user's error handler about the error received by the " +
                    "Receiver '%s'.", this._context.namespace.connectionId, this.name);
            }
        };
        this._onAmqpError = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = amqpCommon.translate(receiverError);
                if (sbError.name === "SessionLockLostError") {
                    this._context.expiredMessageSessions[this.sessionId] = true;
                    sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;
                }
                error("[%s] An error occurred for Receiver '%s': %O.", connectionId, this.name, sbError);
                this._notifyError(sbError);
            }
        };
        this._onSessionError = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = amqpCommon.translate(sessionError);
                error("[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);
                this._notifyError(sbError);
            }
        };
        this._onAmqpClose = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            const receiver$$1 = this._receiver || context.receiver;
            let clearExpiredSessionFlag = true;
            if (receiverError) {
                const sbError = amqpCommon.translate(receiverError);
                if (sbError.name === "SessionLockLostError") {
                    clearExpiredSessionFlag = false;
                }
                error("[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
                // no need to notify the user's error handler since rhea guarantees that receiver_error
                // will always be emitted before receiver_close.
            }
            if (receiver$$1 && !receiver$$1.isItselfClosed()) {
                error("[%s] 'receiver_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", connectionId, this.name, this.sessionId);
                try {
                    yield this.close();
                }
                catch (err) {
                    error("[%s] An error occurred while closing the receiver '%s' for sessionId '%s': %O.", connectionId, this.name, this.sessionId, err);
                }
            }
            else {
                error("[%s] 'receiver_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "because the sdk initiated it. Hence no need to gracefully close the receiver", connectionId, this.name, this.sessionId);
            }
            if (this.sessionId && clearExpiredSessionFlag) {
                delete this._context.expiredMessageSessions[this.sessionId];
            }
        });
        this._onSessionClose = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const receiver$$1 = this._receiver || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = amqpCommon.translate(sessionError);
                error("[%s] 'session_close' event occurred for receiver '%s' for sessionId '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
                // no need to notify the user's error handler since rhea guarantees that session_error
                // will always be emitted before session_close.
            }
            if (receiver$$1 && !receiver$$1.isSessionItselfClosed()) {
                error("[%s] 'session_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", connectionId, this.name, this.sessionId);
                try {
                    yield this.close();
                }
                catch (err) {
                    error("[%s] An error occurred while closing the receiver '%s' for sessionId '%s': %O.", connectionId, this.name, this.sessionId, err);
                }
            }
            else {
                error("[%s] 'session_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "because the sdk initiated it. Hence no need to gracefully close the receiver", connectionId, this.name, this.sessionId);
            }
        });
    }
    /**
     * Closes the underlying AMQP receiver link.
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                messageSession("[%s] Closing the MessageSession '%s' for queue '%s'.", this._context.namespace.connectionId, this.sessionId, this.name);
                this.isReceivingMessages = false;
                if (this._newMessageReceivedTimer)
                    clearTimeout(this._newMessageReceivedTimer);
                if (this._sessionLockRenewalTimer)
                    clearTimeout(this._sessionLockRenewalTimer);
                messageSession("[%s] Cleared the timers for 'no new message received' task and " +
                    "'session lock renewal' task.", this._context.namespace.connectionId);
                if (this._receiver) {
                    const receiverLink = this._receiver;
                    this._deleteFromCache();
                    yield this._closeLink(receiverLink);
                }
            }
            catch (err) {
                error("[%s] An error occurred while closing the message session with id '%s': %O.", this._context.namespace.connectionId, this.sessionId, err);
            }
        });
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     */
    isOpen() {
        const result = this._receiver && this._receiver.isOpen();
        messageSession("[%s] Receiver '%s' for sessionId '%s' is open? -> %s", this._context.namespace.connectionId, this.name, this.sessionId, result);
        return result;
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver or set the property
     * `newMessageWaitTimeoutInSeconds` in the options to provide a timeout.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed. You can
     * also provide a timeout in seconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     *
     * @returns void
     */
    receive(onMessage, onError, options) {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (this.isReceivingMessages) {
            throw new Error(`MessageSession '${this.name}' with sessionId '${this.sessionId}' is ` +
                `already receiving messages.`);
        }
        if (typeof onMessage !== "function") {
            throw new Error("'onSessionMessage' is a required parameter and must be of type 'function'.");
        }
        if (typeof onError !== "function") {
            throw new Error("'onError' is a required parameter and must be of type 'function'.");
        }
        if (!options)
            options = {};
        this.isReceivingMessages = true;
        if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) {
            this.maxConcurrentCalls = options.maxConcurrentCalls;
        }
        this.newMessageWaitTimeoutInSeconds = options.newMessageWaitTimeoutInSeconds;
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete = options.autoComplete === false ? options.autoComplete : true;
        this._onMessage = onMessage;
        this._onError = onError;
        const connectionId = this._context.namespace.connectionId;
        /**
         * Resets the timer when a new message is received for Session Manager.
         * It will close the receiver gracefully, if no
         * messages were received for the configured newMessageWaitTimeoutInSeconds
         */
        const resetTimerOnNewMessageReceived = () => {
            if (this._newMessageReceivedTimer)
                clearTimeout(this._newMessageReceivedTimer);
            if (this.newMessageWaitTimeoutInSeconds) {
                this._newMessageReceivedTimer = setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const msg = `MessageSession '${this.sessionId}' with name '${this.name}' did not receive ` +
                        `any messages in the last ${this.newMessageWaitTimeoutInSeconds} seconds. Hence closing it.`;
                    error("[%s] %s", this._context.namespace.connectionId, msg);
                    if (this.callee === SessionCallee.sessionManager) {
                        // The session manager will not forward this error to user.
                        // Instead, this is taken as a indicator to create a new session client for the next session.
                        const error$$1 = amqpCommon.translate({
                            condition: "com.microsoft:message-wait-timeout",
                            description: msg
                        });
                        this._notifyError(amqpCommon.translate(error$$1));
                    }
                    yield this.close();
                }), this.newMessageWaitTimeoutInSeconds * 1000);
            }
        };
        if (this._receiver && this._receiver.isOpen()) {
            const onSessionMessage = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // If the receiver got closed in PeekLock mode, avoid processing the message as we
                // cannot settle the message.
                if (this.receiveMode === ReceiveMode.peekLock &&
                    (!this._receiver || !this._receiver.isOpen())) {
                    error("[%s] Not calling the user's message handler for the current message " +
                        "as the receiver '%s' is closed", connectionId, this.name);
                    return;
                }
                resetTimerOnNewMessageReceived();
                const bMessage = new ServiceBusMessage(this._context, context.message, context.delivery);
                try {
                    yield this._onMessage(bMessage);
                }
                catch (err) {
                    // This ensures we call users' error handler when users' message handler throws.
                    if (!rheaPromise.isAmqpError(err)) {
                        error("[%s] An error occurred while running user's message handler for the message " +
                            "with id '%s' on the receiver '%s': %O", connectionId, bMessage.messageId, this.name, err);
                        this._onError(err);
                    }
                    const error$$1 = amqpCommon.translate(err);
                    // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                    if (!bMessage.delivery.remote_settled &&
                        this.receiveMode === ReceiveMode.peekLock &&
                        this.isOpen() // only try to abandon the messages if the connection is still open
                    ) {
                        try {
                            error("[%s] Abandoning the message with id '%s' on the receiver '%s' since " +
                                "an error occured: %O.", connectionId, bMessage.messageId, this.name, error$$1);
                            yield bMessage.abandon();
                        }
                        catch (abandonError) {
                            const translatedError = amqpCommon.translate(abandonError);
                            error("[%s] An error occurred while abandoning the message with id '%s' on the " +
                                "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                            this._notifyError(translatedError);
                        }
                    }
                    return;
                }
                finally {
                    if (this._receiver) {
                        this._receiver.addCredit(1);
                    }
                }
                // If we've made it this far, then user's message handler completed fine. Let us try
                // completing the message.
                if (this.autoComplete &&
                    this.receiveMode === ReceiveMode.peekLock &&
                    !bMessage.delivery.remote_settled) {
                    try {
                        messageSession("[%s] Auto completing the message with id '%s' on " + "the receiver '%s'.", connectionId, bMessage.messageId, this.name);
                        yield bMessage.complete();
                    }
                    catch (completeError) {
                        const translatedError = amqpCommon.translate(completeError);
                        error("[%s] An error occurred while completing the message with id '%s' on the " +
                            "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                        this._notifyError(translatedError);
                    }
                }
            });
            // setting the "message" event listener.
            this._receiver.on(rheaPromise.ReceiverEvents.message, onSessionMessage);
            // adding credit
            this._receiver.addCredit(this.maxConcurrentCalls);
        }
        else {
            this.isReceivingMessages = false;
            const msg = `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +
                `has either not been created or is not open.`;
            error("[%s] %s", this._context.namespace.connectionId, msg);
            this._notifyError(new Error(msg));
        }
    }
    /**
     * Returns a batch of messages based on given count and timeout over an AMQP receiver link
     * from a Queue/Subscription.
     *
     * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
     * @param idleTimeoutInSeconds The maximum wait time in seconds for which the Receiver
     * should wait to receive the first message. If no message is received by this time,
     * the returned promise gets resolved to an empty array.
     * - **Default**: `60` seconds.
     * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
     */
    receiveBatch(maxMessageCount, idleTimeoutInSeconds) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (this.isReceivingMessages) {
                throw new Error(`MessageSession '${this.name}' with sessionId '${this.sessionId}' is ` +
                    `already receiving messages.`);
            }
            if (!maxMessageCount || (maxMessageCount && typeof maxMessageCount !== "number")) {
                throw new Error("'maxMessageCount' is a required parameter of type number with a value " + "greater than 0.");
            }
            if (idleTimeoutInSeconds == undefined) {
                idleTimeoutInSeconds = amqpCommon.Constants.defaultOperationTimeoutInSeconds;
            }
            const brokeredMessages = [];
            this.isReceivingMessages = true;
            return new Promise((resolve, reject) => {
                let onReceiveMessage;
                let onReceiveDrain;
                let firstMessageWaitTimer;
                let actionAfterWaitTimeout;
                const setnewMessageWaitTimeoutInSeconds = (value) => {
                    this.newMessageWaitTimeoutInSeconds = value;
                };
                setnewMessageWaitTimeoutInSeconds(1);
                this._onError = (error$$1) => {
                    this.isReceivingMessages = false;
                    // Resetting the newMessageWaitTimeoutInSeconds to undefined since we are done receiving
                    // a batch of messages.
                    setnewMessageWaitTimeoutInSeconds();
                    if (firstMessageWaitTimer) {
                        clearTimeout(firstMessageWaitTimer);
                    }
                    // Removing listeners, so that the next receiveBatch() call can set them again.
                    if (this._receiver) {
                        this._receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                        this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    }
                    reject(error$$1);
                };
                // Final action to be performed after maxMessageCount is reached or the maxWaitTime is over.
                const finalAction = () => {
                    if (this._newMessageReceivedTimer) {
                        clearTimeout(this._newMessageReceivedTimer);
                    }
                    if (firstMessageWaitTimer) {
                        clearTimeout(firstMessageWaitTimer);
                    }
                    // Unsetting the newMessageWaitTimeoutInSeconds to undefined since we are done receiving
                    // a batch of messages.
                    setnewMessageWaitTimeoutInSeconds();
                    // Removing listeners, so that the next receiveBatch() call can set them again.
                    if (this._receiver) {
                        this._receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                    }
                    if (this._receiver && this._receiver.credit > 0) {
                        messageSession("[%s] Receiver '%s': Draining leftover credits(%d).", this._context.namespace.connectionId, this.name, this._receiver.credit);
                        // Setting drain must be accompanied by a flow call (aliased to addCredit in this case).
                        this._receiver.drain = true;
                        this._receiver.addCredit(1);
                    }
                    else {
                        if (this._receiver) {
                            this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                        }
                        this.isReceivingMessages = false;
                        messageSession("[%s] Receiver '%s': Resolving receiveBatch() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                        resolve(brokeredMessages);
                    }
                };
                /**
                 * Resets the timer when a new message is received. If no messages were received for
                 * `newMessageWaitTimeoutInSeconds`, the messages received till now are returned. The
                 * receiver link stays open for the next receive call, but doesnt receive messages until
                 */
                const resetTimerOnNewMessageReceived = () => {
                    if (this._newMessageReceivedTimer)
                        clearTimeout(this._newMessageReceivedTimer);
                    if (this.newMessageWaitTimeoutInSeconds) {
                        this._newMessageReceivedTimer = setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            const msg = `MessageSession '${this.sessionId}' with name '${this.name}' did not receive ` +
                                `any messages in the last ${this.newMessageWaitTimeoutInSeconds} seconds. Hence closing it.`;
                            error("[%s] %s", this._context.namespace.connectionId, msg);
                            finalAction();
                            if (this.callee === SessionCallee.sessionManager) {
                                yield this.close();
                            }
                        }), this.newMessageWaitTimeoutInSeconds * 1000);
                    }
                };
                // Action to be performed after the max wait time is over.
                actionAfterWaitTimeout = () => {
                    batching("[%s] Batching Receiver '%s'  max wait time in seconds %d over.", this._context.namespace.connectionId, this.name, idleTimeoutInSeconds);
                    return finalAction();
                };
                // Action to be performed on the "receiver_drained" event.
                onReceiveDrain = (context) => {
                    this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    this._receiver.drain = false;
                    this.isReceivingMessages = false;
                    messageSession("[%s] Receiver '%s' drained. Resolving receiveBatch() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                    resolve(brokeredMessages);
                };
                // Action to be performed on the "message" event.
                onReceiveMessage = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (firstMessageWaitTimer) {
                        clearTimeout(firstMessageWaitTimer);
                        firstMessageWaitTimer = undefined;
                    }
                    resetTimerOnNewMessageReceived();
                    try {
                        const data = new ServiceBusMessage(this._context, context.message, context.delivery);
                        if (brokeredMessages.length < maxMessageCount) {
                            brokeredMessages.push(data);
                        }
                    }
                    catch (err) {
                        // Removing listeners, so that the next receiveBatch() call can set them again.
                        if (this._receiver) {
                            this._receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                            this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                        }
                        reject(`Error while converting AmqpMessage to ReceivedSBMessage: ${err}`);
                    }
                    if (brokeredMessages.length === maxMessageCount) {
                        finalAction();
                    }
                });
                const addCreditAndSetTimer = (reuse) => {
                    batching("[%s] Receiver '%s', adding credit for receiving %d messages.", this._context.namespace.connectionId, this.name, maxMessageCount);
                    // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
                    // number of messages concurrently. We will return the user an array of messages that can
                    // be of size upto maxMessageCount. Then the user needs to accordingly dispose
                    // (complete,/abandon/defer/deadletter) the messages from the array.
                    this._receiver.addCredit(maxMessageCount);
                    let msg = "[%s] Setting the wait timer for %d seconds for receiver '%s'.";
                    if (reuse)
                        msg += " Receiver link already present, hence reusing it.";
                    batching(msg, this._context.namespace.connectionId, idleTimeoutInSeconds, this.name);
                    firstMessageWaitTimer = setTimeout(actionAfterWaitTimeout, idleTimeoutInSeconds * 1000);
                };
                if (this.isOpen()) {
                    this._receiver.on(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                    this._receiver.on(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    addCreditAndSetTimer(true);
                }
                else {
                    const msg = `MessageSession "${this.name}" with sessionId "${this.sessionId}", ` +
                        `is already closed. Hence cannot receive messages in a batch.`;
                    error("[%s] %s", this._context.namespace.connectionId, msg);
                    reject(new Error(msg));
                }
            });
        });
    }
    /**
     * Settles the message with the specified disposition.
     * @param message The ServiceBus Message that needs to be settled.
     * @param operation The disposition type.
     * @param options Optional parameters that can be provided while disposing the message.
     */
    settleMessage(message$$1, operation, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (!options)
                    options = {};
                if (operation.match(/^(complete|abandon|defer|deadletter)$/) == undefined) {
                    return reject(new Error(`operation: '${operation}' is not a valid operation.`));
                }
                const delivery = message$$1.delivery;
                const timer = setTimeout(() => {
                    this._deliveryDispositionMap.delete(delivery.id);
                    receiver("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                        "Hence resolving the promise.", this._context.namespace.connectionId, delivery.id, messageDispositionTimeout);
                    return resolve();
                }, messageDispositionTimeout);
                this._deliveryDispositionMap.set(delivery.id, {
                    resolve: resolve,
                    reject: reject,
                    timer: timer
                });
                if (operation === DispositionType.complete) {
                    delivery.accept();
                }
                else if (operation === DispositionType.abandon) {
                    const params = {
                        undeliverable_here: false
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.defer) {
                    const params = {
                        undeliverable_here: true
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.deadletter) {
                    delivery.reject(options.error || {});
                }
            });
        });
    }
    /**
     * Deletes the MessageSession from the internal cache.
     */
    _deleteFromCache() {
        this._receiver = undefined;
        delete this._context.messageSessions[this.sessionId];
        error("[%s] Deleted the receiver '%s' with sessionId '%s' from the client cache.", this._context.namespace.connectionId, this.name, this.sessionId);
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     */
    _init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            try {
                if (!this.isOpen() && !this.isConnecting) {
                    error("[%s] The receiver '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", connectionId, this.name, this.address);
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    const options = this._createMessageSessionOptions();
                    error("[%s] Trying to create receiver '%s' with options %O", connectionId, this.name, options);
                    this._receiver = yield this._context.namespace.connection.createReceiver(options);
                    this.isConnecting = false;
                    const receivedSessionId = this._receiver.source &&
                        this._receiver.source.filter &&
                        this._receiver.source.filter[amqpCommon.Constants.sessionFilterName];
                    let errorMessage = "";
                    // SB allows a sessionId with empty string value :)
                    if (receivedSessionId == undefined) {
                        errorMessage =
                            `Received an incorrect sessionId '${receivedSessionId}' while creating ` +
                                `the receiver '${this.name}'.`;
                    }
                    if (this.sessionId != undefined && receivedSessionId !== this.sessionId) {
                        errorMessage =
                            `Received sessionId '${receivedSessionId}' does not match the provided ` +
                                `sessionId '${this.sessionId}' while creating the receiver '${this.name}'.`;
                    }
                    if (errorMessage) {
                        const error$$1 = amqpCommon.translate({
                            description: errorMessage,
                            condition: amqpCommon.ErrorNameConditionMapper.SessionCannotBeLockedError
                        });
                        error("[%s] %O", this._context.namespace.connectionId, error$$1);
                        throw error$$1;
                    }
                    if (this.sessionId == undefined)
                        this.sessionId = receivedSessionId;
                    this.sessionLockedUntilUtc = convertTicksToDate(this._receiver.properties["com.microsoft:locked-until-utc"]);
                    messageSession("[%s] Session with id '%s' is locked until: '%s'.", connectionId, this.sessionId, this.sessionLockedUntilUtc.toISOString());
                    error("[%s] Receiver '%s' for sessionId '%s' has established itself.", connectionId, this.name, this.sessionId);
                    messageSession("Promise to create the receiver resolved. " + "Created receiver with name: ", this.name);
                    messageSession("[%s] Receiver '%s' created with receiver options: %O", connectionId, this.name, options);
                    if (!this._context.messageSessions[this.sessionId]) {
                        this._context.messageSessions[this.sessionId] = this;
                    }
                    this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
                    yield this._ensureTokenRenewal();
                    yield this._ensureSessionLockRenewal();
                }
                else {
                    error("[%s] The receiver '%s' for sessionId '%s' is open -> %s and is connecting " +
                        "-> %s. Hence not reconnecting.", connectionId, this.name, this.sessionId, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                err = amqpCommon.translate(err);
                error("[%s] An error occured while creating the receiver '%s': %O", this._context.namespace.connectionId, this.name, err);
                throw err;
            }
        });
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */
    _createMessageSessionOptions() {
        const rcvrOptions = {
            name: this.name,
            autoaccept: false,
            // receiveAndDelete -> first(0), peekLock -> second (1)
            rcv_settle_mode: this.receiveMode === ReceiveMode.receiveAndDelete ? 0 : 1,
            // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
            snd_settle_mode: this.receiveMode === ReceiveMode.receiveAndDelete ? 1 : 0,
            source: {
                address: this.address,
                filter: {}
            },
            credit_window: 0,
            onClose: (context) => this._onAmqpClose(context).catch(() => {
                /* */
            }),
            onSessionClose: (context) => this._onSessionClose(context).catch(() => {
                /* */
            }),
            onError: this._onAmqpError,
            onSessionError: this._onSessionError,
            onSettled: this._onSettled
        };
        rcvrOptions.source.filter[amqpCommon.Constants.sessionFilterName] = this.sessionId;
        return rcvrOptions;
    }
    /**
     * Ensures that the session lock is renewed before it expires. The lock will not be renewed for
     * more than the configured totalAutoLockRenewDuration.
     */
    _ensureSessionLockRenewal() {
        if (this.autoRenewLock &&
            new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc &&
            Date.now() < this._totalAutoLockRenewDuration &&
            this.isOpen()) {
            const connectionId = this._context.namespace.connectionId;
            const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc);
            this._sessionLockRenewalTimer = setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    messageSession("[%s] Attempting to renew the session lock for MessageSession '%s' " +
                        "with name '%s'.", connectionId, this.sessionId, this.name);
                    this.sessionLockedUntilUtc = yield this._context.managementClient.renewSessionLock(this.sessionId, {
                        delayInSeconds: 0,
                        timeoutInSeconds: 10,
                        times: 4
                    });
                    receiver("[%s] Successfully renewed the session lock for MessageSession '%s' " +
                        "with name '%s'.", connectionId, this.sessionId, this.name);
                    receiver("[%s] Calling _ensureSessionLockRenewal() again for MessageSession '%s'.", connectionId, this.sessionId);
                    this._ensureSessionLockRenewal();
                }
                catch (err) {
                    error("[%s] An error occurred while renewing the session lock for MessageSession " +
                        "'%s' with name '%s': %O", this._context.namespace.connectionId, this.sessionId, this.name, err);
                }
            }), nextRenewalTimeout);
            messageSession("[%s] MessageSession '%s' with name '%s', has next session lock renewal " +
                "in %d seconds @(%s).", this._context.namespace.connectionId, this.sessionId, this.name, nextRenewalTimeout / 1000, new Date(Date.now() + nextRenewalTimeout).toString());
        }
    }
    /**
     * Creates a new instance of the MessageSession based on the provided parameters.
     * @param context The client entity context
     * @param options Options that can be provided while creating the MessageSession.
     */
    static create(context, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(context.namespace);
            const messageSession$$1 = new MessageSession(context, options);
            yield messageSession$$1._init();
            return messageSession$$1;
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Describes the MessageSender that will send messages to ServiceBus.
 * @class MessageSender
 */
class MessageSender extends LinkEntity {
    /**
     * Creates a new MessageSender instance.
     * @constructor
     * @param {ClientEntityContext} context The client entity context.
     */
    constructor(context) {
        super(context.entityPath, context, {
            address: context.entityPath,
            audience: `${context.namespace.config.endpoint}${context.entityPath}`
        });
        /**
         * @property {string} senderLock The unqiue lock name per connection that is used to acquire the
         * lock for establishing a sender link by an entity on that connection.
         * @readonly
         */
        this.senderLock = `sender-${rheaPromise.generate_uuid()}`;
        this._onAmqpError = (context) => {
            const senderError = context.sender && context.sender.error;
            if (senderError) {
                const err = amqpCommon.translate(senderError);
                error("[%s] An error occurred for sender '%s': %O.", this._context.namespace.connectionId, this.name, err);
            }
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const err = amqpCommon.translate(sessionError);
                error("[%s] An error occurred on the session of sender '%s': %O.", this._context.namespace.connectionId, this.name, err);
            }
        };
        this._onAmqpClose = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sender$$1 = this._sender || context.sender;
            const senderError = context.sender && context.sender.error;
            if (senderError) {
                error("[%s] 'sender_close' event occurred for sender '%s' with address '%s'. " +
                    "The associated error is: %O", this._context.namespace.connectionId, this.name, this.address, senderError);
            }
            if (sender$$1 && !sender$$1.isItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                        "and the sdk did not initiate this. The sender is not reconnecting. Hence, calling " +
                        "detached from the _onAmqpClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                    yield this.detached(senderError);
                }
                else {
                    error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                        "and the sdk did not initate this. Moreover the sender is already re-connecting. " +
                        "Hence not calling detached from the _onAmqpClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", this._context.namespace.connectionId, this.name, this.address);
            }
        });
        this._onSessionClose = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sender$$1 = this._sender || context.sender;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                error("[%s] 'session_close' event occurred for sender '%s' with address '%s'. " +
                    "The associated error is: %O", this._context.namespace.connectionId, this.name, this.address, sessionError);
            }
            if (sender$$1 && !sender$$1.isSessionItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'session_close' event occurred on the session of sender '%s' with " +
                        "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                        "_onSessionClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                    yield this.detached(sessionError);
                }
                else {
                    error("[%s] 'session_close' event occurred on the session of sender '%s' with " +
                        "address '%s' and the sdk did not initiate this. Moreover the sender is already " +
                        "re-connecting. Hence not calling detached from the _onSessionClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'session_close' event occurred on the session of sender '%s' with address " +
                    "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                    "() handler.", this._context.namespace.connectionId, this.name, this.address);
            }
        });
    }
    /**
     * Will reconnect the sender link if necessary.
     * @param {AmqpError | Error} [senderError] The sender error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    detached(senderError) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const wasCloseInitiated = this._sender && this._sender.isItselfClosed();
                // Clears the token renewal timer. Closes the link and its session if they are open.
                // Removes the link and its session if they are present in rhea's cache.
                yield this._closeLink(this._sender);
                // We should attempt to reopen only when the sender(sdk) did not initiate the close
                let shouldReopen = false;
                if (senderError && !wasCloseInitiated) {
                    const translatedError = amqpCommon.translate(senderError);
                    if (translatedError.retryable) {
                        shouldReopen = true;
                        error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                            "was an accompanying error an it is retryable. This is a candidate for re-establishing " +
                            "the sender link.", this._context.namespace.connectionId, this.name, this.address);
                    }
                    else {
                        error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                            "the sender link.", this._context.namespace.connectionId, this.name, this.address);
                    }
                }
                else if (!wasCloseInitiated) {
                    shouldReopen = true;
                    error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                        "was no accompanying error as well. This is a candidate for re-establishing " +
                        "the sender link.", this._context.namespace.connectionId, this.name, this.address);
                }
                else {
                    const state = {
                        wasCloseInitiated: wasCloseInitiated,
                        senderError: senderError,
                        _sender: this._sender
                    };
                    error("[%s] Something is busted. State of sender '%s' with address '%s' is: %O", this._context.namespace.connectionId, this.name, this.address, state);
                }
                if (shouldReopen) {
                    yield amqpCommon.defaultLock.acquire(this.senderLock, () => {
                        const options = this._createSenderOptions({
                            newName: true
                        });
                        // shall retry forever at an interval of 15 seconds if the error is a retryable error
                        // else bail out when the error is not retryable or the oepration succeeds.
                        const config = {
                            operation: () => this._init(options),
                            connectionId: this._context.namespace.connectionId,
                            operationType: amqpCommon.RetryOperationType.senderLink,
                            times: amqpCommon.Constants.defaultConnectionRetryAttempts,
                            delayInSeconds: 15
                        };
                        return amqpCommon.retry(config);
                    });
                }
            }
            catch (err) {
                error("[%s] An error occurred while processing detached() of Sender '%s' with address " +
                    "'%s': %O", this._context.namespace.connectionId, this.name, this.address, err);
            }
        });
    }
    /**
     * Deletes the sender fromt the context. Clears the token renewal timer. Closes the sender link.
     * @return {Promise<void>} Promise<void>
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this._sender) {
                sender("[%s] Closing the Sender for the entity '%s'.", this._context.namespace.connectionId, this._context.entityPath);
                const senderLink = this._sender;
                this._deleteFromCache();
                yield this._closeLink(senderLink);
            }
        });
    }
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this._sender && this._sender.isOpen();
        error("[%s] Sender '%s' with address '%s' is open? -> %s", this._context.namespace.connectionId, this.name, this.address, result);
        return result;
    }
    /**
     * Sends the given message, with the given options on this link
     *
     * @param {SendableMessageInfo} data Message to send.  Will be sent as UTF8-encoded JSON string.
     * @returns {Promise<void>}
     */
    send(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            try {
                if (!data || (data && typeof data !== "object")) {
                    throw new Error("data is required and it must be of type object.");
                }
                if (!this.isOpen()) {
                    sender("Acquiring lock %s for initializing the session, sender and " +
                        "possibly the connection.", this.senderLock);
                    yield amqpCommon.defaultLock.acquire(this.senderLock, () => {
                        return this._init();
                    });
                }
                const message$$1 = SendableMessageInfo.toAmqpMessage(data);
                message$$1.body = this._context.namespace.dataTransformer.encode(data.body);
                return yield this._trySend(message$$1);
            }
            catch (err) {
                error("An error occurred while sending the message %O", err);
                throw err;
            }
        });
    }
    /**
     * Send a batch of Message to the ServiceBus in a single AMQP message. The "message_annotations",
     * "application_properties" and "properties" of the first message will be set as that
     * of the envelope (batch message).
     * @param {Array<Message>} datas  An array of Message objects to be sent in a
     * Batch message.
     * @return {Promise<void>}
     */
    sendBatch(datas) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            try {
                if (!datas || (datas && !Array.isArray(datas))) {
                    throw new Error("data is required and it must be an Array.");
                }
                if (!this.isOpen()) {
                    sender("Acquiring lock %s for initializing the session, sender and " +
                        "possibly the connection.", this.senderLock);
                    yield amqpCommon.defaultLock.acquire(this.senderLock, () => {
                        return this._init();
                    });
                }
                sender("[%s] Sender '%s', trying to send Message[]: %O", this._context.namespace.connectionId, this.name, datas);
                const messages = [];
                // Convert Message to AmqpMessage.
                for (let i = 0; i < datas.length; i++) {
                    const message$$1 = SendableMessageInfo.toAmqpMessage(datas[i]);
                    message$$1.body = this._context.namespace.dataTransformer.encode(datas[i].body);
                    messages[i] = message$$1;
                }
                // Encode every amqp message and then convert every encoded message to amqp data section
                const batchMessage = {
                    body: rheaPromise.message.data_sections(messages.map(rheaPromise.message.encode))
                };
                // Set message_annotations, application_properties and properties of the first message as
                // that of the envelope (batch message).
                if (messages[0].message_annotations) {
                    batchMessage.message_annotations = messages[0].message_annotations;
                }
                if (messages[0].application_properties) {
                    batchMessage.application_properties = messages[0].application_properties;
                }
                for (const prop of rheaPromise.messageProperties) {
                    if (messages[0][prop]) {
                        batchMessage[prop] = messages[0][prop];
                    }
                }
                // Finally encode the envelope (batch message).
                const encodedBatchMessage = rheaPromise.message.encode(batchMessage);
                sender("[%s]Sender '%s', sending encoded batch message.", this._context.namespace.connectionId, this.name, encodedBatchMessage);
                return yield this._trySend(encodedBatchMessage, undefined, 0x80013700);
            }
            catch (err) {
                error("An error occurred while sending the batch message %O", err);
                throw err;
            }
        });
    }
    _deleteFromCache() {
        this._sender = undefined;
        delete this._context.sender;
        error("[%s] Deleted the sender '%s' with address '%s' from the client cache.", this._context.namespace.connectionId, this.name, this.address);
    }
    _createSenderOptions(options) {
        if (options.newName)
            this.name = getUniqueName(this._context.entityPath);
        const srOptions = {
            name: this.name,
            target: {
                address: this.address
            },
            onError: this._onAmqpError,
            onClose: this._onAmqpClose,
            onSessionError: this._onSessionError,
            onSessionClose: this._onSessionClose
        };
        sender("Creating sender with options: %O", srOptions);
        return srOptions;
    }
    /**
     * Tries to send the message to ServiceBus if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     *
     * @param message The message to be sent to ServiceBus.
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    _trySend(message$$1, tag, format) {
        const sendEventPromise = () => new Promise((resolve, reject) => {
            let waitTimer;
            sender("[%s] Sender '%s', credit: %d available: %d", this._context.namespace.connectionId, this.name, this._sender.credit, this._sender.session.outgoing.available());
            if (this._sender.sendable()) {
                sender("[%s] Sender '%s', sending message: %O", this._context.namespace.connectionId, this.name, message$$1);
                let onRejected;
                let onReleased;
                let onModified;
                let onAccepted;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    this._sender.removeListener(rheaPromise.SenderEvents.rejected, onRejected);
                    this._sender.removeListener(rheaPromise.SenderEvents.accepted, onAccepted);
                    this._sender.removeListener(rheaPromise.SenderEvents.released, onReleased);
                    this._sender.removeListener(rheaPromise.SenderEvents.modified, onModified);
                };
                onAccepted = (context) => {
                    // Since we will be adding listener for accepted and rejected event every time
                    // we send a message, we need to remove listener for both the events.
                    // This will ensure duplicate listeners are not added for the same event.
                    removeListeners();
                    sender("[%s] Sender '%s', got event accepted.", this._context.namespace.connectionId, this.name);
                    resolve();
                };
                onRejected = (context) => {
                    removeListeners();
                    error("[%s] Sender '%s', got event rejected.", this._context.namespace.connectionId, this.name);
                    const err = amqpCommon.translate(context.delivery.remote_state.error);
                    error(err);
                    reject(err);
                };
                onReleased = (context) => {
                    removeListeners();
                    error("[%s] Sender '%s', got event released.", this._context.namespace.connectionId, this.name);
                    let err;
                    if (context.delivery.remote_state.error) {
                        err = amqpCommon.translate(context.delivery.remote_state.error);
                    }
                    else {
                        err = new Error(`[${this._context.namespace.connectionId}]Sender '${this.name}', ` +
                            `received a release disposition.Hence we are rejecting the promise.`);
                    }
                    error(err);
                    reject(err);
                };
                onModified = (context) => {
                    removeListeners();
                    error("[%s] Sender '%s', got event modified.", this._context.namespace.connectionId, this.name);
                    let err;
                    if (context.delivery.remote_state.error) {
                        err = amqpCommon.translate(context.delivery.remote_state.error);
                    }
                    else {
                        err = new Error(`[${this._context.namespace.connectionId}]Sender "${this.name}", ` +
                            `received a modified disposition.Hence we are rejecting the promise.`);
                    }
                    error(err);
                    reject(err);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const desc = `[${this._context.namespace.connectionId}] Sender "${this.name}" ` +
                        `with address "${this.address}", was not able to send the message right now, due ` +
                        `to operation timeout.`;
                    error(desc);
                    const e = {
                        condition: amqpCommon.ErrorNameConditionMapper.ServiceUnavailableError,
                        description: desc
                    };
                    return reject(amqpCommon.translate(e));
                };
                this._sender.on(rheaPromise.SenderEvents.accepted, onAccepted);
                this._sender.on(rheaPromise.SenderEvents.rejected, onRejected);
                this._sender.on(rheaPromise.SenderEvents.modified, onModified);
                this._sender.on(rheaPromise.SenderEvents.released, onReleased);
                waitTimer = setTimeout(actionAfterTimeout, amqpCommon.Constants.defaultOperationTimeoutInSeconds * 1000);
                const delivery = this._sender.send(message$$1, tag, format);
                sender("[%s] Sender '%s', sent message with delivery id: %d", this._context.namespace.connectionId, this.name, delivery.id);
            }
            else {
                // let us retry to send the message after some time.
                const msg = `[${this._context.namespace.connectionId}] Sender "${this.name}", ` +
                    `cannot send the message right now. Please try later.`;
                error(msg);
                const amqpError = {
                    condition: amqpCommon.ErrorNameConditionMapper.SenderBusyError,
                    description: msg
                };
                reject(amqpCommon.translate(amqpError));
            }
        });
        const jitterInSeconds = amqpCommon.randomNumberFromInterval(1, 4);
        const config = {
            operation: sendEventPromise,
            connectionId: this._context.namespace.connectionId,
            operationType: amqpCommon.RetryOperationType.sendMessage,
            times: amqpCommon.Constants.defaultRetryAttempts,
            delayInSeconds: amqpCommon.Constants.defaultDelayBetweenOperationRetriesInSeconds + jitterInSeconds
        };
        return amqpCommon.retry(config);
    }
    /**
     * Initializes the sender session on the connection.
     */
    _init(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                // isOpen isConnecting  Should establish
                // true     false          No
                // true     true           No
                // false    true           No
                // false    false          Yes
                if (!this.isOpen()) {
                    error("[%s] The sender '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", this._context.namespace.connectionId, this.name, this.address);
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    error("[%s] Trying to create sender '%s'...", this._context.namespace.connectionId, this.name);
                    if (!options) {
                        options = this._createSenderOptions({});
                    }
                    this._sender = yield this._context.namespace.connection.createSender(options);
                    this.isConnecting = false;
                    error("[%s] Sender '%s' with address '%s' has established itself.", this._context.namespace.connectionId, this.name, this.address);
                    this._sender.setMaxListeners(1000);
                    error("[%s] Promise to create the sender resolved. Created sender with name: %s", this._context.namespace.connectionId, this.name);
                    error("[%s] Sender '%s' created with sender options: %O", this._context.namespace.connectionId, this.name, options);
                    // It is possible for someone to close the sender and then start it again.
                    // Thus make sure that the sender is present in the client cache.
                    if (!this._sender)
                        this._context.sender = this;
                    yield this._ensureTokenRenewal();
                }
            }
            catch (err) {
                err = amqpCommon.translate(err);
                error("[%s] An error occurred while creating the sender %s", this._context.namespace.connectionId, this.name, err);
                throw err;
            }
        });
    }
    /**
     * Creates a new sender to the specifiec ServiceBus entity, and optionally to a given
     * partition if it is not present in the context or returns the one present in the context.
     * @static
     * @returns {Promise<MessageSender>}
     */
    static create(context) {
        throwErrorIfConnectionClosed(context.namespace);
        if (!context.sender) {
            context.sender = new MessageSender(context);
        }
        return context.sender;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The Sender class can be used to send messages, schedule messages to be sent at a later time
 * and cancel such scheduled messages.
 * Use the `getSender` function on the QueueClient or TopicClient to instantiate a Sender.
 * The Sender class is an abstraction over the underlying AMQP sender link.
 * @class Sender
 */
class Sender {
    /**
     * @internal
     */
    constructor(context) {
        this._isClosed = false;
        throwErrorIfConnectionClosed(context.namespace);
        this._context = context;
    }
    /**
     * @property {boolean} [isClosed] Denotes if close() was called on this sender.
     * @readonly
     */
    get isClosed() {
        return this._isClosed;
    }
    /**
     * Sends the given message after creating an AMQP Sender link if it doesnt already exists.
     *
     * To send a message to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`
     * and/or `partitionKey` properties respectively on the message.
     *
     * @param message - Message to send.
     * @returns Promise<void>
     */
    send(message$$1) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfSenderOrConnectionClosed();
            const sender$$1 = MessageSender.create(this._context);
            return sender$$1.send(message$$1);
        });
    }
    /**
     * Sends the given messages in a batch i.e. in a single AMQP message after creating an AMQP Sender
     * link if it doesnt already exists.
     *
     * To send messages to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`
     * and/or `partitionKey` properties respectively on the messages. When doing so, all
     * messages in the batch should have the same `sessionId` (if using sessions) and the same
     * `parititionKey` (if using paritions).
     *
     * @param messages - An array of SendableMessageInfo objects to be sent in a Batch message.
     * @return Promise<void>
     */
    sendBatch(messages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfSenderOrConnectionClosed();
            const sender$$1 = MessageSender.create(this._context);
            return sender$$1.sendBatch(messages);
        });
    }
    /**
     * Schedules given message to appear on Service Bus Queue/Subscription at a later time.
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the message should be enqueued.
     * @param message - The message that needs to be scheduled.
     * @returns Promise<Long> - The sequence number of the message that was scheduled.
     * You will need the sequence number if you intend to cancel the scheduling of the message.
     * Save the `Long` type as-is in your application without converting to number. Since JavaScript
     * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.
     */
    scheduleMessage(scheduledEnqueueTimeUtc, message$$1) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfSenderOrConnectionClosed();
            const scheduleMessages = [
                { message: message$$1, scheduledEnqueueTimeUtc: scheduledEnqueueTimeUtc }
            ];
            const result = yield this._context.managementClient.scheduleMessages(scheduleMessages);
            return result[0];
        });
    }
    /**
     * Schedules given messages to appear on Service Bus Queue/Subscription at a later time.
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
     * @param messages - Array of Messages that need to be scheduled.
     * @returns Promise<Long[]> - The sequence numbers of messages that were scheduled.
     * You will need the sequence number if you intend to cancel the scheduling of the messages.
     * Save the `Long` type as-is in your application without converting to number. Since JavaScript
     * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.
     */
    scheduleMessages(scheduledEnqueueTimeUtc, messages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfSenderOrConnectionClosed();
            const scheduleMessages = messages.map((message$$1) => {
                return {
                    message: message$$1,
                    scheduledEnqueueTimeUtc
                };
            });
            return this._context.managementClient.scheduleMessages(scheduleMessages);
        });
    }
    /**
     * Cancels a message that was scheduled to appear on a ServiceBus Queue/Subscription.
     * @param sequenceNumber - The sequence number of the message to be cancelled.
     * @returns Promise<void>
     */
    cancelScheduledMessage(sequenceNumber) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfSenderOrConnectionClosed();
            return this._context.managementClient.cancelScheduledMessages([sequenceNumber]);
        });
    }
    /**
     * Cancels an array of messages that were scheduled to appear on a ServiceBus Queue/Subscription.
     * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.
     * @returns Promise<void>
     */
    cancelScheduledMessages(sequenceNumbers) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfSenderOrConnectionClosed();
            return this._context.managementClient.cancelScheduledMessages(sequenceNumbers);
        });
    }
    /**
     * Closes the underlying AMQP sender link.
     * Once closed, the sender cannot be used for any further operations.
     * Use the `getSender` function on the QueueClient or TopicClient to instantiate a new Sender
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.namespace.connection &&
                    this._context.namespace.connection.isOpen() &&
                    this._context.sender) {
                    yield this._context.sender.close();
                }
                this._isClosed = true;
            }
            catch (err) {
                const msg = `An error occurred while closing the sender for` +
                    `"${this._context.entityPath}": ${JSON.stringify(err)} `;
                error(msg);
                throw new Error(msg);
            }
        });
    }
    throwIfSenderOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (this._isClosed) {
            throw new Error("The sender has been closed and can no longer be used.");
        }
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 */
var ReceiverType;
(function (ReceiverType) {
    ReceiverType["batching"] = "batching";
    ReceiverType["streaming"] = "streaming";
})(ReceiverType || (ReceiverType = {}));
/**
 * @internal
 * Describes the MessageReceiver that will receive messages from ServiceBus.
 * @class MessageReceiver
 */
class MessageReceiver extends LinkEntity {
    constructor(context, receiverType, options) {
        super(context.entityPath, context, {
            address: context.entityPath,
            audience: `${context.namespace.config.endpoint}${context.entityPath}`
        });
        /**
         * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
         * processed concurrently while in streaming mode. Once this limit has been reached, more
         * messages will not be received until the user's message handler has completed processing current message.
         * Default: 1
         */
        this.maxConcurrentCalls = 1;
        /**
         * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */
        this._deliveryDispositionMap = new Map();
        /**
         * @property {Map<string, Function>} _messageRenewLockTimers Maintains a map of messages for which
         * the lock is automatically renewed.
         * @protected
         */
        this._messageRenewLockTimers = new Map();
        if (!options)
            options = {};
        this.receiverType = receiverType;
        this.receiveMode = options.receiveMode || ReceiveMode.peekLock;
        if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) {
            this.maxConcurrentCalls = options.maxConcurrentCalls;
        }
        this.newMessageWaitTimeoutInSeconds = options.newMessageWaitTimeoutInSeconds;
        this.resetTimerOnNewMessageReceived = () => {
            /** */
        };
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete = options.autoComplete === false ? options.autoComplete : true;
        this.maxAutoRenewDurationInSeconds =
            options.maxMessageAutoRenewLockDurationInSeconds != undefined
                ? options.maxMessageAutoRenewLockDurationInSeconds
                : 300;
        this.autoRenewLock =
            this.maxAutoRenewDurationInSeconds > 0 && this.receiveMode === ReceiveMode.peekLock;
        this._clearMessageLockRenewTimer = (messageId) => {
            if (this._messageRenewLockTimers.has(messageId)) {
                clearTimeout(this._messageRenewLockTimers.get(messageId));
                receiver("[%s] Cleared the message renew lock timer for message with id '%s'.", this._context.namespace.connectionId, messageId);
                this._messageRenewLockTimers.delete(messageId);
            }
        };
        this._clearAllMessageLockRenewTimers = () => {
            receiver("[%s] Clearing message renew lock timers for all the active messages.", this._context.namespace.connectionId);
            for (const messageId of this._messageRenewLockTimers.keys()) {
                this._clearMessageLockRenewTimer(messageId);
            }
        };
        // setting all the handlers
        this._onSettled = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const delivery = context.delivery;
            if (delivery) {
                const id = delivery.id;
                const state = delivery.remote_state;
                const settled = delivery.remote_settled;
                receiver("[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been " + "received.", connectionId, id, settled, state && state.error ? state.error : state);
                if (settled && this._deliveryDispositionMap.has(id)) {
                    const promise = this._deliveryDispositionMap.get(id);
                    clearTimeout(promise.timer);
                    receiver("[%s] Found the delivery with id %d in the map and cleared the timer.", connectionId, id);
                    const deleteResult = this._deliveryDispositionMap.delete(id);
                    receiver("[%s] Successfully deleted the delivery with id %d from the map.", connectionId, id, deleteResult);
                    if (state && state.error && (state.error.condition || state.error.description)) {
                        const error$$1 = amqpCommon.translate(state.error);
                        return promise.reject(error$$1);
                    }
                    return promise.resolve();
                }
            }
        };
        this._onAmqpMessage = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If the receiver got closed in PeekLock mode, avoid processing the message as we
            // cannot settle the message.
            if (this.receiveMode === ReceiveMode.peekLock &&
                (!this._receiver || !this._receiver.isOpen())) {
                error("[%s] Not calling the user's message handler for the current message " +
                    "as the receiver '%s' is closed", this._context.namespace.connectionId, this.name);
                return;
            }
            this.resetTimerOnNewMessageReceived();
            const connectionId = this._context.namespace.connectionId;
            const bMessage = new ServiceBusMessage(this._context, context.message, context.delivery);
            if (this.autoRenewLock) {
                // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.
                // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInSeconds
                // - We should be able to clear the renewal timer when the user's message handler
                // is done (whether it succeeds or fails).
                // Setting the messageId with undefined value in the _messageRenewockTimers Map because we
                // track state by checking the presence of messageId in the map. It is removed from the map
                // when an attempt is made to settle the message (either by the user or by the sdk) OR
                // when the execution of user's message handler completes.
                this._messageRenewLockTimers.set(bMessage.messageId, undefined);
                receiver("[%s] message with id '%s' is locked until %s.", connectionId, bMessage.messageId, bMessage.lockedUntilUtc.toString());
                const totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
                receiver("[%s] Total autolockrenew duration for message with id '%s' is: ", connectionId, bMessage.messageId, new Date(totalAutoLockRenewDuration).toString());
                const autoRenewLockTask = () => {
                    if (new Date(totalAutoLockRenewDuration) > bMessage.lockedUntilUtc &&
                        Date.now() < totalAutoLockRenewDuration) {
                        if (this._messageRenewLockTimers.has(bMessage.messageId)) {
                            // TODO: We can run into problems with clock skew between the client and the server.
                            // It would be better to calculate the duration based on the "lockDuration" property
                            // of the queue. However, we do not have the management plane of the client ready for
                            // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.
                            const amount = calculateRenewAfterDuration(bMessage.lockedUntilUtc);
                            receiver("[%s] Sleeping for %d milliseconds while renewing the lock for " +
                                "message with id '%s' is: ", connectionId, amount, bMessage.messageId);
                            // Setting the value of the messageId to the actual timer. This will be cleared when
                            // an attempt is made to settle the message (either by the user or by the sdk) OR
                            // when the execution of user's message handler completes.
                            this._messageRenewLockTimers.set(bMessage.messageId, setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                                try {
                                    receiver("[%s] Attempting to renew the lock for message with id '%s'.", connectionId, bMessage.messageId);
                                    yield this._context.managementClient.renewLock(bMessage);
                                    receiver("[%s] Successfully renewed the lock for message with id '%s'.", connectionId, bMessage.messageId);
                                    receiver("[%s] Calling the autorenewlock task again for message with " + "id '%s'.", connectionId, bMessage.messageId);
                                    autoRenewLockTask();
                                }
                                catch (err) {
                                    error("[%s] An error occured while auto renewing the message lock '%s' " +
                                        "for message with id '%s': %O.", connectionId, bMessage.lockToken, bMessage.messageId, err);
                                    // Let the user know that there was an error renewing the message lock.
                                    this._onError(err);
                                }
                            }), amount));
                        }
                        else {
                            receiver("[%s] Looks like the message lock renew timer has already been " +
                                "cleared for message with id '%s'.", connectionId, bMessage.messageId);
                        }
                    }
                    else {
                        receiver("[%s] Current time %s exceeds the total autolockrenew duration %s for " +
                            "message with messageId '%s'. Hence we will stop the autoLockRenewTask.", connectionId, new Date(Date.now()).toString(), new Date(totalAutoLockRenewDuration).toString(), bMessage.messageId);
                        this._clearMessageLockRenewTimer(bMessage.messageId);
                    }
                };
                // start
                autoRenewLockTask();
            }
            try {
                yield this._onMessage(bMessage);
                this._clearMessageLockRenewTimer(bMessage.messageId);
            }
            catch (err) {
                // This ensures we call users' error handler when users' message handler throws.
                if (!rheaPromise.isAmqpError(err)) {
                    error("[%s] An error occurred while running user's message handler for the message " +
                        "with id '%s' on the receiver '%s': %O", connectionId, bMessage.messageId, this.name, err);
                    this._onError(err);
                }
                // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,
                // doing this here. Otherwise, this should be done in finally.
                this._clearMessageLockRenewTimer(bMessage.messageId);
                const error$$1 = amqpCommon.translate(err);
                // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                if (!bMessage.delivery.remote_settled &&
                    error$$1.name !== amqpCommon.ConditionErrorNameMapper["com.microsoft:message-lock-lost"] &&
                    this.receiveMode === ReceiveMode.peekLock &&
                    this.isOpen() // only try to abandon the messages if the connection is still open
                ) {
                    try {
                        error("[%s] Abandoning the message with id '%s' on the receiver '%s' since " +
                            "an error occured: %O.", connectionId, bMessage.messageId, this.name, error$$1);
                        yield bMessage.abandon();
                    }
                    catch (abandonError) {
                        const translatedError = amqpCommon.translate(abandonError);
                        error("[%s] An error occurred while abandoning the message with id '%s' on the " +
                            "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                        this._onError(translatedError);
                    }
                }
                return;
            }
            finally {
                if (this._receiver) {
                    this._receiver.addCredit(1);
                }
            }
            // If we've made it this far, then user's message handler completed fine. Let us try
            // completing the message.
            if (this.autoComplete &&
                this.receiveMode === ReceiveMode.peekLock &&
                !bMessage.delivery.remote_settled) {
                try {
                    log$1[this.receiverType]("[%s] Auto completing the message with id '%s' on " + "the receiver '%s'.", connectionId, bMessage.messageId, this.name);
                    yield bMessage.complete();
                }
                catch (completeError) {
                    const translatedError = amqpCommon.translate(completeError);
                    error("[%s] An error occurred while completing the message with id '%s' on the " +
                        "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                    this._onError(translatedError);
                }
            }
        });
        this._onAmqpError = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const receiver$$1 = this._receiver || context.receiver;
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = amqpCommon.translate(receiverError);
                error("[%s] An error occurred for Receiver '%s': %O.", connectionId, this.name, sbError);
                if (!sbError.retryable) {
                    if (receiver$$1 && !receiver$$1.isItselfClosed()) {
                        error("[%s] Since the user did not close the receiver and the error is not " +
                            "retryable, we let the user know about it by calling the user's error handler.", connectionId);
                        this._onError(sbError);
                    }
                    else {
                        error("[%s] The received error is not retryable. However, the receiver was " +
                            "closed by the user. Hence not notifying the user's error handler.", connectionId);
                    }
                }
                else {
                    error("[%s] Since received error is retryable, we will NOT notify the user's " +
                        "error handler.", connectionId);
                }
            }
            if (this._newMessageReceivedTimer) {
                clearTimeout(this._newMessageReceivedTimer);
            }
        };
        this._onSessionError = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const receiver$$1 = this._receiver || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = amqpCommon.translate(sessionError);
                error("[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);
                if (receiver$$1 && !receiver$$1.isSessionItselfClosed() && !sbError.retryable) {
                    error("[%s] Since the user did not close the receiver and the session error is not " +
                        "retryable, we let the user know about it by calling the user's error handler.", connectionId);
                    this._onError(sbError);
                }
            }
            if (this._newMessageReceivedTimer) {
                clearTimeout(this._newMessageReceivedTimer);
            }
        };
        this._onAmqpClose = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            const receiver$$1 = this._receiver || context.receiver;
            if (receiverError) {
                error("[%s] 'receiver_close' event occurred for receiver '%s' with address '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.address, receiverError);
            }
            this._clearAllMessageLockRenewTimers();
            if (receiver$$1 && !receiver$$1.isItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                        "and the sdk did not initiate this. The receiver is not reconnecting. Hence, calling " +
                        "detached from the _onAmqpClose() handler.", connectionId, this.name, this.address);
                    yield this.detached(receiverError);
                }
                else {
                    error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                        "and the sdk did not initate this. Moreover the receiver is already re-connecting. " +
                        "Hence not calling detached from the _onAmqpClose() handler.", connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", connectionId, this.name, this.address);
            }
        });
        this._onSessionClose = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const receiver$$1 = this._receiver || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                error("[%s] 'session_close' event occurred for receiver '%s' with address '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.address, sessionError);
            }
            this._clearAllMessageLockRenewTimers();
            if (receiver$$1 && !receiver$$1.isSessionItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                        "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                        "_onSessionClose() handler.", connectionId, this.name, this.address);
                    yield this.detached(sessionError);
                }
                else {
                    error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                        "address '%s' and the sdk did not initiate this. Moreover the receiver is already " +
                        "re-connecting. Hence not calling detached from the _onSessionClose() handler.", connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'session_close' event occurred on the session of receiver '%s' with address " +
                    "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                    "() handler.", connectionId, this.name, this.address);
            }
        });
    }
    /**
     * Will reconnect the receiver link if necessary.
     * @param {AmqpError | Error} [receiverError] The receiver error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    detached(receiverError) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            try {
                const wasCloseInitiated = this._receiver && this._receiver.isItselfClosed();
                // Clears the token renewal timer. Closes the link and its session if they are open.
                // Removes the link and its session if they are present in rhea's cache.
                yield this._closeLink(this._receiver);
                if (this.receiverType === ReceiverType.batching) {
                    error("[%s] Receiver '%s' with address '%s' is a Batching Receiver, so we will not be " +
                        "re-establishing the receiver link.", connectionId, this.name, this.address);
                    return;
                }
                // We should attempt to reopen only when the receiver(sdk) did not initiate the close
                let shouldReopen = false;
                if (receiverError && !wasCloseInitiated) {
                    const translatedError = amqpCommon.translate(receiverError);
                    if (translatedError.retryable) {
                        shouldReopen = true;
                        error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is retryable. This is a candidate for re-establishing " +
                            "the receiver link.", connectionId, this.name, this.address);
                    }
                    else {
                        error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                            "the receiver link.", connectionId, this.name, this.address);
                    }
                }
                else if (!wasCloseInitiated) {
                    shouldReopen = true;
                    error("[%s] close() method of Receiver '%s' with address '%s' was not called. " +
                        "There was no accompanying error as well. This is a candidate for re-establishing " +
                        "the receiver link.", connectionId, this.name, this.address);
                }
                else {
                    const state = {
                        wasCloseInitiated: wasCloseInitiated,
                        receiverError: receiverError,
                        _receiver: this._receiver
                    };
                    error("[%s] Something is busted. State of Receiver '%s' with address '%s' is: %O", connectionId, this.name, this.address, state);
                }
                if (shouldReopen) {
                    // provide a new name to the link while re-connecting it. This ensures that
                    // the service does not send an error stating that the link is still open.
                    const options = this._createReceiverOptions(true);
                    // shall retry forever at an interval of 15 seconds if the error is a retryable error
                    // else bail out when the error is not retryable or the oepration succeeds.
                    const config = {
                        operation: () => this._init(options),
                        connectionId: connectionId,
                        operationType: amqpCommon.RetryOperationType.receiverLink,
                        times: amqpCommon.Constants.defaultConnectionRetryAttempts,
                        delayInSeconds: 15
                    };
                    yield amqpCommon.retry(config);
                }
            }
            catch (err) {
                error("[%s] An error occurred while processing detached() of Receiver '%s': %O ", connectionId, this.name, this.address, err);
            }
        });
    }
    /**
     * Closes the underlying AMQP receiver.
     * @return {Promise<void>} Promise<void>.
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            receiver("[%s] Closing the [%s]Receiver for entity '%s'.", this._context.namespace.connectionId, this.receiverType, this._context.entityPath);
            if (this._newMessageReceivedTimer)
                clearTimeout(this._newMessageReceivedTimer);
            if (this._receiver) {
                const receiverLink = this._receiver;
                this._deleteFromCache();
                yield this._closeLink(receiverLink);
            }
        });
    }
    /**
     * Settles the message with the specified disposition.
     * @param message The ServiceBus Message that needs to be settled.
     * @param operation The disposition type.
     * @param options Optional parameters that can be provided while disposing the message.
     */
    settleMessage(message$$1, operation, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (!options)
                    options = {};
                if (operation.match(/^(complete|abandon|defer|deadletter)$/) == undefined) {
                    return reject(new Error(`operation: '${operation}' is not a valid operation.`));
                }
                this._clearMessageLockRenewTimer(message$$1.messageId);
                const delivery = message$$1.delivery;
                const timer = setTimeout(() => {
                    this._deliveryDispositionMap.delete(delivery.id);
                    receiver("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                        "Hence resolving the promise.", this._context.namespace.connectionId, delivery.id, messageDispositionTimeout);
                    return resolve();
                }, messageDispositionTimeout);
                this._deliveryDispositionMap.set(delivery.id, {
                    resolve: resolve,
                    reject: reject,
                    timer: timer
                });
                if (operation === DispositionType.complete) {
                    delivery.accept();
                }
                else if (operation === DispositionType.abandon) {
                    const params = {
                        undeliverable_here: false
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.defer) {
                    const params = {
                        undeliverable_here: true
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.deadletter) {
                    delivery.reject(options.error || {});
                }
            });
        });
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this._receiver && this._receiver.isOpen();
        error("[%s] Receiver '%s' with address '%s' is open? -> %s", this._context.namespace.connectionId, this.name, this.address, result);
        return result;
    }
    _deleteFromCache() {
        this._receiver = undefined;
        if (this.receiverType === ReceiverType.streaming) {
            this._context.streamingReceiver = undefined;
        }
        else if (this.receiverType === ReceiverType.batching) {
            this._context.batchingReceiver = undefined;
        }
        error("[%s] Deleted the receiver '%s' from the client cache.", this._context.namespace.connectionId, this.name);
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     * @protected
     *
     * @returns {Promise<void>} Promise<void>.
     */
    _init(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            try {
                if (!this.isOpen() && !this.isConnecting) {
                    error("[%s] The receiver '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", connectionId, this.name, this.address);
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    if (!options) {
                        options = this._createReceiverOptions();
                    }
                    error("[%s] Trying to create receiver '%s' with options %O", connectionId, this.name, options);
                    this._receiver = yield this._context.namespace.connection.createReceiver(options);
                    this.isConnecting = false;
                    error("[%s] Receiver '%s' with address '%s' has established itself.", connectionId, this.name, this.address);
                    log$1[this.receiverType]("Promise to create the receiver resolved. " + "Created receiver with name: ", this.name);
                    log$1[this.receiverType]("[%s] Receiver '%s' created with receiver options: %O", connectionId, this.name, options);
                    // It is possible for someone to close the receiver and then start it again.
                    // Thus make sure that the receiver is present in the client cache.
                    if (this.receiverType === ReceiverType.streaming && !this._context.streamingReceiver) {
                        this._context.streamingReceiver = this;
                    }
                    else if (this.receiverType === ReceiverType.batching && !this._context.batchingReceiver) {
                        this._context.batchingReceiver = this;
                    }
                    yield this._ensureTokenRenewal();
                }
                else {
                    error("[%s] The receiver '%s' with address '%s' is open -> %s and is connecting " +
                        "-> %s. Hence not reconnecting.", connectionId, this.name, this.address, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                err = amqpCommon.translate(err);
                error("[%s] An error occured while creating the receiver '%s': %O", this._context.namespace.connectionId, this.name, err);
                throw err;
            }
        });
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */
    _createReceiverOptions(useNewName, options) {
        if (!options) {
            options = {
                onMessage: (context) => this._onAmqpMessage(context).catch(() => {
                    /* */
                }),
                onClose: (context) => this._onAmqpClose(context).catch(() => {
                    /* */
                }),
                onSessionClose: (context) => this._onSessionClose(context).catch(() => {
                    /* */
                }),
                onError: this._onAmqpError,
                onSessionError: this._onSessionError,
                onSettled: this._onSettled
            };
        }
        const rcvrOptions = Object.assign({ name: useNewName ? getUniqueName(this._context.entityPath) : this.name, autoaccept: this.receiveMode === ReceiveMode.receiveAndDelete ? true : false, 
            // receiveAndDelete -> first(0), peekLock -> second (1)
            rcv_settle_mode: this.receiveMode === ReceiveMode.receiveAndDelete ? 0 : 1, 
            // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
            snd_settle_mode: this.receiveMode === ReceiveMode.receiveAndDelete ? 1 : 0, source: {
                address: this.address
            }, credit_window: 0 }, options);
        return rcvrOptions;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Describes the streaming receiver where the user can receive the message
 * by providing handler functions.
 * @class StreamingReceiver
 * @extends MessageReceiver
 */
class StreamingReceiver extends MessageReceiver {
    /**
     * Instantiate a new Streaming receiver for receiving messages with handlers.
     *
     * @constructor
     * @param {ClientEntityContext} context                      The client entity context.
     * @param {ReceiveOptions} [options]                         Options for how you'd like to connect.
     */
    constructor(context, options) {
        super(context, ReceiverType.streaming, options);
        this.resetTimerOnNewMessageReceived = () => {
            if (this._newMessageReceivedTimer)
                clearTimeout(this._newMessageReceivedTimer);
            if (this.newMessageWaitTimeoutInSeconds) {
                this._newMessageReceivedTimer = setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const msg = `StreamingReceiver '${this.name}' did not receive any messages in ` +
                        `the last ${this.newMessageWaitTimeoutInSeconds} seconds. ` +
                        `Hence ending this receive operation.`;
                    error("[%s] %s", this._context.namespace.connectionId, msg);
                    yield this.close();
                }), this.newMessageWaitTimeoutInSeconds * 1000);
            }
        };
    }
    /**
     * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.
     *
     * @param {OnMessage} onMessage The message handler to receive servicebus messages.
     * @param {OnError} onError The error handler to receive an error that occurs while receivin messages.
     */
    receive(onMessage, onError) {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (!onMessage || typeof onMessage !== "function") {
            throw new Error("'onMessage' is a required parameter and must be of type 'function'.");
        }
        if (!onError || typeof onError !== "function") {
            throw new Error("'onError' is a required parameter and must be of type 'function'.");
        }
        this._onMessage = onMessage;
        this._onError = onError;
        if (this.isOpen()) {
            const msg = `A streaming receiver with id "${this.name}" is active for ` +
                `"${this._context.entityPath}". A new receive() call cannot be made at this time. ` +
                `Either wait for current receiver to complete or create a new receiver.`;
            throw new Error(msg);
        }
        this._init()
            .then(() => {
            if (this._receiver) {
                this._receiver.addCredit(this.maxConcurrentCalls);
            }
        })
            .catch((err) => {
            this._onError(err);
        });
    }
    /**
     * Creates a streaming receiver.
     * @static
     *
     * @param {ClientEntityContext} context    The connection context.
     * @param {ReceiveOptions} [options]     Receive options.
     * @return {StreamingReceiver} An instance of StreamingReceiver.
     */
    static create(context, options) {
        throwErrorIfConnectionClosed(context.namespace);
        if (!options)
            options = {};
        if (options.autoComplete == undefined)
            options.autoComplete = true;
        const sReceiver = new StreamingReceiver(context, options);
        context.streamingReceiver = sReceiver;
        return sReceiver;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the batching receiver where the user can receive a specified number of messages for
 * a predefined time.
 * @internal
 * @class BatchingReceiver
 * @extends MessageReceiver
 */
class BatchingReceiver extends MessageReceiver {
    /**
     * Instantiate a new BatchingReceiver.
     *
     * @constructor
     * @param {ClientEntityContext} context The client entity context.
     * @param {ReceiveOptions} [options]  Options for how you'd like to connect.
     */
    constructor(context, options) {
        super(context, ReceiverType.batching, options);
        /**
         * @property {boolean} isReceivingMessages Indicates whether the link is actively receiving
         * messages. Default: false.
         */
        this.isReceivingMessages = false;
    }
    /**
     * Receives a batch of messages from a ServiceBus Queue/Topic.
     * @param maxMessageCount      The maximum number of messages to receive.
     * @param idleTimeoutInSeconds The maximum wait time in seconds for which the Receiver
     * should wait to receive the first message. If no message is received by this time,
     * the returned promise gets resolved to an empty array.
     * @returns {Promise<ServiceBusMessage[]>} A promise that resolves with an array of Message objects.
     */
    receive(maxMessageCount, idleTimeoutInSeconds) {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (!maxMessageCount || (maxMessageCount && typeof maxMessageCount !== "number")) {
            throw new Error("'maxMessageCount' is a required parameter of type number with a value " + "greater than 0.");
        }
        if (idleTimeoutInSeconds == undefined) {
            idleTimeoutInSeconds = amqpCommon.Constants.defaultOperationTimeoutInSeconds;
        }
        const brokeredMessages = [];
        this.isReceivingMessages = true;
        return new Promise((resolve, reject) => {
            let onReceiveMessage;
            let onSessionClose;
            let onReceiveClose;
            let onReceiveDrain;
            let onReceiveError;
            let onSessionError;
            let firstMessageWaitTimer;
            // Final action to be performed after maxMessageCount is reached or the maxWaitTime is over.
            const finalAction = () => {
                if (this._newMessageReceivedTimer) {
                    clearTimeout(this._newMessageReceivedTimer);
                }
                if (firstMessageWaitTimer) {
                    clearTimeout(firstMessageWaitTimer);
                }
                // Removing listeners, so that the next receiveBatch() call can set them again.
                if (this._receiver) {
                    this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                    this._receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                    this._receiver.session.removeListener(rheaPromise.SessionEvents.sessionError, onSessionError);
                }
                if (this._receiver && this._receiver.credit > 0) {
                    batching("[%s] Receiver '%s': Draining leftover credits(%d).", this._context.namespace.connectionId, this.name, this._receiver.credit);
                    // Setting drain must be accompanied by a flow call (aliased to addCredit in this case).
                    this._receiver.drain = true;
                    this._receiver.addCredit(1);
                }
                else {
                    if (this._receiver) {
                        this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    }
                    this.isReceivingMessages = false;
                    batching("[%s] Receiver '%s': Resolving receiveBatch() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                    resolve(brokeredMessages);
                }
            };
            /**
             * Resets the timer when a new message is received. If no messages were received for
             * `newMessageWaitTimeoutInSeconds`, the messages received till now are returned. The
             * receiver link stays open for the next receive call, but doesnt receive messages until then
             */
            this.resetTimerOnNewMessageReceived = () => {
                if (this._newMessageReceivedTimer)
                    clearTimeout(this._newMessageReceivedTimer);
                if (this.newMessageWaitTimeoutInSeconds) {
                    this._newMessageReceivedTimer = setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const msg = `BatchingReceiver '${this.name}' did not receive any messages in the last ` +
                            `${this.newMessageWaitTimeoutInSeconds} seconds. ` +
                            `Hence ending this batch receive operation.`;
                        error("[%s] %s", this._context.namespace.connectionId, msg);
                        finalAction();
                    }), this.newMessageWaitTimeoutInSeconds * 1000);
                }
            };
            // Action to be performed after the max wait time is over.
            const actionAfterWaitTimeout = () => {
                batching("[%s] Batching Receiver '%s'  max wait time in seconds %d over.", this._context.namespace.connectionId, this.name, idleTimeoutInSeconds);
                return finalAction();
            };
            // Action to be performed on the "receiver_drained" event.
            onReceiveDrain = (context) => {
                this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                this._receiver.drain = false;
                this.isReceivingMessages = false;
                batching("[%s] Receiver '%s' drained. Resolving receiveBatch() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                resolve(brokeredMessages);
            };
            // Action to be performed on the "message" event.
            onReceiveMessage = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (firstMessageWaitTimer) {
                    clearTimeout(firstMessageWaitTimer);
                    firstMessageWaitTimer = undefined;
                }
                this.resetTimerOnNewMessageReceived();
                try {
                    const data = new ServiceBusMessage(this._context, context.message, context.delivery);
                    if (brokeredMessages.length < maxMessageCount) {
                        brokeredMessages.push(data);
                    }
                }
                catch (err) {
                    reject(`Error while converting AmqpMessage to ReceivedSBMessage: ${err}`);
                }
                if (brokeredMessages.length === maxMessageCount) {
                    finalAction();
                }
            });
            // Action to be taken when an error is received.
            onReceiveError = (context) => {
                this.isReceivingMessages = false;
                const receiver$$1 = this._receiver || context.receiver;
                receiver$$1.removeListener(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                receiver$$1.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                receiver$$1.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                receiver$$1.session.removeListener(rheaPromise.SessionEvents.sessionError, onSessionError);
                const receiverError = context.receiver && context.receiver.error;
                let error$$1 = new amqpCommon.MessagingError("An error occuured while receiving messages.");
                if (receiverError) {
                    error$$1 = amqpCommon.translate(receiverError);
                    error("[%s] Receiver '%s' received an error:\n%O", this._context.namespace.connectionId, this.name, error$$1);
                }
                if (firstMessageWaitTimer) {
                    clearTimeout(firstMessageWaitTimer);
                }
                if (this._newMessageReceivedTimer) {
                    clearTimeout(this._newMessageReceivedTimer);
                }
                reject(error$$1);
            };
            onReceiveClose = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    this.isReceivingMessages = false;
                    const receiverError = context.receiver && context.receiver.error;
                    if (receiverError) {
                        error("[%s] 'receiver_close' event occurred. The associated error is: %O", this._context.namespace.connectionId, receiverError);
                    }
                }
                catch (err) {
                    error("[%s] Receiver '%s' error in onClose handler:\n%O", this._context.namespace.connectionId, this.name, amqpCommon.translate(err));
                }
            });
            onSessionClose = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    this.isReceivingMessages = false;
                    const sessionError = context.session && context.session.error;
                    if (sessionError) {
                        error("[%s] 'session_close' event occurred for receiver '%s'. The associated error is: %O", this._context.namespace.connectionId, this.name, sessionError);
                    }
                }
                catch (err) {
                    error("[%s] Receiver '%s' error in onSessionClose handler:\n%O", this._context.namespace.connectionId, this.name, amqpCommon.translate(err));
                }
            });
            onSessionError = (context) => {
                this.isReceivingMessages = false;
                const receiver$$1 = this._receiver || context.receiver;
                receiver$$1.removeListener(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                receiver$$1.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                receiver$$1.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                receiver$$1.session.removeListener(rheaPromise.SessionEvents.sessionError, onSessionError);
                const sessionError = context.session && context.session.error;
                let error$$1 = new amqpCommon.MessagingError("An error occuured while receiving messages.");
                if (sessionError) {
                    error$$1 = amqpCommon.translate(sessionError);
                    error("[%s] 'session_close' event occurred for Receiver '%s' received an error:\n%O", this._context.namespace.connectionId, this.name, error$$1);
                }
                if (firstMessageWaitTimer) {
                    clearTimeout(firstMessageWaitTimer);
                }
                if (this._newMessageReceivedTimer) {
                    clearTimeout(this._newMessageReceivedTimer);
                }
                reject(error$$1);
            };
            const onSettled = (context) => {
                const connectionId = this._context.namespace.connectionId;
                const delivery = context.delivery;
                if (delivery) {
                    const id = delivery.id;
                    const state = delivery.remote_state;
                    const settled = delivery.remote_settled;
                    receiver("[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been " +
                        "received.", connectionId, id, settled, state && state.error ? state.error : state);
                    if (settled && this._deliveryDispositionMap.has(id)) {
                        const promise = this._deliveryDispositionMap.get(id);
                        clearTimeout(promise.timer);
                        receiver("[%s] Found the delivery with id %d in the map and cleared the timer.", connectionId, id);
                        const deleteResult = this._deliveryDispositionMap.delete(id);
                        receiver("[%s] Successfully deleted the delivery with id %d from the map.", connectionId, id, deleteResult);
                        if (state && state.error && (state.error.condition || state.error.description)) {
                            const error$$1 = amqpCommon.translate(state.error);
                            return promise.reject(error$$1);
                        }
                        return promise.resolve();
                    }
                }
            };
            const addCreditAndSetTimer = (reuse) => {
                batching("[%s] Receiver '%s', adding credit for receiving %d messages.", this._context.namespace.connectionId, this.name, maxMessageCount);
                // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
                // number of messages concurrently. We will return the user an array of messages that can
                // be of size upto maxMessageCount. Then the user needs to accordingly dispose
                // (complete,/abandon/defer/deadletter) the messages from the array.
                this._receiver.addCredit(maxMessageCount);
                let msg = "[%s] Setting the wait timer for %d seconds for receiver '%s'.";
                if (reuse)
                    msg += " Receiver link already present, hence reusing it.";
                batching(msg, this._context.namespace.connectionId, idleTimeoutInSeconds, this.name);
                firstMessageWaitTimer = setTimeout(actionAfterWaitTimeout, idleTimeoutInSeconds * 1000);
                // TODO: Disabling this for now. We would want to give the user a decent chance to receive
                // the first message and only timeout faster if successive messages from there onwards are
                // not received quickly. However, it may be possible that there are no pending messages
                // currently on the queue. In that case waiting for idleTimeoutInSeconds would be
                // unnecessary.
                // There is a management plane API to get runtimeInfo of the Queue which provides
                // information about active messages on the Queue and it's sub Queues. However, this adds
                // a little complexity. If the first message was delayed due to network latency then there
                // are bright chances that the management plane api would receive the same fate.
                // It would be better to weigh all the options before making a decision.
                // resetTimerOnNewMessageReceived();
            };
            if (!this.isOpen()) {
                batching("[%s] Receiver '%s', setting max concurrent calls to 0.", this._context.namespace.connectionId, this.name);
                // while creating the receiver link for batching receiver the max concurrent calls
                // i.e. the credit_window on the link is set to zero. After the link is created
                // successfully, we add credit which is the maxMessageCount specified by the user.
                this.maxConcurrentCalls = 0;
                const rcvrOptions = this._createReceiverOptions(false, {
                    onMessage: onReceiveMessage,
                    onError: onReceiveError,
                    onSessionError: onSessionError,
                    onSettled: onSettled,
                    onClose: onReceiveClose,
                    onSessionClose: onSessionClose
                });
                this._init(rcvrOptions)
                    .then(() => {
                    this._receiver.on(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    addCreditAndSetTimer();
                })
                    .catch(reject);
            }
            else {
                addCreditAndSetTimer(true);
                this._receiver.on(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                this._receiver.on(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                this._receiver.on(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                this._receiver.session.on(rheaPromise.SessionEvents.sessionError, onSessionError);
            }
        });
    }
    /**
     * Creates a batching receiver.
     * @static
     *
     * @param {ClientEntityContext} context    The connection context.
     * @param {ReceiveOptions} [options]     Receive options.
     */
    static create(context, options) {
        throwErrorIfConnectionClosed(context.namespace);
        const bReceiver = new BatchingReceiver(context, options);
        context.batchingReceiver = bReceiver;
        return bReceiver;
    }
}

/**
 * The Receiver class can be used to receive messages in a batch or by registering handlers.
 * Use the `getReceiver` function on the QueueClient or SubscriptionClient to instantiate a Receiver.
 * The Receiver class is an abstraction over the underlying AMQP receiver link.
 * @class Receiver
 */
class Receiver {
    /**
     * @internal
     */
    constructor(context, options) {
        this._isClosed = false;
        throwErrorIfConnectionClosed(context.namespace);
        this._context = context;
        if (!options) {
            options = {};
        }
        this._receiveMode =
            options.receiveMode === undefined ? ReceiveMode.peekLock : options.receiveMode;
    }
    /**
     * @property {boolean} [isClosed] Denotes if close() was called on this receiver.
     * @readonly
     */
    get isClosed() {
        return this._isClosed;
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the Receiver or set the property
     * `newMessageWaitTimeoutInSeconds` in the options to provide a timeout.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control if messages should be automatically completed, and/or have
     * their locks automatically renewed. You can control the maximum number of messages that should
     * be concurrently processed. You can also provide a timeout in seconds to denote the
     * amount of time to wait for a new message before closing the receiver.
     *
     * @returns void
     */
    receive(onMessage, onError, options) {
        this.throwIfReceiverOrConnectionClosed();
        this.validateNewReceiveCall(ReceiverType.streaming);
        const sReceiver = StreamingReceiver.create(this._context, Object.assign({}, options, { receiveMode: this._receiveMode }));
        this._context.streamingReceiver = sReceiver;
        return sReceiver.receive(onMessage, onError);
    }
    /**
     * Returns a batch of messages based on given count and timeout over an AMQP receiver link
     * from a Queue/Subscription.
     *
     * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
     * @param idleTimeoutInSeconds The maximum wait time in seconds for which the Receiver
     * should wait to receive the first message. If no message is received by this time,
     * the returned promise gets resolved to an empty array.
     * - **Default**: `60` seconds.
     * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
     */
    receiveBatch(maxMessageCount, idleTimeoutInSeconds) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            this.validateNewReceiveCall(ReceiverType.batching);
            if (!this._context.batchingReceiver || !this._context.batchingReceiver.isOpen()) {
                const options = {
                    maxConcurrentCalls: 0,
                    receiveMode: this._receiveMode,
                    newMessageWaitTimeoutInSeconds: 1
                };
                this._context.batchingReceiver = BatchingReceiver.create(this._context, options);
            }
            try {
                return yield this._context.batchingReceiver.receive(maxMessageCount, idleTimeoutInSeconds);
            }
            catch (err) {
                error("[%s] Receiver '%s', an error occurred while receiving %d messages for %d " +
                    "max time:\n %O", this._context.namespace.connectionId, this._context.batchingReceiver.name, maxMessageCount, idleTimeoutInSeconds, err);
                throw err;
            }
        });
    }
    /**
     * Renews the lock on the message.
     *
     * When a message is received in `PeekLock` mode, the message is locked on the server for this
     * receiver instance for a duration as specified during the Queue/Subscription creation
     * (LockDuration). If processing of the message requires longer than this duration, the
     * lock needs to be renewed. For each renewal, it resets the time the message is locked by the
     * LockDuration set on the Entity.
     *
     * @param lockTokenOrMessage - Lock token of the message or the message itself.
     * @returns Promise<Date> - New lock token expiry date and time in UTC format.
     */
    renewLock(lockTokenOrMessage) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            if (this._receiveMode !== ReceiveMode.peekLock) {
                throw new Error("The operation is only supported in 'PeekLock' receive mode.");
            }
            return this._context.managementClient.renewLock(lockTokenOrMessage);
        });
    }
    /**
     * Receives a deferred message identified by the given `sequenceNumber`.
     * @param sequenceNumber The sequence number of the message that will be received.
     * @returns Promise<ServiceBusMessage | undefined>
     * - Returns `Message` identified by sequence number.
     * - Returns `undefined` if no such message is found.
     * - Throws an error if the message has not been deferred.
     */
    receiveDeferredMessage(sequenceNumber) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            if (this._receiveMode !== ReceiveMode.peekLock) {
                throw new Error("The operation is only supported in 'PeekLock' receive mode.");
            }
            return this._context.managementClient.receiveDeferredMessage(sequenceNumber, this._receiveMode);
        });
    }
    /**
     * Receives a list of deferred messages identified by given `sequenceNumbers`.
     * @param sequenceNumbers A list containing the sequence numbers to receive.
     * @returns Promise<ServiceBusMessage[]>
     * - Returns a list of messages identified by the given sequenceNumbers.
     * - Returns an empty list if no messages are found.
     * - Throws an error if the messages have not been deferred.
     */
    receiveDeferredMessages(sequenceNumbers) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            if (this._receiveMode !== ReceiveMode.peekLock) {
                throw new Error("The operation is only supported in 'PeekLock' receive mode.");
            }
            return this._context.managementClient.receiveDeferredMessages(sequenceNumbers, this._receiveMode);
        });
    }
    /**
     * Closes the underlying AMQP receiver link.
     * Once closed, the receiver cannot be used for any further operations.
     * Use the `getReceiver` function on the QueueClient or SubscriptionClient to instantiate
     * a new Receiver
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.namespace.connection && this._context.namespace.connection.isOpen()) {
                    // Close the streaming receiver.
                    if (this._context.streamingReceiver) {
                        yield this._context.streamingReceiver.close();
                    }
                    // Close the batching receiver.
                    if (this._context.batchingReceiver) {
                        yield this._context.batchingReceiver.close();
                    }
                    // Make sure that we clear the map of deferred messages
                    this._context.requestResponseLockedMessages.clear();
                }
                this._isClosed = true;
            }
            catch (err) {
                const msg = `An error occurred while closing the receiver for` +
                    `"${this._context.entityPath}": ${JSON.stringify(err)} `;
                error(msg);
                throw new Error(msg);
            }
        });
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this return true, a new receive() or receiveBatch() call cannot be made.
     */
    isReceivingMessages() {
        if (this._context.streamingReceiver && this._context.streamingReceiver.isOpen()) {
            return true;
        }
        if (this._context.batchingReceiver &&
            this._context.batchingReceiver.isOpen() &&
            this._context.batchingReceiver.isReceivingMessages) {
            return true;
        }
        return false;
    }
    validateNewReceiveCall(newCallType) {
        let currentlyActiveReceiver = "";
        let currentlyActiveReceiverType = "";
        if (this._context.streamingReceiver && this._context.streamingReceiver.isOpen()) {
            currentlyActiveReceiver = this._context.streamingReceiver.name;
            currentlyActiveReceiverType = "streaming";
        }
        else if (this._context.batchingReceiver &&
            this._context.batchingReceiver.isOpen() &&
            this._context.batchingReceiver.isReceivingMessages) {
            currentlyActiveReceiver = this._context.batchingReceiver.name;
            currentlyActiveReceiverType = "batching";
        }
        if (currentlyActiveReceiverType && currentlyActiveReceiver) {
            const msg = `A "${currentlyActiveReceiverType}" receiver with id ` +
                `"${currentlyActiveReceiver}" is active for "${this._context.entityPath}". ` +
                `A ${newCallType === ReceiverType.streaming ? "new receive" : "receiveBatch"}() call ` +
                `cannot be made at this time. Either wait for current receiver to complete or create a new receiver.`;
            throw new Error(msg);
        }
    }
    throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (this.isClosed) {
            throw new Error("The receiver has been closed and can no longer be used.");
        }
    }
}
/**
 * The SessionReceiver class can be used to receive messages from a session enabled Queue or
 * Subscription in a batch or by registering handlers.
 * Use the `getSessionReceiver` function on the QueueClient or SubscriptionClient to instantiate a
 * SessionReceiver.
 * The SessionReceiver class is an abstraction over the underlying AMQP receiver link.
 * @class SessionReceiver
 */
class SessionReceiver {
    /**
     * @property {boolean} [isClosed] Denotes if close() was called on this receiver.
     * @readonly
     */
    get isClosed() {
        return !this._context.messageSessions[this.sessionId];
    }
    /**
     * @property {string} [sessionId] The sessionId for the message session.
     * @readonly
     */
    get sessionId() {
        return this._sessionId || "";
    }
    /**
     * @property {Date} [sessionLockedUntilUtc] The time in UTC until which the session is locked.
     * @readonly
     */
    get sessionLockedUntilUtc() {
        return this._messageSession.sessionLockedUntilUtc;
    }
    /**
     * @internal
     */
    constructor(context, messageSession$$1) {
        throwErrorIfConnectionClosed(context.namespace);
        this._context = context;
        this._receiveMode = messageSession$$1.receiveMode;
        this._sessionId = messageSession$$1.sessionId;
        this._messageSession = messageSession$$1;
    }
    /**
     * Renews the lock for the Session.
     * @returns Promise<Date> New lock token expiry date and time in UTC format.
     */
    renewLock() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            this._messageSession.sessionLockedUntilUtc = yield this._context.managementClient.renewSessionLock(this.sessionId);
            return this._messageSession.sessionLockedUntilUtc;
        });
    }
    /**
     * Sets the state of the MessageSession.
     * @param state The state that needs to be set.
     */
    setState(state) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            return this._context.managementClient.setSessionState(this.sessionId, state);
        });
    }
    /**
     * Gets the state of the MessageSession.
     * @returns Promise<any> The state of that session
     */
    getState() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            return this._context.managementClient.getSessionState(this.sessionId);
        });
    }
    /**
     * Fetches the next batch of active messages (including deferred but not deadlettered messages) in
     * the current session. The first call to `peek()` fetches the first active message. Each
     * subsequent call fetches the subsequent message.
     *
     * Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param messageCount The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     */
    peek(messageCount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            return this._context.managementClient.peekMessagesBySession(this.sessionId, messageCount);
        });
    }
    /**
     * Peeks the desired number of active messages (including deferred but not deadlettered messages)
     * from the specified sequence number in the current session.
     *
     * Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param [messageCount] The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     */
    peekBySequenceNumber(fromSequenceNumber, messageCount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            return this._context.managementClient.peekBySequenceNumber(fromSequenceNumber, {
                sessionId: this.sessionId,
                messageCount: messageCount
            });
        });
    }
    /**
     * Receives a deferred message identified by the given `sequenceNumber`.
     * @param sequenceNumber The sequence number of the message that will be received.
     * @returns Promise<ServiceBusMessage | undefined>
     * - Returns `Message` identified by sequence number.
     * - Returns `undefined` if no such message is found.
     * - Throws an error if the message has not been deferred.
     */
    receiveDeferredMessage(sequenceNumber) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            if (this._receiveMode !== ReceiveMode.peekLock) {
                throw new Error("The operation is only supported in 'PeekLock' receive mode.");
            }
            return this._context.managementClient.receiveDeferredMessage(sequenceNumber, this._receiveMode, this.sessionId);
        });
    }
    /**
     * Receives a list of deferred messages identified by given `sequenceNumbers`.
     * @param sequenceNumbers A list containing the sequence numbers to receive.
     * @returns Promise<ServiceBusMessage[]>
     * - Returns a list of messages identified by the given sequenceNumbers.
     * - Returns an empty list if no messages are found.
     * - Throws an error if the messages have not been deferred.
     */
    receiveDeferredMessages(sequenceNumbers) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            if (this._receiveMode !== ReceiveMode.peekLock) {
                throw new Error("The operation is only supported in 'PeekLock' receive mode.");
            }
            return this._context.managementClient.receiveDeferredMessages(sequenceNumbers, this._receiveMode, this.sessionId);
        });
    }
    /**
     * Returns a batch of messages based on given count and timeout over an AMQP receiver link
     * from a Queue/Subscription.
     *
     * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
     * @param maxWaitTimeInSeconds The maximum wait time in seconds for which the Receiver
     * should wait to receive the first message. If no message is received by this time,
     * the returned promise gets resolved to an empty array.
     * - **Default**: `60` seconds.
     * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
     */
    receiveBatch(maxMessageCount, maxWaitTimeInSeconds) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwIfReceiverOrConnectionClosed();
            try {
                return yield this._messageSession.receiveBatch(maxMessageCount, maxWaitTimeInSeconds);
            }
            catch (err) {
                error("[%s] Receiver '%s', an error occurred while receiving %d messages for %d " +
                    "max time:\n %O", this._context.namespace.connectionId, this._messageSession.name, maxMessageCount, maxWaitTimeInSeconds, err);
                throw err;
            }
        });
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver or set the property
     * `newMessageWaitTimeoutInSeconds` in the options to provide a timeout.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed
     * or if the lock on the session should be automatically renewed. You can control the
     * maximum number of messages that should be concurrently processed. You can
     * also provide a timeout in seconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     *
     * @returns void
     */
    receive(onMessage, onError, options) {
        this.throwIfReceiverOrConnectionClosed();
        return this._messageSession.receive(onMessage, onError, options);
    }
    /**
     * Closes the underlying AMQP receiver link.
     * Once closed, the receiver cannot be used for any further operations.
     * Use the `getSessionReceiver` function on the QueueClient or SubscriptionClient to instantiate
     * a new Receiver
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this._messageSession.close();
            }
            catch (err) {
                error("[%s] An error occurred while closing the message session with id '%s': %O.", this._context.namespace.connectionId, this.sessionId, err);
                throw err;
            }
        });
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this return true, a new receive() or receiveBatch() call cannot be made on the receiver.
     */
    isReceivingMessages() {
        return this._messageSession.isReceivingMessages;
    }
    throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (this.isClosed) {
            throw new Error("The receiver has been closed and can no longer be used.");
        }
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
const validCorrelationProperties = [
    "correlationId",
    "messageId",
    "to",
    "replyTo",
    "label",
    "sessionId",
    "replyToSessionId",
    "contentType",
    "userProperties"
];
/**
 * @internal
 * @class ManagementClient
 * Descibes the ServiceBus Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
class ManagementClient extends LinkEntity {
    /**
     * @constructor
     * Instantiates the management client.
     * @param {ClientEntityContext} context The client entity context.
     * @param {ManagementClientOptions} [options] Options to be provided for creating the
     * "$management" client.
     */
    constructor(context, options) {
        super(`${context.entityPath}/$management`, context, {
            address: options && options.address ? options.address : amqpCommon.Constants.management,
            audience: options && options.audience
                ? options.audience
                : `${context.namespace.config.endpoint}${context.entityPath}/$management`
        });
        this.managementLock = `${amqpCommon.Constants.managementRequestKey}-${rheaPromise.generate_uuid()}`;
        /**
         * @property {string} replyTo The reply to Guid for the management client.
         */
        this.replyTo = rheaPromise.generate_uuid();
        /**
         * @property _lastPeekedSequenceNumber Provides the sequence number of the last peeked message.
         * @private
         */
        this._lastPeekedSequenceNumber = Long.ZERO;
        this._context = context;
        this.entityPath = context.namespace.config.entityPath;
    }
    /**
     * Closes the AMQP management session to the ServiceBus namespace for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @return Promise<void>
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._isMgmtRequestResponseLinkOpen()) {
                    const mgmtLink = this._mgmtReqResLink;
                    this._mgmtReqResLink = undefined;
                    clearTimeout(this._tokenRenewalTimer);
                    yield mgmtLink.close();
                    mgmt("Successfully closed the management session.");
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the management session: ${err}`;
                error(msg);
                throw new Error(msg);
            }
        });
    }
    /**
     * Fetches the next batch of active messages. The first call to `peek()` fetches the first
     * active message for this client. Each subsequent call fetches the subsequent message in the
     * entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. Also, unlike
     * `receive() | receiveBatch()` this method will fetch even Deferred messages
     * (but not Deadlettered message).
     * @param {number} [messageCount] The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     */
    peek(messageCount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), {
                messageCount: messageCount
            });
        });
    }
    /**
     * Fetches the next batch of active messages in the current MessageSession. The first call to
     * `peek()` fetches the first active message for this client. Each subsequent call fetches the
     * subsequent message in the entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. Also, unlike
     * `receive() | receiveBatch()` this method will also fetch `Deferred` messages, but
     * **NOT** `Deadlettered` messages.
     * @param {string} sessionId The sessionId from which messages need to be peeked.
     * @param {number} [messageCount] The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     */
    peekMessagesBySession(sessionId, messageCount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (sessionId == undefined) {
                throw new Error("'sessionId' is a required parameter and must be of type 'string'.");
            }
            return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), {
                sessionId: sessionId,
                messageCount: messageCount
            });
        });
    }
    /**
     * Peeks the desired number of messages from the specified sequence number.
     * @param {Long} fromSequenceNumber The sequence number from where to read the message.
     * @param {PeekOptions} [options] Options that can be provided while peeking messages.
     * @returns Promise<ReceivedMessageInfo[]>
     */
    peekBySequenceNumber(fromSequenceNumber, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!options)
                options = {};
            if (fromSequenceNumber == undefined || !Long.isLong(fromSequenceNumber)) {
                throw new Error("'fromSequenceNumber' is a required parameter and must be an instance of 'Long'.");
            }
            if (options.messageCount != undefined && typeof options.messageCount !== "number") {
                throw new Error("'messageCount' must be of type 'number'.");
            }
            if (options.sessionId != undefined && typeof options.sessionId !== "string") {
                throw new Error("'sessionId' must be of type 'string'.");
            }
            if (options.messageCount == undefined)
                options.messageCount = 1;
            const messageList = [];
            try {
                const messageBody = {};
                messageBody[amqpCommon.Constants.fromSequenceNumber] = rheaPromise.types.wrap_long(Buffer.from(fromSequenceNumber.toBytesBE()));
                messageBody[amqpCommon.Constants.messageCount] = rheaPromise.types.wrap_int(options.messageCount);
                if (options.sessionId) {
                    messageBody[amqpCommon.Constants.sessionIdMapKey] = options.sessionId;
                }
                const request = {
                    body: messageBody,
                    message_id: rheaPromise.generate_uuid(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.peekMessage
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Peek by sequence number request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request);
                if (result.application_properties.statusCode !== 204) {
                    const messages = result.body.messages;
                    for (const msg of messages) {
                        const decodedMessage = rheaPromise.message.decode(msg.message);
                        const message$$1 = ReceivedMessageInfo.fromAmqpMessage(decodedMessage);
                        message$$1.body = this._context.namespace.dataTransformer.decode(message$$1.body);
                        messageList.push(message$$1);
                        this._lastPeekedSequenceNumber = message$$1.sequenceNumber;
                    }
                }
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the request to peek messages to " +
                    "$management endpoint: %O", error$$1);
                // statusCode == 404 then do not throw
                if (error$$1.name !== amqpCommon.ConditionErrorNameMapper["com.microsoft:message-not-found"]) {
                    throw error$$1;
                }
            }
            return messageList;
        });
    }
    /**
     * Renews the lock on the message. The lock will be renewed based on the setting specified on
     * the queue.
     *
     * When a message is received in `PeekLock` mode, the message is locked on the server for this
     * receiver instance for a duration as specified during the Queue/Subscription creation
     * (LockDuration). If processing of the message requires longer than this duration, the
     * lock needs to be renewed. For each renewal, it resets the time the message is locked by the
     * LockDuration set on the Entity.
     *
     * @param {string | ServiceBusMessage} lockTokenOrMessage Lock token of the message or
     * the message itself.
     * @param {SendRequestOptions} [options] Options that can be set while sending the request.
     * @returns {Promise<Date>} Promise<Date> New lock token expiry date and time in UTC format.
     */
    renewLock(lockTokenOrMessage, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!lockTokenOrMessage) {
                throw new Error("'lockTokenOrMessage' is a required parameter.");
            }
            if (typeof lockTokenOrMessage !== "object" && typeof lockTokenOrMessage !== "string") {
                throw new Error("'lockTokenOrMessage must be of type 'string' or of type 'object'.");
            }
            if (!options)
                options = {};
            if (options.delayInSeconds == undefined)
                options.delayInSeconds = 1;
            if (options.timeoutInSeconds == undefined)
                options.timeoutInSeconds = 5;
            if (options.times == undefined)
                options.times = 5;
            const lockToken = lockTokenOrMessage.lockToken
                ? lockTokenOrMessage.lockToken
                : lockTokenOrMessage;
            try {
                const messageBody = {};
                messageBody[amqpCommon.Constants.lockTokens] = rheaPromise.types.wrap_array([rheaPromise.string_to_uuid(lockToken)], 0x98, undefined);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.renewLock
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Renew message Lock request: %O.", this._context.namespace.connectionId, request);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request, options);
                const lockedUntilUtc = new Date(result.body.expirations[0]);
                if (typeof lockTokenOrMessage === "object") {
                    lockTokenOrMessage.lockedUntilUtc = lockedUntilUtc;
                }
                return lockedUntilUtc;
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Schedules an array of messages to appear on Service Bus at a later time.
     *
     * @param messages - An array of messages that needs to be scheduled.
     * @returns Promise<number> The sequence numbers of messages that were scheduled.
     */
    scheduleMessages(messages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!Array.isArray(messages)) {
                throw new Error("'messages' is a required parameter of type 'Array'.");
            }
            const messageBody = [];
            for (let i = 0; i < messages.length; i++) {
                const item = messages[i];
                if (typeof item.message !== "object") {
                    throw new Error("'message' is a required property and must be of type 'object'.");
                }
                if (!(item.scheduledEnqueueTimeUtc instanceof Date)) {
                    throw new Error("'scheduledEnqueueTimeUtc' is a required property and must be of type 'Date'.");
                }
                const now = Date.now();
                const enqueueTimeInMs = item.scheduledEnqueueTimeUtc.getTime();
                if (enqueueTimeInMs < now) {
                    throw new Error(`Cannot schedule messages in the past. Given scheduledEnqueueTimeUtc` +
                        `(${enqueueTimeInMs}) < current time (${now}).`);
                }
                item.message.scheduledEnqueueTimeUtc = item.scheduledEnqueueTimeUtc;
                if (!item.message.messageId)
                    item.message.messageId = rheaPromise.generate_uuid();
                SendableMessageInfo.validate(item.message);
                const amqpMessage = SendableMessageInfo.toAmqpMessage(item.message);
                try {
                    const entry = {
                        message: rheaPromise.message.encode(amqpMessage),
                        "message-id": item.message.messageId
                    };
                    if (item.message.sessionId) {
                        entry[amqpCommon.Constants.sessionIdMapKey] = item.message.sessionId;
                    }
                    if (item.message.partitionKey) {
                        entry["partition-key"] = item.message.partitionKey;
                    }
                    if (item.message.viaPartitionKey) {
                        entry["via-partition-key"] = item.message.viaPartitionKey;
                    }
                    const wrappedEntry = rheaPromise.types.wrap_map(entry);
                    messageBody.push(wrappedEntry);
                }
                catch (err) {
                    const error$$1 = amqpCommon.translate(err);
                    error("An error occurred while encoding the item at position %d in the messages array" + ": %O", i, error$$1);
                    throw error$$1;
                }
            }
            try {
                const request = {
                    body: { messages: messageBody },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.scheduleMessage
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Schedule messages request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request);
                const sequenceNumbers = result.body[amqpCommon.Constants.sequenceNumbers];
                const sequenceNumbersAsLong = [];
                for (let i = 0; i < sequenceNumbers.length; i++) {
                    if (typeof sequenceNumbers[i] === "number") {
                        sequenceNumbersAsLong.push(Long.fromNumber(sequenceNumbers[i]));
                    }
                    else {
                        sequenceNumbersAsLong.push(Long.fromBytesBE(sequenceNumbers[i]));
                    }
                }
                return sequenceNumbersAsLong;
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the request to schedule messages to " +
                    "$management endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Cancels an array of messages that were scheduled.
     * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.
     * @returns Promise<void>
     */
    cancelScheduledMessages(sequenceNumbers) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!Array.isArray(sequenceNumbers)) {
                throw new Error("'sequenceNumbers' is a required parameter of type 'Array'.");
            }
            const messageBody = {};
            messageBody[amqpCommon.Constants.sequenceNumbers] = [];
            for (let i = 0; i < sequenceNumbers.length; i++) {
                const sequenceNumber = sequenceNumbers[i];
                if (!Long.isLong(sequenceNumber)) {
                    throw new Error("An item in the 'sequenceNumbers' Array must be an instance of 'Long'.");
                }
                try {
                    messageBody[amqpCommon.Constants.sequenceNumbers].push(Buffer.from(sequenceNumber.toBytesBE()));
                }
                catch (err) {
                    const error$$1 = amqpCommon.translate(err);
                    error("An error occurred while encoding the item at position %d in the " +
                        "sequenceNumbers array: %O", i, error$$1);
                    throw error$$1;
                }
            }
            try {
                messageBody[amqpCommon.Constants.sequenceNumbers] = rheaPromise.types.wrap_array(messageBody[amqpCommon.Constants.sequenceNumbers], 0x81, undefined);
                const request = {
                    body: messageBody,
                    message_id: rheaPromise.generate_uuid(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.cancelScheduledMessage
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Cancel scheduled messages request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                yield this._mgmtReqResLink.sendRequest(request);
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the request to cancel the scheduled message to " +
                    "$management endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Receives a specific deferred message identified by `sequenceNumber` of the `Message`.
     * @param sequenceNumber The sequence number of the message that will be received.
     * @param receiveMode The mode in which the receiver was created.
     * @returns Promise<ServiceBusMessage | undefined>
     * - Returns `ServiceBusMessage` identified by sequence number.
     * - Returns `undefined` if no such message is found.
     * - Throws an error if the message has not been deferred.
     */
    receiveDeferredMessage(sequenceNumber, receiveMode, sessionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!Long.isLong(sequenceNumber)) {
                throw new Error("'sequenceNumber' is a required parameter and must be an instance of 'Long'.");
            }
            let message$$1 = undefined;
            const messages = yield this.receiveDeferredMessages([sequenceNumber], receiveMode, sessionId);
            if (messages.length) {
                message$$1 = messages[0];
            }
            return message$$1;
        });
    }
    /**
     * Receives a list of deferred messages identified by `sequenceNumbers`.
     * @param sequenceNumbers A list containing the sequence numbers to receive.
     * @param receiveMode The mode in which the receiver was created.
     * @returns Promise<ServiceBusMessage[]>
     * - Returns a list of messages identified by the given sequenceNumbers.
     * - Returns an empty list if no messages are found.
     * - Throws an error if the messages have not been deferred.
     */
    receiveDeferredMessages(sequenceNumbers, receiveMode, sessionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!Array.isArray(sequenceNumbers)) {
                throw new Error("'sequenceNumbers' is a required parameter and must be of type 'Array'.");
            }
            if (typeof receiveMode !== "number") {
                throw new Error("'receiveMode' is a required parameter with value 1 or 2.");
            }
            if (sessionId && typeof sessionId !== "string") {
                throw new Error("'sessionId' must be of type 'string'.");
            }
            const messageList = [];
            const messageBody = {};
            messageBody[amqpCommon.Constants.sequenceNumbers] = [];
            for (let i = 0; i < sequenceNumbers.length; i++) {
                const sequenceNumber = sequenceNumbers[i];
                if (!Long.isLong(sequenceNumber)) {
                    throw new Error("An item in the 'sequenceNumbers' Array must be an instance of 'Long'.");
                }
                try {
                    messageBody[amqpCommon.Constants.sequenceNumbers].push(Buffer.from(sequenceNumber.toBytesBE()));
                }
                catch (err) {
                    const error$$1 = amqpCommon.translate(err);
                    error("An error occurred while encoding the item at position %d in the " +
                        "sequenceNumbers array: %O", i, error$$1);
                    throw error$$1;
                }
            }
            try {
                messageBody[amqpCommon.Constants.sequenceNumbers] = rheaPromise.types.wrap_array(messageBody[amqpCommon.Constants.sequenceNumbers], 0x81, undefined);
                const receiverSettleMode = receiveMode === ReceiveMode.receiveAndDelete ? 0 : 1;
                messageBody[amqpCommon.Constants.receiverSettleMode] = rheaPromise.types.wrap_uint(receiverSettleMode);
                if (sessionId != undefined) {
                    messageBody[amqpCommon.Constants.sessionIdMapKey] = sessionId;
                }
                const request = {
                    body: messageBody,
                    message_id: rheaPromise.generate_uuid(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.receiveBySequenceNumber
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Receive deferred messages request bosy: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request);
                const messages = result.body.messages;
                for (const msg of messages) {
                    const decodedMessage = rheaPromise.message.decode(msg.message);
                    const message$$1 = new ServiceBusMessage(this._context, decodedMessage, { tag: msg["lock-token"] });
                    this._context.requestResponseLockedMessages.set(message$$1.lockToken, message$$1.lockedUntilUtc);
                    messageList.push(message$$1);
                }
                return messageList;
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the request to receive deferred messages to " +
                    "$management endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Updates the disposition status of deferred messages.
     *
     * @param lockTokens Message lock tokens to update disposition status.
     * @param dispositionStatus The disposition status to be set
     * @param options Optional parameters that can be provided while updating the disposition status.
     *
     * @returns Promise<void>
     */
    updateDispositionStatus(lockTokens, dispositionStatus, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!Array.isArray(lockTokens)) {
                throw new Error("'lockTokens' is a required parameter and must be of type 'Array'.");
            }
            if (!dispositionStatus || typeof dispositionStatus !== "string") {
                throw new Error("'dispositionStatus' is a required parameter and must be of type 'string'.");
            }
            if (!options)
                options = {};
            try {
                const messageBody = {};
                const lockTokenBuffer = [];
                for (const lockToken of lockTokens) {
                    lockTokenBuffer.push(rheaPromise.string_to_uuid(lockToken));
                }
                messageBody[amqpCommon.Constants.lockTokens] = rheaPromise.types.wrap_array(lockTokenBuffer, 0x98, undefined);
                messageBody[amqpCommon.Constants.dispositionStatus] = dispositionStatus;
                if (options.deadLetterDescription != undefined) {
                    messageBody[amqpCommon.Constants.deadLetterDescription] = options.deadLetterDescription;
                }
                if (options.deadLetterReason != undefined) {
                    messageBody[amqpCommon.Constants.deadLetterReason] = options.deadLetterReason;
                }
                if (options.propertiesToModify != undefined) {
                    messageBody[amqpCommon.Constants.propertiesToModify] = options.propertiesToModify;
                }
                if (options.sessionId != undefined) {
                    messageBody[amqpCommon.Constants.sessionIdMapKey] = options.sessionId;
                }
                const request = {
                    body: messageBody,
                    message_id: rheaPromise.generate_uuid(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.updateDisposition
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Update disposition status request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                yield this._mgmtReqResLink.sendRequest(request);
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the request to update disposition status to " +
                    "$management endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Renews the lock for the specified session.
     * @param sessionId Id of the session for which the lock needs to be renewed
     * @param options Options that can be set while sending the request.
     * @returns Promise<Date> New lock token expiry date and time in UTC format.
     */
    renewSessionLock(sessionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (typeof sessionId !== "string") {
                throw new Error("'sessionId' is a required parameter and must be of type 'string'.");
            }
            if (!options)
                options = {};
            if (options.delayInSeconds == undefined)
                options.delayInSeconds = 1;
            if (options.timeoutInSeconds == undefined)
                options.timeoutInSeconds = 5;
            if (options.times == undefined)
                options.times = 5;
            try {
                const messageBody = {};
                messageBody[amqpCommon.Constants.sessionIdMapKey] = sessionId;
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.renewSessionLock
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Renew Session Lock request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request, options);
                const lockedUntilUtc = new Date(result.body.expiration);
                mgmt("[%s] Lock for session '%s' will expire at %s.", this._context.namespace.connectionId, sessionId, lockedUntilUtc.toString());
                return lockedUntilUtc;
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Sets the state of the specified session.
     * @param sessionId The session for which the state needs to be set
     * @param state The state that needs to be set.
     * @returns Promise<void>
     */
    setSessionState(sessionId, state) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (typeof sessionId !== "string") {
                throw new Error("'sessionId' is a required parameter and must be of type 'string'.");
            }
            try {
                const messageBody = {};
                messageBody[amqpCommon.Constants.sessionIdMapKey] = sessionId;
                messageBody["session-state"] = toBuffer(state);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.setSessionState
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Set Session state request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                yield this._mgmtReqResLink.sendRequest(request);
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Gets the state of the specified session.
     * @param sessionId The session for which the state needs to be retrieved.
     * @returns Promise<any> The state of that session
     */
    getSessionState(sessionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (typeof sessionId !== "string") {
                throw new Error("'sessionId' is a required parameter and must be of type 'string'.");
            }
            try {
                const messageBody = {};
                messageBody[amqpCommon.Constants.sessionIdMapKey] = sessionId;
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.getSessionState
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Get session state request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request);
                return result.body["session-state"]
                    ? this._context.namespace.dataTransformer.decode(result.body["session-state"])
                    : result.body["session-state"];
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Lists the sessions on the ServiceBus Queue/Topic.
     * @param lastUpdateTime Filter to include only sessions updated after a given time.
     * @param skip The number of sessions to skip
     * @param top Maximum numer of sessions.
     * @returns Promise<string[]> A list of session ids.
     */
    listMessageSessions(skip, top, lastUpdatedTime) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            const defaultLastUpdatedTimeForListingSessions = 259200000; // 3 * 24 * 3600 * 1000
            if (typeof skip !== "number") {
                throw new Error("'skip' is a required parameter and must be of type 'number'.");
            }
            if (typeof top !== "number") {
                throw new Error("'top' is a required parameter and must be of type 'number'.");
            }
            if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) {
                throw new Error("'lastUpdatedTime' must be of type 'Date'.");
            }
            if (!lastUpdatedTime) {
                lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);
            }
            try {
                const messageBody = {};
                messageBody["last-updated-time"] = lastUpdatedTime;
                messageBody["skip"] = rheaPromise.types.wrap_int(skip);
                messageBody["top"] = rheaPromise.types.wrap_int(top);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.enumerateSessions
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] List sessions request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const response = yield this._mgmtReqResLink.sendRequest(request);
                return (response && response.body && response.body["sessions-ids"]) || [];
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Get all the rules on the Subscription.
     * @returns Promise<RuleDescription[]> A list of rules.
     */
    getRules() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            try {
                const request = {
                    body: {
                        top: rheaPromise.types.wrap_int(max32BitNumber),
                        skip: rheaPromise.types.wrap_int(0)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.enumerateRules
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Get rules request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const response = yield this._mgmtReqResLink.sendRequest(request);
                if (response.application_properties.statusCode === 204 ||
                    !response.body ||
                    !Array.isArray(response.body.rules)) {
                    return [];
                }
                // Reference: https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-amqp-request-response#response-11
                const result = response.body.rules || [];
                const rules = [];
                result.forEach((x) => {
                    const ruleDescriptor = x["rule-description"];
                    // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name
                    if (!ruleDescriptor ||
                        !ruleDescriptor.descriptor ||
                        ruleDescriptor.descriptor.value !== amqpCommon.Constants.descriptorCodes.ruleDescriptionList ||
                        !Array.isArray(ruleDescriptor.value) ||
                        ruleDescriptor.value.length < 3) {
                        return;
                    }
                    const filtersRawData = ruleDescriptor.value[0];
                    const actionsRawData = ruleDescriptor.value[1];
                    const rule = {
                        name: ruleDescriptor.value[2].value
                    };
                    switch (filtersRawData.descriptor.value) {
                        case amqpCommon.Constants.descriptorCodes.trueFilterList:
                            rule.filter = {
                                expression: "1=1"
                            };
                            break;
                        case amqpCommon.Constants.descriptorCodes.falseFilterList:
                            rule.filter = {
                                expression: "1=0"
                            };
                            break;
                        case amqpCommon.Constants.descriptorCodes.sqlFilterList:
                            rule.filter = {
                                expression: this._safelyGetTypedValueFromArray(filtersRawData.value, 0)
                            };
                            break;
                        case amqpCommon.Constants.descriptorCodes.correlationFilterList:
                            rule.filter = {
                                correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),
                                messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),
                                to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),
                                replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),
                                label: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),
                                sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),
                                replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),
                                contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),
                                userProperties: this._safelyGetTypedValueFromArray(filtersRawData.value, 8)
                            };
                            break;
                        default:
                            mgmt(`Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`);
                            break;
                    }
                    if (actionsRawData.descriptor.value === amqpCommon.Constants.descriptorCodes.sqlRuleActionList &&
                        Array.isArray(actionsRawData.value) &&
                        actionsRawData.value.length) {
                        rule.action = {
                            expression: this._safelyGetTypedValueFromArray(actionsRawData.value, 0)
                        };
                    }
                    rules.push(rule);
                });
                return rules;
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the get rules request to $management " + "endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Removes the rule on the Subscription identified by the given rule name.
     * @param ruleName
     */
    removeRule(ruleName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!ruleName || typeof ruleName !== "string") {
                throw new Error("Cannot remove rule. Rule name is missing or is not a string.");
            }
            try {
                const request = {
                    body: {
                        "rule-name": rheaPromise.types.wrap_string(ruleName)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.removeRule
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Remove Rule request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                yield this._mgmtReqResLink.sendRequest(request);
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the remove rule request to $management " + "endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    /**
     * Adds a rule on the subscription as defined by the given rule name, filter and action
     * @param ruleName Name of the rule
     * @param filter A Boolean, SQL expression or a Correlation filter
     * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression
     */
    addRule(ruleName, filter, sqlRuleActionExpression) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!ruleName || typeof ruleName !== "string") {
                throw new Error("Cannot add rule. Rule name is missing or is not a string.");
            }
            if (!filter && filter !== false) {
                throw new Error("Cannot add rule. Filter is missing.");
            }
            if (typeof filter !== "boolean" && typeof filter !== "string") {
                const filterProperties = Object.keys(filter);
                if (!filterProperties.length) {
                    throw new Error("Cannot add rule. Filter should be either a boolean, string or should have one of the Correlation filter properties.");
                }
                for (let i = 0; i < filterProperties.length; i++) {
                    const filterProperty = filterProperties[i];
                    if (validCorrelationProperties.indexOf(filterProperty) === -1) {
                        throw new Error(`Cannot add rule. Given filter object has unexpected property "${filterProperty}".`);
                    }
                }
            }
            if (sqlRuleActionExpression && typeof sqlRuleActionExpression !== "string") {
                throw new Error("Cannot add rule. Given action expression is not a string.");
            }
            try {
                const ruleDescription = {};
                switch (typeof filter) {
                    case "boolean":
                        ruleDescription["sql-filter"] = {
                            expression: filter ? "1=1" : "1=0"
                        };
                        break;
                    case "string":
                        ruleDescription["sql-filter"] = {
                            expression: filter
                        };
                        break;
                    default:
                        ruleDescription["correlation-filter"] = {
                            "correlation-id": filter.correlationId,
                            "message-id": filter.messageId,
                            to: filter.to,
                            "reply-to": filter.replyTo,
                            label: filter.label,
                            "session-id": filter.sessionId,
                            "reply-to-session-id": filter.replyToSessionId,
                            "content-type": filter.contentType,
                            properties: filter.userProperties
                        };
                        break;
                }
                if (sqlRuleActionExpression && typeof sqlRuleActionExpression === "string") {
                    ruleDescription["sql-rule-action"] = {
                        expression: sqlRuleActionExpression
                    };
                }
                const request = {
                    body: {
                        "rule-name": rheaPromise.types.wrap_string(ruleName),
                        "rule-description": rheaPromise.types.wrap_map(ruleDescription)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.addRule
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Add Rule request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                yield this._mgmtReqResLink.sendRequest(request);
            }
            catch (err) {
                const error$$1 = amqpCommon.translate(err);
                error("An error occurred while sending the Add rule request to $management " + "endpoint: %O", error$$1);
                throw error$$1;
            }
        });
    }
    _init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            try {
                if (!this._isMgmtRequestResponseLinkOpen()) {
                    yield this._negotiateClaim();
                    const rxopt = {
                        source: { address: this.address },
                        name: this.replyTo,
                        target: { address: this.replyTo },
                        onSessionError: (context) => {
                            const id = context.connection.options.id;
                            const ehError = amqpCommon.translate(context.session.error);
                            error("[%s] An error occurred on the session for request/response links for " +
                                "$management: %O", id, ehError);
                        }
                    };
                    const sropt = { target: { address: this.address } };
                    mgmt("[%s] Creating sender/receiver links on a session for $management endpoint with " +
                        "srOpts: %o, receiverOpts: %O.", this._context.namespace.connectionId, sropt, rxopt);
                    this._mgmtReqResLink = yield amqpCommon.RequestResponseLink.create(this._context.namespace.connection, sropt, rxopt);
                    this._mgmtReqResLink.sender.on(rheaPromise.SenderEvents.senderError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = amqpCommon.translate(context.sender.error);
                        error("[%s] An error occurred on the $management sender link.. %O", id, ehError);
                    });
                    this._mgmtReqResLink.receiver.on(rheaPromise.ReceiverEvents.receiverError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = amqpCommon.translate(context.receiver.error);
                        error("[%s] An error occurred on the $management receiver link.. %O", id, ehError);
                    });
                    mgmt("[%s] Created sender '%s' and receiver '%s' links for $management endpoint.", this._context.namespace.connectionId, this._mgmtReqResLink.sender.name, this._mgmtReqResLink.receiver.name);
                    yield this._ensureTokenRenewal();
                }
            }
            catch (err) {
                err = amqpCommon.translate(err);
                error("[%s] An error occured while establishing the $management links: %O", this._context.namespace.connectionId, err);
                throw err;
            }
        });
    }
    _isMgmtRequestResponseLinkOpen() {
        return this._mgmtReqResLink && this._mgmtReqResLink.isOpen();
    }
    /**
     * Given array of typed values, returns the element in given index
     */
    _safelyGetTypedValueFromArray(data, index) {
        return Array.isArray(data) && data.length > index && data[index]
            ? data[index].value
            : undefined;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes a map that ensures, deleting a an entry from the map is concurrency safe.
 * @internal
 * @class ConcurrentExpiringMap<TKey>
 */
class ConcurrentExpiringMap {
    constructor(options) {
        this._map = new Map();
        this._cleanupScheduled = false;
        this._lockId = rheaPromise.generate_uuid();
        this._lockStore = new amqpCommon.AsyncLock({ maxPending: 1000000 });
        if (!options)
            options = {};
        this._delayBetweenCleanupInSeconds = options.delayBetweenCleanupInSeconds || 30;
    }
    /**
     * Sets the key and it's expiration time as the value in the map.
     * @param key The key to be set.
     * @param expiration Expiration time for the key.
     * @returns void
     */
    set(key, expiration) {
        this._map.set(key, expiration);
        this._scheduleCleanup().catch((err) => {
            error("An error occurred while scheduling the cleanup, after " + "setting the key: '%s': %O", key, err);
        });
    }
    /**
     * Determines whether the key is present in the map.
     * @param key The key whose presence in the map needs to be checked.
     * @returns boolean
     */
    has(key) {
        const value = this._map.get(key);
        const result = value && value.getTime() > Date.now();
        map("Key '%s' is present in the map? -> %s", key, result);
        return result;
    }
    /**
     * Removes an entry from the the map if present
     * @param key The key which needs to be removed from the map.
     * @returns True if the key was found and removed from the map, False otherwise
     */
    delete(key) {
        map("Deleting key '%s' from the map", key);
        return this._map.delete(key);
    }
    /**
     * Clears all the entries from the underlying map.
     */
    clear() {
        map("Clearing the map of all the entries");
        this._map.clear();
    }
    _scheduleCleanup() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this._cleanupScheduled || this._map.size === 0) {
                return;
            }
            yield this._lockStore.acquire(this._lockId, () => {
                this._cleanupScheduled = true;
                this._collectExpiredEntries().catch((err) => {
                    error("An error occurred while collecting expired entries: %O", err);
                });
            });
        });
    }
    _collectExpiredEntries() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this._map.size === 0) {
                return;
            }
            yield amqpCommon.delay(this._delayBetweenCleanupInSeconds);
            this._cleanupScheduled = false;
            for (const key of this._map.keys()) {
                if (Date.now() > this._map.get(key).getTime()) {
                    this._map.delete(key);
                    map("Deleted the key '%s' from the map.", key);
                }
            }
            this._scheduleCleanup().catch((err) => {
                error("An error occurred while scheduling the cleanup, after " + "collecting expired entries: %O", err);
            });
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * @internal
 * A simple Semaphore
 * @class Semaphore
 */
class Semaphore {
    constructor(limit) {
        this._queue = [];
        this._used = 0;
        if (typeof limit !== "number") {
            throw new TypeError(`Expected limit to be a number, got ${typeof limit}`);
        }
        if (limit < 1) {
            throw new Error("limit cannot be less than 1");
        }
        this.limit = limit;
    }
    /**
     * Acquires a lock from the semaphore, returns a Promise that resolves when the caller holds
     * a lock.
     */
    acquire() {
        if (this._used < this.limit) {
            this._used += 1;
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            this._queue.push(resolve);
        });
    }
    /**
     * Releases a lock back to the semaphore.
     */
    release() {
        if (this._queue.length) {
            const item = this._queue.shift();
            if (item) {
                item();
            }
        }
        else {
            this._used -= 1;
        }
    }
    /**
     * Aquires a lock from the semaphore and then execute the fn. If the fn returns a Promise,
     * wait for that promise to settle and then release the lock back to the semaphore.
     * @param fn The function that needs to be executed in the ciritical region.
     * @returns A Promise that will settle with the return value of fn.
     */
    use(fn) {
        return this.acquire()
            .then(fn)
            .then((val) => {
            this.release();
            return val;
        })
            .catch((err) => {
            this.release();
            throw err;
        });
    }
    /**
     * Provides the number of locks currently held.
     */
    currentLockCount() {
        return this._used;
    }
    /**
     * Provides the number of tasks waiting to acquire a lock.
     */
    awaitedTaskCount() {
        return this._queue.length;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Enum to denote the entity type calling the session manager
 */
var SessionEntityType;
(function (SessionEntityType) {
    SessionEntityType["queue"] = "Queue";
    SessionEntityType["subscription"] = "Subscription";
})(SessionEntityType || (SessionEntityType = {}));
/**
 * @internal
 */
class SessionManager {
    constructor(context) {
        this._isManagingSessions = false;
        this._isCancelRequested = false;
        this._context = context;
        this.maxConcurrentSessions = 2000;
    }
    /**
     * @property {number} maxConcurrentSessions The maximum number of sessions that the user wants to
     * handle concurrently.
     * - **Default**: `2000`.
     */
    set maxConcurrentSessions(value) {
        if (value <= 0) {
            throw new Error("'maxConcurrentSessions must be greater than 0.");
        }
        this._maxConcurrentSessions = value;
        this.maxConcurrentAcceptSessionRequests = value;
    }
    get maxConcurrenSessions() {
        return this._maxConcurrentSessions;
    }
    /**
     * @property {number} _maxConcurrentAcceptSessionRequests The maximum number of acceptSession
     * requests that can be made concurrently at any given time.
     */
    set maxConcurrentAcceptSessionRequests(value) {
        this._maxConcurrentAcceptSessionRequests = Math.min(value, getProcessorCount());
    }
    get maxConcurrentAcceptSessionRequests() {
        return this._maxConcurrentAcceptSessionRequests;
    }
    /**
     * Manages MessageSessions based on the provided parameters.
     * @param onMessage The message handler to receive service bus messages from a session
     * enabled entity.
     * @param onError The error handler to receive an error that occurs while receiving messages
     * from a session enabled entity.
     */
    manageMessageSessions(entityType, onMessage, onError, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this._isManagingSessions) {
                throw new Error(`${entityType}Client for "${this._context.namespace.config.entityPath}" ` +
                    `is already receiving messages from sessions. Please close this ${entityType}Client or ` +
                    `create a new one and receiveMessages from Sessions.`);
            }
            this._isManagingSessions = true;
            this._isCancelRequested = false;
            if (!options)
                options = {};
            if (options.maxConcurrentSessions)
                this.maxConcurrentSessions = options.maxConcurrentSessions;
            // We are explicitly configuring the messageSession to timeout in 60 seconds (if not provided
            // by the user) when no new messages are received.
            if (!options.newMessageWaitTimeoutInSeconds) {
                options.newMessageWaitTimeoutInSeconds = amqpCommon.Constants.defaultOperationTimeoutInSeconds;
            }
            this._maxConcurrentSessionsSemaphore = new Semaphore(this.maxConcurrenSessions);
            this._maxPendingAcceptSessionsSemaphore = new Semaphore(this.maxConcurrentAcceptSessionRequests);
            for (let i = 0; i < this._maxConcurrentAcceptSessionRequests; i++) {
                this._acceptSessionAndReceiveMessages(onMessage, onError, options).catch((err) => {
                    error(err);
                });
            }
        });
    }
    /**
     * Close the session manager.
     */
    close() {
        sessionManager("[%s] Closing the SessionMaanger for entity '%s'.", this._context.namespace.connectionId, this._context.entityPath);
        this._isCancelRequested = true;
        this._isManagingSessions = false;
    }
    /**
     * Accept a new session and start receiving messages.
     * @param onMessage Handler for receiving messages from a session enabled entity.
     * @param onError Handler for receiving errors.
     * @param options Optional parameters for handling sessions.
     */
    _acceptSessionAndReceiveMessages(onMessage, onError, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const noActiveSessionBackOffInSeconds = 10;
            while (!this._isCancelRequested) {
                try {
                    yield this._maxConcurrentSessionsSemaphore.acquire();
                    sessionManager("[%s] Acquired the semaphore for max concurrent sessions: %d, %d.", connectionId, this._maxConcurrentSessionsSemaphore.currentLockCount(), this._maxConcurrentSessionsSemaphore.awaitedTaskCount());
                    yield this._maxPendingAcceptSessionsSemaphore.acquire();
                    sessionManager("[%s] Acquired the semaphore for max pending accept sessions: %d, %d.", connectionId, this._maxPendingAcceptSessionsSemaphore.currentLockCount(), this._maxPendingAcceptSessionsSemaphore.awaitedTaskCount());
                    const closeMessageSession = (messageSession$$1) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this._maxConcurrentSessionsSemaphore.release();
                            sessionManager("[%s] Releasing the semaphore for max concurrent sessions: %d, %d.", connectionId, this._maxConcurrentSessionsSemaphore.currentLockCount(), this._maxConcurrentSessionsSemaphore.awaitedTaskCount());
                            if (messageSession$$1.isOpen()) {
                                yield messageSession$$1.close();
                            }
                        }
                        catch (err) {
                            error("[%s] An error occurred while releasing the max concurrent session semaphore " +
                                "or while closing MessageSession with id '%s': %O.", connectionId, messageSession$$1.sessionId, err);
                        }
                    });
                    // Create the MessageSession.
                    const messageSession$$1 = yield MessageSession.create(this._context, Object.assign({ callee: SessionCallee.sessionManager }, options));
                    if (this._isCancelRequested) {
                        sessionManager("[%s] Since cancellation was requested, we will close the messageSession with id '%s'.", connectionId, messageSession$$1.sessionId);
                        yield closeMessageSession(messageSession$$1);
                    }
                    const sessionId = messageSession$$1.sessionId;
                    this._context.messageSessions[sessionId] = messageSession$$1;
                    sessionManager("[%s] Created MessageSession with id '%s'.", connectionId, sessionId);
                    const onSessionError = (error$$1) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        sessionManager("An error ocurred in MessageSession with id '%s': %O. Hence closing it.", connectionId, sessionId, error$$1);
                        yield closeMessageSession(messageSession$$1);
                        if (error$$1.name !== amqpCommon.ConditionErrorNameMapper["com.microsoft:message-wait-timeout"]) {
                            // notify the user about the error.
                            onError(error$$1);
                        }
                    });
                    messageSession$$1.receive(onMessage, onSessionError, options);
                }
                catch (err) {
                    error("[%s] An error occurred while accepting a MessageSession: %O", connectionId, err);
                    this._maxConcurrentSessionsSemaphore.release();
                    sessionManager("[%s] Releasing the semaphore for max concurrent sessions " +
                        "because an error ocurred: %d, %d.", connectionId, this._maxConcurrentSessionsSemaphore.currentLockCount(), this._maxConcurrentSessionsSemaphore.awaitedTaskCount());
                    // When we ask servicebus to give us a random session and if there are no active sessions,
                    // ServiceBus initially sends the attach frame which causes rhea to emit "receiver_open"
                    // event and thus rhea-promise resolves the promise. Moments later ServiceBus sends a
                    // detach frame with an error that the link creation timed out. Therefore inside
                    // MessageSession._init() after the promise to create a session enabled receiver link
                    // resolves we check for sessionId. If it is undefined then we reject the Promise with an
                    // error "session-cannot-be-locked". The "operation-timeout" error happens when
                    // rhea-promise does not receive a response from ServiceBus in a predefined time frame and
                    // the Promise is rejected. The "microsoft.timeout" error occurs when timeout happens on
                    // the server side and ServiceBus sends a detach frame due to which the Promise is rejected.
                    if (err.name === amqpCommon.ConditionErrorNameMapper["amqp:operation-timeout"] ||
                        err.name === amqpCommon.ConditionErrorNameMapper["com.microsoft:timeout"] ||
                        err.name === amqpCommon.ConditionErrorNameMapper["com.microsoft:session-cannot-be-locked"]) {
                        // No point in delaying if cancel has been requested.
                        if (!this._isCancelRequested) {
                            sessionManager("[%s] Sleeping for %d seconds, since there are no more active MessageSessions on " +
                                "the ServiceBus entity.", connectionId, noActiveSessionBackOffInSeconds);
                            yield amqpCommon.delay(noActiveSessionBackOffInSeconds * 1000);
                        }
                    }
                    else {
                        // notify the user about the error only when it is not one of the above mentioned errors.
                        onError(err);
                    }
                }
                finally {
                    this._maxPendingAcceptSessionsSemaphore.release();
                    sessionManager("[%s] Releasing the semaphore for max pending accept sessions from " +
                        "the finally block: %d, %d.", connectionId, this._maxPendingAcceptSessionsSemaphore.currentLockCount(), this._maxPendingAcceptSessionsSemaphore.awaitedTaskCount());
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 */
var ClientEntityContext;
(function (ClientEntityContext) {
    /**
     * @internal
     */
    function create(entityPath, context, options) {
        if (!entityPath || typeof entityPath !== "string") {
            throw new Error("'entityPath' is a required parameter and must be of type 'string'.");
        }
        if (!context || typeof context !== "object") {
            throw new Error("'context' is a required parameter and must be of type 'object'.");
        }
        if (!options)
            options = {};
        const entityContext = {
            namespace: context,
            entityPath: entityPath,
            requestResponseLockedMessages: new ConcurrentExpiringMap(),
            isSessionEnabled: !!options.isSessionEnabled,
            messageSessions: {},
            expiredMessageSessions: {}
        };
        entityContext.sessionManager = new SessionManager(entityContext);
        entityContext.getReceiver = (name, sessionId) => {
            if (sessionId && entityContext.expiredMessageSessions[sessionId]) {
                const error$$1 = new Error(`The session lock has expired on the session with id ${sessionId}.`);
                error$$1.name = "SessionLockLostError";
                throw error$$1;
            }
            let receiver$$1 = undefined;
            if (sessionId != undefined &&
                entityContext.messageSessions[sessionId] &&
                entityContext.messageSessions[sessionId].name === name) {
                receiver$$1 = entityContext.messageSessions[sessionId];
            }
            else if (entityContext.streamingReceiver && entityContext.streamingReceiver.name === name) {
                receiver$$1 = entityContext.streamingReceiver;
            }
            else if (entityContext.batchingReceiver && entityContext.batchingReceiver.name === name) {
                receiver$$1 = entityContext.batchingReceiver;
            }
            else {
                throw new Error(`Cannot find the receiver with name '${name}'.`);
            }
            return receiver$$1;
        };
        entityContext.detached = (error$$1) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionId = entityContext.namespace.connectionId;
            // reconnect the sender if present
            const sender$$1 = entityContext.sender;
            if (sender$$1 && !sender$$1.isConnecting) {
                try {
                    error("[%s] calling detached on sender '%s'.", connectionId, sender$$1.name);
                    yield sender$$1.detached();
                }
                catch (err) {
                    error("[%s] An error occurred while reconnecting the sender '%s': %O.", connectionId, sender$$1.name, err);
                }
            }
            // reconnect the batching receiver if present
            const batchingReceiver = entityContext.batchingReceiver;
            if (batchingReceiver && !batchingReceiver.isConnecting) {
                try {
                    error("[%s] calling detached on batching receiver '%s'.", connectionId, batchingReceiver.name);
                    yield batchingReceiver.detached(error$$1);
                }
                catch (err) {
                    error("[%s] An error occurred while reconnecting the sender '%s': %O.", connectionId, batchingReceiver.name, err);
                }
            }
            // reconnect the streaming receiver if present
            const streamingReceiver = entityContext.batchingReceiver;
            if (streamingReceiver && !streamingReceiver.isConnecting) {
                try {
                    error("[%s] calling detached on streaming receiver '%s'.", connectionId, streamingReceiver.name);
                    yield streamingReceiver.detached(error$$1);
                }
                catch (err) {
                    error("[%s] An error occurred while reconnecting the sender '%s': %O.", connectionId, streamingReceiver.name, err);
                }
            }
        });
        entityContext.clearClientReference = (clientId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            delete context.clients[clientId];
            if (!entityContext.managementClient) {
                return;
            }
            let isManagementClientInUse = false;
            for (const id of Object.keys(context.clients)) {
                if (context.clients[id].entityPath === entityContext.entityPath) {
                    isManagementClientInUse = true;
                    break;
                }
            }
            if (!isManagementClientInUse) {
                yield entityContext.managementClient.close();
                entityContext.managementClient = undefined;
            }
        });
        let managementClient = getManagementClient(context.clients, entityPath);
        if (!managementClient) {
            const mOptions = {
                address: options.managementClientAddress || `${entityPath}/$management`,
                audience: options.managementClientAudience
            };
            managementClient = new ManagementClient(entityContext, mOptions);
        }
        entityContext.managementClient = managementClient;
        entityCtxt("Created client entity context: %O", entityContext);
        return entityContext;
    }
    ClientEntityContext.create = create;
})(ClientEntityContext || (ClientEntityContext = {}));
// Multiple Queue clients for the same queue should be using the same management client.
function getManagementClient(clients, entityPath) {
    let result;
    for (const id of Object.keys(clients)) {
        if (clients[id].entityPath === entityPath) {
            result = clients[id]._context.managementClient;
            break;
        }
    }
    return result;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the client that allows interacting with a Service Bus Queue.
 * Use the `createQueueClient` function on the Namespace object to instantiate a QueueClient
 * @class QueueClient
 */
class QueueClient {
    /**
     * Constructor for QueueClient.
     * This is not meant for the user to call directly.
     * The user should use the `createQueueClient` on the Namespace instead.
     *
     * @constructor
     * @internal
     * @param name The Queue name.
     * @param context The connection context to create the QueueClient.
     */
    constructor(name, context) {
        /**
         * @property {boolean} _isClosed Denotes if close() was called on this client.
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(context);
        this.entityPath = name;
        this.id = `${this.entityPath}/${rheaPromise.generate_uuid()}`;
        this._context = ClientEntityContext.create(this.entityPath, context);
    }
    /**
     * Closes all the AMQP links for sender/receivers created by this client.
     * Once closed, neither the QueueClient nor its sender/recievers can be used for any
     * further operations. Use the `createQueueClient` function on the Namespace object to
     * instantiate a new QueueClient
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.namespace.connection && this._context.namespace.connection.isOpen()) {
                    // Close the sender.
                    if (this._currentSender) {
                        yield this._currentSender.close();
                    }
                    // Close the sessionManager.
                    if (this._context.sessionManager) {
                        this._context.sessionManager.close();
                    }
                    // Close the streaming and batching receivers.
                    if (this._currentReceiver) {
                        yield this._currentReceiver.close();
                    }
                    // Close all the MessageSessions.
                    for (const messageSessionId of Object.keys(this._context.messageSessions)) {
                        yield this._context.messageSessions[messageSessionId].close();
                    }
                    // Make sure that we clear the map of deferred messages
                    this._context.requestResponseLockedMessages.clear();
                    // Delete the reference in ConnectionContext
                    yield this._context.clearClientReference(this.id);
                    // Mark this client as closed, so that we can show appropriate errors for subsequent usage
                    this._isClosed = true;
                    qClient("Closed the Queue client '%s'.", this.id);
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the queue client ` +
                    `"${this.id}": ${JSON.stringify(err)} `;
                error(msg);
                throw new Error(msg);
            }
        });
    }
    /**
     * Will reconnect the queueClient and all its sender/receiver links.
     * This is meant for the library to use to resume sending/receiving when retryable errors are seen.
     * This is not meant for the consumer of this library to use.
     * @ignore
     * @param error Error if any due to which we are attempting to reconnect
     */
    detached(error$$1) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this._context.detached(error$$1);
            }
            catch (err) {
                error("[%s] [%s] An error occurred while reconnecting the client: %O.", this._context.namespace.connectionId, this.id, err);
            }
        });
    }
    /**
     * Gets a Sender to be used for sending messages, scheduling messages to be sent at a later time
     * and cancelling such scheduled messages.
     */
    getSender() {
        this.throwErrorIfClientOrConnectionClosed();
        if (!this._currentSender || this._currentSender.isClosed) {
            this._currentSender = new Sender(this._context);
        }
        return this._currentSender;
    }
    /**
     * Gets a Receiver to be used for receiving messages in batches or by registering handlers.
     *
     * @param options Options for creating the receiver.
     */
    getReceiver(options) {
        this.throwErrorIfClientOrConnectionClosed();
        if (!this._currentReceiver || this._currentReceiver.isClosed) {
            this._currentReceiver = new Receiver(this._context, options);
        }
        return this._currentReceiver;
    }
    /**
     * Fetches the next batch of active messages (including deferred but not deadlettered messages).
     * The first call to `peek()` fetches the first active message. Each subsequent call fetches the
     * subsequent message.
     *
     * Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param [messageCount] The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     */
    peek(messageCount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwErrorIfClientOrConnectionClosed();
            return this._context.managementClient.peek(messageCount);
        });
    }
    /**
     * Peeks the desired number of active messages (including deferred but not deadlettered messages)
     * from the specified sequence number.
     *
     * Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param [messageCount] The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     */
    peekBySequenceNumber(fromSequenceNumber, messageCount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwErrorIfClientOrConnectionClosed();
            return this._context.managementClient.peekBySequenceNumber(fromSequenceNumber, {
                messageCount: messageCount
            });
        });
    }
    // /**
    //  * Lists the ids of the sessions on the ServiceBus Queue.
    //  * @param maxNumberOfSessions Maximum number of sessions.
    //  * @param lastUpdateTime Filter to include only sessions updated after a given time. Default
    //  * value is 3 days before the current time.
    //  */
    // async listMessageSessions(
    //   maxNumberOfSessions: number,
    //   lastUpdatedTime?: Date
    // ): Promise<string[]> {
    // this.throwErrorIfClientOrConnectionClosed();
    //   return this._context.managementClient!.listMessageSessions(
    //     0,
    //     maxNumberOfSessions,
    //     lastUpdatedTime
    //   );
    // }
    /**
     * Gets a SessionReceiver for receiving messages in batches or by registering handlers from a
     * session enabled Queue. When no sessionId is given, a random session among the available
     * sessions is used.
     *
     * @param options Options to provide sessionId and ReceiveMode for receiving messages from the
     * session enabled Servicebus Queue.
     *
     * @returns SessionReceiver An instance of a SessionReceiver to receive messages from the session.
     */
    getSessionReceiver(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwErrorIfClientOrConnectionClosed();
            if (!options)
                options = {};
            if (options.sessionId) {
                if (this._context.messageSessions[options.sessionId] &&
                    this._context.messageSessions[options.sessionId].isOpen()) {
                    throw new Error(`Close the current session receiver for sessionId ${options.sessionId} before using "getSessionReceiver" to create a new one for the same sessionId`);
                }
            }
            this._context.isSessionEnabled = true;
            const messageSession$$1 = yield MessageSession.create(this._context, options);
            if (messageSession$$1.sessionId) {
                delete this._context.expiredMessageSessions[messageSession$$1.sessionId];
            }
            return new SessionReceiver(this._context, messageSession$$1);
        });
    }
    /**
     * Throws error if this queueClient has been closed
     * @param client
     */
    throwErrorIfClientOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (this._isClosed) {
            throw new Error("The queueClient has been closed and can no longer be used.");
        }
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the client that allows interacting with a Service Bus Topic.
 * Use the `createTopicClient` function on the Namespace object to instantiate a TopicClient
 * @class TopicClient
 */
class TopicClient {
    /**
     * Constructor for TopicClient.
     * This is not meant for the user to call directly.
     * The user should use the `createTopicClient` on the Namespace instead.
     *
     * @constructor
     * @internal
     * @param name - The topic name.
     * @param context - The connection context to create the TopicClient.
     */
    constructor(name, context) {
        /**
         * @property {boolean} _isClosed Denotes if close() was called on this client.
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(context);
        this.entityPath = name;
        this.id = `${this.entityPath}/${rheaPromise.generate_uuid()}`;
        this._context = ClientEntityContext.create(this.entityPath, context);
    }
    /**
     * Closes the AMQP link for the sender created by this client.
     * Once closed, neither the TopicClient nor its senders can be used for any
     * further operations. Use the `createTopicClient` function on the Namespace object to
     * instantiate a new TopicClient
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.namespace.connection && this._context.namespace.connection.isOpen()) {
                    // Close the sender.
                    if (this._currentSender) {
                        yield this._currentSender.close();
                    }
                    // Delete the reference in ConnectionContext
                    yield this._context.clearClientReference(this.id);
                    // Mark this client as closed, so that we can show appropriate errors for subsequent usage
                    this._isClosed = true;
                    topicClient("Closed the topic client '%s'.", this.id);
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the topic client ` +
                    `"${this.id}": ${JSON.stringify(err)} `;
                error(msg);
                throw new Error(msg);
            }
        });
    }
    /**
     * Will reconnect the topicClient and its sender links.
     * This is meant for the library to use to resume sending when retryable errors are seen.
     * This is not meant for the consumer of this library to use.
     * @ignore
     * @param error Error if any due to which we are attempting to reconnect
     */
    detached(error$$1) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this._context.detached(error$$1);
            }
            catch (err) {
                error("[%s] [%s] An error occurred while reconnecting the client: %O.", this._context.namespace.connectionId, this.id, err);
            }
        });
    }
    /**
     * Gets a Sender to be used for sending messages, scheduling messages to be sent at a later time
     * and cancelling such scheduled messages.
     *
     * If the Topic has session enabled Subscriptions, then messages sent without the `sessionId`
     * property will go to the dead letter queue of such subscriptions.
     */
    getSender() {
        this.throwErrorIfClientOrConnectionClosed();
        if (!this._currentSender || this._currentSender.isClosed) {
            this._currentSender = new Sender(this._context);
        }
        return this._currentSender;
    }
    /**
     * Throws error if given client has been closed
     * @param client
     */
    throwErrorIfClientOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (this._isClosed) {
            throw new Error("The topicClient has been closed and can no longer be used.");
        }
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the client that allows interacting with a Service Bus Subscription.
 * Use the `createSubscriptionClient` function on the Namespace object to instantiate a
 * SubscriptionClient
 * @class SubscriptionClient
 */
class SubscriptionClient {
    /**
     * Constructor for SubscriptionClient.
     * This is not meant for the user to call directly.
     * The user should use the `createSubscriptionClient` on the Namespace instead.
     *
     * @constructor
     * @internal
     * @param topicName - The Topic name.
     * @param subscriptionName - The Subscription name.
     * @param context - The connection context to create the SubscriptionClient.
     */
    constructor(topicName, subscriptionName, context) {
        /**
         * @property {string} defaultRuleName Name of the default rule on the subscription.
         */
        this.defaultRuleName = "$Default";
        /**
         * @property {boolean} _isClosed Denotes if close() was called on this client.
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(context);
        this.entityPath = `${topicName}/Subscriptions/${subscriptionName}`;
        this.id = `${this.entityPath}/${rheaPromise.generate_uuid()}`;
        this._context = ClientEntityContext.create(this.entityPath, context);
        this.topicName = topicName;
        this.subscriptionName = subscriptionName;
    }
    /**
     * Closes the AMQP link for the receivers created by this client.
     * Once closed, neither the SubscriptionClient nor its recievers can be used for any
     * further operations. Use the `createSubscriptionClient` function on the Namespace object to
     * instantiate a new SubscriptionClient.
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.namespace.connection && this._context.namespace.connection.isOpen()) {
                    // Close the sessionManager.
                    if (this._context.sessionManager) {
                        this._context.sessionManager.close();
                    }
                    // Close the streaming and batching receivers.
                    if (this._currentReceiver) {
                        yield this._currentReceiver.close();
                    }
                    // Close all the MessageSessions.
                    for (const messageSessionId of Object.keys(this._context.messageSessions)) {
                        yield this._context.messageSessions[messageSessionId].close();
                    }
                    // Make sure that we clear the map of deferred messages
                    this._context.requestResponseLockedMessages.clear();
                    // Delete the reference in ConnectionContext
                    yield this._context.clearClientReference(this.id);
                    // Mark this client as closed, so that we can show appropriate errors for subsequent usage
                    this._isClosed = true;
                    subscriptionClient("Closed the subscription client '%s'.", this.id);
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the subscription client ` +
                    `"${this.id}": ${JSON.stringify(err)} `;
                error(msg);
                throw new Error(msg);
            }
        });
    }
    /**
     * Will reconnect the subscritpionClient and its receiver links.
     * This is meant for the library to use to resume receiving when retryable errors are seen.
     * This is not meant for the consumer of this library to use.
     * @ignore
     * @param error Error if any due to which we are attempting to reconnect
     */
    detached(error$$1) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this._context.detached(error$$1);
            }
            catch (err) {
                error("[%s] [%s] An error occurred while reconnecting the client: %O.", this._context.namespace.connectionId, this.id, err);
            }
        });
    }
    /**
     * Gets a Receiver to be used for receiving messages in batches or by registering handlers.
     *
     * @param options Options for creating the receiver.
     */
    getReceiver(options) {
        this.throwErrorIfClientOrConnectionClosed();
        if (!this._currentReceiver || this._currentReceiver.isClosed) {
            this._currentReceiver = new Receiver(this._context, options);
        }
        return this._currentReceiver;
    }
    /**
     * Fetches the next batch of active messages (including deferred but not deadlettered messages).
     * The first call to `peek()` fetches the first active message. Each subsequent call fetches the
     * subsequent message.
     *
     * Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param [messageCount] The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     */
    peek(messageCount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwErrorIfClientOrConnectionClosed();
            return this._context.managementClient.peek(messageCount);
        });
    }
    /**
     * Peeks the desired number of active messages (including deferred but not deadlettered messages)
     * from the specified sequence number.
     *
     * Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param [messageCount] The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     */
    peekBySequenceNumber(fromSequenceNumber, messageCount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwErrorIfClientOrConnectionClosed();
            return this._context.managementClient.peekBySequenceNumber(fromSequenceNumber, {
                messageCount: messageCount
            });
        });
    }
    //#region topic-filters
    /**
     * Get all the rules associated with the subscription
     */
    getRules() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwErrorIfClientOrConnectionClosed();
            return this._context.managementClient.getRules();
        });
    }
    /**
     * Removes the rule on the subscription identified by the given rule name.
     * @param ruleName
     */
    removeRule(ruleName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwErrorIfClientOrConnectionClosed();
            return this._context.managementClient.removeRule(ruleName);
        });
    }
    /**
     * Adds a rule on the subscription as defined by the given rule name, filter and action.
     * Remember to remove the default true filter on the subscription before adding a rule,
     * otherwise, the added rule will have no affect as the true filter will always result in
     * the subscription receiving all messages.
     * @param ruleName Name of the rule
     * @param filter A Boolean, SQL expression or a Correlation filter. For SQL Filter syntax, see
     * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-filter SQLFilter syntax}.
     * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression. For SQL Rule Action syntax,
     * see {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-rule-action SQLRuleAction syntax}.
     */
    addRule(ruleName, filter, sqlRuleActionExpression) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwErrorIfClientOrConnectionClosed();
            return this._context.managementClient.addRule(ruleName, filter, sqlRuleActionExpression);
        });
    }
    //#endregion
    //#region sessions
    // /**
    //  * Lists the ids of the sessions on the ServiceBus Subscription.
    //  * @param maxNumberOfSessions Maximum number of sessions.
    //  * @param lastUpdateTime Filter to include only sessions updated after a given time. Default
    //  * value is 3 days before the current time.
    //  */
    // async listMessageSessions(
    //   maxNumberOfSessions: number,
    //   lastUpdatedTime?: Date
    // ): Promise<string[]> {
    // this.throwErrorIfClientOrConnectionClosed();
    //   return this._context.managementClient!.listMessageSessions(
    //     0,
    //     maxNumberOfSessions,
    //     lastUpdatedTime
    //   );
    // }
    /**
     * Gets a SessionReceiver for receiving messages in batches or by registering handlers from a
     * session enabled Subscription. When no sessionId is given, a random session among the available
     * sessions is used.
     *
     * @param options Options to provide sessionId and ReceiveMode for receiving messages from the
     * session enabled Servicebus Subscription.
     *
     * @returns SessionReceiver An instance of a SessionReceiver to receive messages from the session.
     */
    getSessionReceiver(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.throwErrorIfClientOrConnectionClosed();
            if (!options)
                options = {};
            if (options.sessionId) {
                if (this._context.messageSessions[options.sessionId] &&
                    this._context.messageSessions[options.sessionId].isOpen()) {
                    throw new Error(`Close the current session receiver for sessionId ${options.sessionId} before using "getSessionReceiver" to create a new one for the same sessionId`);
                }
            }
            this._context.isSessionEnabled = true;
            const messageSession$$1 = yield MessageSession.create(this._context, options);
            if (messageSession$$1.sessionId) {
                delete this._context.expiredMessageSessions[messageSession$$1.sessionId];
            }
            return new SessionReceiver(this._context, messageSession$$1);
        });
    }
    //#endregion
    /**
     * Throws error if this subscriptionClient has been closed
     * @param client
     */
    throwErrorIfClientOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (this._isClosed) {
            throw new Error("The subscriptionClient has been closed and can no longer be used.");
        }
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Holds the AMQP connection to the Service Bus Namespace and is the entry point for using Queues,
 * Topics and Subscriptions.
 */
class Namespace {
    /**
     * Instantiates a client pointing to the Service Bus Namespace.
     *
     * @constructor
     * @param {ConnectionConfig} config - The connection configuration to create the Namespace.
     * @param {TokenProvider} [tokenProvider] - The token provider that provides the token for
     * authentication.
     * @param {NamespaceOptions} - Options to create the Namespace.
     */
    constructor(config, tokenProvider, options) {
        if (!options)
            options = {};
        this.name = config.endpoint;
        this._context = ConnectionContext.create(config, tokenProvider, options);
    }
    /**
     * Creates a QueueClient for the given Queue name. It assumes that the queue has already been
     * created.
     * @param {string} queueName The queue name.
     * @returns QueueClient.
     */
    createQueueClient(queueName) {
        if (!queueName || typeof queueName !== "string") {
            throw new Error("'queueName' is a required parameter and must be of type 'string'.");
        }
        const client = new QueueClient(queueName, this._context);
        this._context.clients[client.id] = client;
        ns("Created the QueueClient for Queue: %s", queueName);
        return client;
    }
    /**
     * Creates a TopicClient for the given topic name. It assumes that the topic has already been
     * created.
     * @param {string} topicName The topic name.
     * @returns TopicClient.
     */
    createTopicClient(topicName) {
        if (!topicName || typeof topicName !== "string") {
            throw new Error("'topicName' is a required parameter and must be of type 'string'.");
        }
        const client = new TopicClient(topicName, this._context);
        this._context.clients[client.id] = client;
        ns("Created the TopicClient for Topic: %s", topicName);
        return client;
    }
    /**
     * Creates a SubscriptionClient for the given topic name and subscription.
     * It assumes that the topic has already been created.
     * @param {string} topicName The topic name.
     * @param {string} subscriptionName The subscription name.
     * @returns SubscriptionClient.
     */
    createSubscriptionClient(topicName, subscriptionName) {
        if (!topicName || typeof topicName !== "string") {
            throw new Error("'topicName' is a required parameter and must be of type 'string'.");
        }
        if (!subscriptionName || typeof subscriptionName !== "string") {
            throw new Error("'subscriptionName' is a required parameter and must be of type 'string'.");
        }
        const client = new SubscriptionClient(topicName, subscriptionName, this._context);
        this._context.clients[client.id] = client;
        ns("Created the SubscriptionClient for Topic: %s and Subscription: %s", topicName, subscriptionName);
        return client;
    }
    /**
     * Closes the AMQP connection created by this namespace along with AMQP links for sender/receivers
     * created by the queue/topic/subscription clients created in this namespace.
     * Once closed,
     * - the namespace cannot be used to create anymore clients for queues/topics/subscriptions
     * - the clients created in this namespace cannot be used to send/receive messages anymore
     * @returns {Promise<any>}
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.connection.isOpen()) {
                    // Close all the senders.
                    for (const id of Object.keys(this._context.clients)) {
                        const client = this._context.clients[id];
                        yield client.close();
                    }
                    yield this._context.cbsSession.close();
                    // Close management sessions
                    for (const id of Object.keys(this._context.clients)) {
                        const client = this._context.clients[id];
                        yield client._context.managementClient.close();
                    }
                    yield this._context.connection.close();
                    this._context.wasConnectionCloseCalled = true;
                    ns("Closed the amqp connection '%s' on the client.", this._context.connectionId);
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the connection ` +
                    `"${this._context.connectionId}": ${err ? err.stack : JSON.stringify(err)}`;
                error(msg);
                throw new Error(msg);
            }
        });
    }
    /**
     * Creates a Namespace from connection string.
     * @param {string} connectionString - Connection string of the form
     * 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {NamespaceOptions} [options] Options that can be provided during namespace creation.
     * @returns {Namespace} - An instance of the Namespace.
     */
    static createFromConnectionString(connectionString, options) {
        if (!connectionString || typeof connectionString !== "string") {
            throw new Error("'connectionString' is a required parameter and must be of type: 'string'.");
        }
        const config = amqpCommon.ConnectionConfig.create(connectionString);
        amqpCommon.ConnectionConfig.validate(config);
        const tokenProvider = new amqpCommon.SasTokenProvider(config.endpoint, config.sharedAccessKeyName, config.sharedAccessKey);
        return new Namespace(config, tokenProvider, options);
    }
    /**
     * Creates a Namespace from a generic token provider.
     * @param {string} host - Fully qualified domain name for Servicebus. Most likely,
     * `<yournamespace>.servicebus.windows.net`.
     * @param {TokenProvider} tokenProvider - Your token provider that implements the TokenProvider interface.
     * @param {NamespaceOptions} options - The options that can be provided during namespace creation.
     * @returns {Namespace} An instance of the Namespace.
     */
    static createFromTokenProvider(host, tokenProvider, options) {
        if (!host || (host && typeof host !== "string")) {
            throw new Error("'host' is a required parameter and must be of type: 'string'.");
        }
        if (!tokenProvider || (tokenProvider && typeof tokenProvider !== "object")) {
            throw new Error("'tokenProvider' is a required parameter and must be of type: 'object'.");
        }
        if (!host.endsWith("/"))
            host += "/";
        const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;` +
            `SharedAccessKey=defaultKeyValue`;
        const config = amqpCommon.ConnectionConfig.create(connectionString);
        amqpCommon.ConnectionConfig.validate(config);
        return new Namespace(config, tokenProvider, options);
    }
    /**
     * Creates a Namespace from AADTokenCredentials.
     * @param {string} host - Fully qualified domain name for ServiceBus.
     * Most likely, {yournamespace}.servicebus.windows.net
     * @param {TokenCredentials} credentials - The AAD Token credentials.
     * It can be one of the following: ApplicationTokenCredentials | UserTokenCredentials |
     * DeviceTokenCredentials | MSITokenCredentials.
     * @param {NamespaceOptions} options - The options that can be provided during namespace creation.
     * @returns {Namespace} An instance of the Namespace.
     */
    static createFromAadTokenCredentials(host, credentials, options) {
        if (!host || typeof host !== "string") {
            throw new Error("'host' is a required parameter and must be of type: 'string'.");
        }
        if (typeof credentials !== "object") {
            throw new Error("'credentials' is a required parameter and must be an instance of " +
                "ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials | " +
                "MSITokenCredentials.");
        }
        const tokenProvider = new amqpCommon.AadTokenProvider(credentials);
        return Namespace.createFromTokenProvider(host, tokenProvider, options);
    }
    /**
     * Returns the corresponding dead letter queue name for the given queue name.
     * Use this in the `createQueueClient` function to receive messages from dead letter queue.
     * @param queueName
     */
    static getDeadLetterQueuePath(queueName) {
        return `${queueName}/$DeadLetterQueue`;
    }
    /**
     * Returns the corresponding dead letter topic name for the given topic and subscription names.
     * Use this in the `createSubscriptionClient` function to receive messages from dead letter
     * subscription corresponding to given subscription
     * @param topicName
     * @param subscriptionName
     */
    static getDeadLetterTopicPath(topicName, subscriptionName) {
        return `${topicName}/Subscriptions/${subscriptionName}/$DeadLetterQueue`;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.

// Copyright (c) Microsoft Corporation. All rights reserved.
class TestMessage {
    static getSample() {
        const randomNumber = Math.random();
        return {
            body: `message body ${randomNumber}`,
            messageId: `message id ${randomNumber}`,
            partitionKey: "dummy"
        };
    }
    static getSessionSample() {
        const randomNumber = Math.random();
        return {
            body: `message body ${randomNumber}`,
            messageId: `message id ${randomNumber}`,
            sessionId: TestMessage.sessionId
        };
    }
}
TestMessage.sessionId = "my-session";
var ClientType;
(function (ClientType) {
    ClientType[ClientType["PartitionedQueue"] = 0] = "PartitionedQueue";
    ClientType[ClientType["PartitionedTopic"] = 1] = "PartitionedTopic";
    ClientType[ClientType["PartitionedSubscription"] = 2] = "PartitionedSubscription";
    ClientType[ClientType["UnpartitionedQueue"] = 3] = "UnpartitionedQueue";
    ClientType[ClientType["UnpartitionedTopic"] = 4] = "UnpartitionedTopic";
    ClientType[ClientType["UnpartitionedSubscription"] = 5] = "UnpartitionedSubscription";
    ClientType[ClientType["PartitionedQueueWithSessions"] = 6] = "PartitionedQueueWithSessions";
    ClientType[ClientType["PartitionedTopicWithSessions"] = 7] = "PartitionedTopicWithSessions";
    ClientType[ClientType["PartitionedSubscriptionWithSessions"] = 8] = "PartitionedSubscriptionWithSessions";
    ClientType[ClientType["UnpartitionedQueueWithSessions"] = 9] = "UnpartitionedQueueWithSessions";
    ClientType[ClientType["UnpartitionedTopicWithSessions"] = 10] = "UnpartitionedTopicWithSessions";
    ClientType[ClientType["UnpartitionedSubscriptionWithSessions"] = 11] = "UnpartitionedSubscriptionWithSessions";
    ClientType[ClientType["TopicFilterTestTopic"] = 12] = "TopicFilterTestTopic";
    ClientType[ClientType["TopicFilterTestDefaultSubscription"] = 13] = "TopicFilterTestDefaultSubscription";
    ClientType[ClientType["TopicFilterTestSubscription"] = 14] = "TopicFilterTestSubscription";
})(ClientType || (ClientType = {}));
const defaultLockDuration = "PT30S"; // 30 seconds in ISO 8601 FORMAT - equivalent to "P0Y0M0DT0H0M30S"
function getEnvVars() {
    if (!process.env.AAD_CLIENT_ID) {
        throw new Error("Define AAD_CLIENT_ID in your environment before running integration tests.");
    }
    if (!process.env.AAD_CLIENT_SECRET) {
        throw new Error("Define AAD_CLIENT_SECRET in your environment before running integration tests.");
    }
    if (!process.env.AAD_TENANT_ID) {
        throw new Error("Define AAD_TENANT_ID in your environment before running integration tests.");
    }
    if (!process.env.AZURE_SUBSCRIPTION_ID) {
        throw new Error("Define AZURE_SUBSCRIPTION_ID in your environment before running integration tests.");
    }
    if (!process.env.RESOURCE_GROUP) {
        throw new Error("Define RESOURCE_GROUP in your environment before running integration tests.");
    }
    if (!process.env.SERVICEBUS_CONNECTION_STRING) {
        throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
    }
    const servicebusNamespace = (process.env.SERVICEBUS_CONNECTION_STRING.match("Endpoint=sb://(.*).servicebus.windows.net") || "")[1];
    return {
        clientId: process.env.AAD_CLIENT_ID,
        clientSecret: process.env.AAD_CLIENT_SECRET,
        tenantId: process.env.AAD_TENANT_ID,
        subscriptionId: process.env.AZURE_SUBSCRIPTION_ID,
        resourceGroup: process.env.RESOURCE_GROUP,
        servicebusNamespace: servicebusNamespace
    };
}
function recreateQueue(queueName, parameters) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const env = getEnvVars();
        yield msRestNodeAuth.loginWithServicePrincipalSecret(env.clientId, env.clientSecret, env.tenantId)
            .then((creds) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = yield new armServicebus.ServiceBusManagementClient(creds, env.subscriptionId);
            yield client.queues.deleteMethod(env.resourceGroup, env.servicebusNamespace, queueName, function (error) {
                if (error)
                    throw error.message;
            });
            yield client.queues.createOrUpdate(env.resourceGroup, env.servicebusNamespace, queueName, parameters, function (error) {
                if (error)
                    throw error.message;
            });
        }));
    });
}
function recreateTopic(topicName, parameters) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const env = getEnvVars();
        yield msRestNodeAuth.loginWithServicePrincipalSecret(env.clientId, env.clientSecret, env.tenantId)
            .then((creds) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = yield new armServicebus.ServiceBusManagementClient(creds, env.subscriptionId);
            yield client.topics.deleteMethod(env.resourceGroup, env.servicebusNamespace, topicName, function (error) {
                if (error)
                    throw error.message;
            });
            yield client.topics.createOrUpdate(env.resourceGroup, env.servicebusNamespace, topicName, parameters, function (error) {
                if (error)
                    throw error.message;
            });
        }));
    });
}
function recreateSubscription(topicName, subscriptionName, parameters) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const env = getEnvVars();
        yield msRestNodeAuth.loginWithServicePrincipalSecret(env.clientId, env.clientSecret, env.tenantId)
            .then((creds) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = yield new armServicebus.ServiceBusManagementClient(creds, env.subscriptionId);
            /*
              Unlike Queues/Topics, there is no need to delete the subscription because
              `recreateTopic` is called before `recreateSubscription` which would
              delete the topic and the subscriptions before creating a new topic.
            */
            yield client.subscriptions.createOrUpdate(env.resourceGroup, env.servicebusNamespace, topicName, subscriptionName, parameters, function (error) {
                if (error)
                    throw error.message;
            });
        }));
    });
}
function getSenderReceiverClients(namespace, senderClientType, receiverClientType) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        switch (receiverClientType) {
            case ClientType.PartitionedQueue: {
                const queueName = process.env.QUEUE_NAME || "partitioned-queue";
                if (process.env.CLEAN_NAMESPACE) {
                    yield recreateQueue(queueName, {
                        lockDuration: defaultLockDuration,
                        enablePartitioning: true,
                        enableBatchedOperations: true
                    });
                }
                const queueClient = namespace.createQueueClient(queueName);
                return {
                    senderClient: queueClient,
                    receiverClient: queueClient
                };
            }
            case ClientType.PartitionedSubscription: {
                const topicName = process.env.TOPIC_NAME || "partitioned-topic";
                const subscriptionName = process.env.SUBSCRIPTION_NAME || "partitioned-topic-subscription";
                if (process.env.CLEAN_NAMESPACE) {
                    yield recreateTopic(topicName, {
                        enablePartitioning: true,
                        enableBatchedOperations: true
                    });
                    yield recreateSubscription(topicName, subscriptionName, {
                        lockDuration: defaultLockDuration,
                        enableBatchedOperations: true
                    });
                }
                return {
                    senderClient: namespace.createTopicClient(topicName),
                    receiverClient: namespace.createSubscriptionClient(topicName, subscriptionName)
                };
            }
            case ClientType.UnpartitionedQueue: {
                const queueName = process.env.QUEUE_NAME_NO_PARTITION || "unpartitioned-queue";
                if (process.env.CLEAN_NAMESPACE) {
                    yield recreateQueue(queueName, {
                        lockDuration: defaultLockDuration,
                        enableBatchedOperations: true
                    });
                }
                const queueClient = namespace.createQueueClient(queueName);
                return {
                    senderClient: queueClient,
                    receiverClient: queueClient
                };
            }
            case ClientType.UnpartitionedSubscription: {
                const topicName = process.env.TOPIC_NAME_NO_PARTITION || "unpartitioned-topic";
                const subscriptionName = process.env.SUBSCRIPTION_NAME_NO_PARTITION || "unpartitioned-topic-subscription";
                if (process.env.CLEAN_NAMESPACE) {
                    yield recreateTopic(topicName, {
                        enableBatchedOperations: true
                    });
                    yield recreateSubscription(topicName, subscriptionName, {
                        lockDuration: defaultLockDuration,
                        enableBatchedOperations: true
                    });
                }
                return {
                    senderClient: namespace.createTopicClient(topicName),
                    receiverClient: namespace.createSubscriptionClient(topicName, subscriptionName)
                };
            }
            case ClientType.PartitionedQueueWithSessions: {
                const queueName = process.env.QUEUE_NAME_SESSION || "partitioned-queue-sessions";
                if (process.env.CLEAN_NAMESPACE) {
                    yield recreateQueue(queueName, {
                        lockDuration: defaultLockDuration,
                        enablePartitioning: true,
                        enableBatchedOperations: true,
                        requiresSession: true
                    });
                }
                const queueClient = namespace.createQueueClient(queueName);
                return {
                    senderClient: queueClient,
                    receiverClient: queueClient
                };
            }
            case ClientType.PartitionedSubscriptionWithSessions: {
                const topicName = process.env.TOPIC_NAME_SESSION || "partitioned-topic-sessions";
                const subscriptionName = process.env.SUBSCRIPTION_NAME_SESSION || "partitioned-topic-sessions-subscription";
                if (process.env.CLEAN_NAMESPACE) {
                    yield recreateTopic(topicName, {
                        enablePartitioning: true,
                        enableBatchedOperations: true
                    });
                    yield recreateSubscription(topicName, subscriptionName, {
                        lockDuration: defaultLockDuration,
                        enableBatchedOperations: true,
                        requiresSession: true
                    });
                }
                return {
                    senderClient: namespace.createTopicClient(topicName),
                    receiverClient: namespace.createSubscriptionClient(topicName, subscriptionName)
                };
            }
            case ClientType.UnpartitionedQueueWithSessions: {
                const queueName = process.env.QUEUE_NAME_NO_PARTITION_SESSION || "unpartitioned-queue-sessions";
                if (process.env.CLEAN_NAMESPACE) {
                    yield recreateQueue(queueName, {
                        lockDuration: defaultLockDuration,
                        enableBatchedOperations: true,
                        requiresSession: true
                    });
                }
                const queueClient = namespace.createQueueClient(queueName);
                return {
                    senderClient: queueClient,
                    receiverClient: queueClient
                };
            }
            case ClientType.UnpartitionedSubscriptionWithSessions: {
                const topicName = process.env.TOPIC_NAME_NO_PARTITION_SESSION || "unpartitioned-topic-sessions";
                const subscriptionName = process.env.SUBSCRIPTION_NAME_NO_PARTITION_SESSION ||
                    "unpartitioned-topic-sessions-subscription";
                if (process.env.CLEAN_NAMESPACE) {
                    yield recreateTopic(topicName, {
                        enableBatchedOperations: true
                    });
                    yield recreateSubscription(topicName, subscriptionName, {
                        lockDuration: defaultLockDuration,
                        enableBatchedOperations: true,
                        requiresSession: true
                    });
                }
                return {
                    senderClient: namespace.createTopicClient(topicName),
                    receiverClient: namespace.createSubscriptionClient(topicName, subscriptionName)
                };
            }
            case ClientType.TopicFilterTestDefaultSubscription: {
                const topicName = process.env.TOPIC_FILTER_NAME || "topic-filter";
                const subscriptionName = process.env.TOPIC_FILTER_DEFAULT_SUBSCRIPTION_NAME || "topic-filter-default-subscription";
                if (process.env.CLEAN_NAMESPACE) {
                    yield recreateTopic(topicName, {
                        enableBatchedOperations: true
                    });
                    yield recreateSubscription(topicName, subscriptionName, {
                        lockDuration: defaultLockDuration,
                        enableBatchedOperations: true
                    });
                }
                return {
                    senderClient: namespace.createTopicClient(topicName),
                    receiverClient: namespace.createSubscriptionClient(topicName, subscriptionName)
                };
            }
            case ClientType.TopicFilterTestSubscription: {
                const topicName = process.env.TOPIC_FILTER_NAME || "topic-filter";
                const subscriptionName = process.env.TOPIC_FILTER_SUBSCRIPTION_NAME || "topic-filter-subscription";
                if (process.env.CLEAN_NAMESPACE) {
                    yield recreateTopic(topicName, {
                        enableBatchedOperations: true
                    });
                    yield recreateSubscription(topicName, subscriptionName, {
                        lockDuration: defaultLockDuration,
                        enableBatchedOperations: true
                    });
                }
                return {
                    senderClient: namespace.createTopicClient(topicName),
                    receiverClient: namespace.createSubscriptionClient(topicName, subscriptionName)
                };
            }
            default:
                break;
        }
        throw new Error("Cannot create sender/receiver clients for given client types");
    });
}
/**
 * Purges the content in the Queue/Subscription corresponding to the receiverClient
 * @param receiverClient
 * @param sessionId if passed, session receiver will be used instead of normal receiver
 */
function purge(receiverClient, sessionId) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let isEmpty = false;
        while (!isEmpty) {
            const peekedMsgs = yield receiverClient.peek(10);
            if (peekedMsgs.length === 0) {
                isEmpty = true;
            }
            else {
                const receiver = sessionId
                    ? yield receiverClient.getSessionReceiver({ sessionId: sessionId })
                    : receiverClient.getReceiver();
                const msgs = yield receiver.receiveBatch(peekedMsgs.length);
                for (let index = 0; index < msgs.length; index++) {
                    if (msgs[index]) {
                        yield msgs[index].complete();
                    }
                }
                yield receiver.close();
            }
        }
    });
}
/**
 * Maximum wait duration for the expected event to happen = `10000 ms`(default value is 10 seconds)(= maxWaitTimeInMilliseconds)
 * Keep checking whether the predicate is true after every `1000 ms`(default value is 1 second) (= delayBetweenRetriesInMilliseconds)
 */
function checkWithTimeout(predicate, delayBetweenRetriesInMilliseconds = 1000, maxWaitTimeInMilliseconds = 10000) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const maxTime = Date.now() + maxWaitTimeInMilliseconds;
        while (Date.now() < maxTime) {
            if (predicate())
                return true;
            yield amqpCommon.delay(delayBetweenRetriesInMilliseconds);
        }
        return false;
    });
}

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$1 = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
function testPeekMsgsLength(client, expectedPeekLength) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const peekedMsgs = yield client.peek(expectedPeekLength + 1);
        should$1.equal(peekedMsgs.length, expectedPeekLength, "Unexpected number of msgs found when peeking");
    });
}
let ns$1;
let errorWasThrown;
let senderClient;
let receiverClient;
let deadLetterClient;
let sender$1;
let receiver$1;
const maxDeliveryCount = 10;
function beforeEachTest(senderType, receiverType, useSessions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // The tests in this file expect the env variables to contain the connection string and
        // the names of empty queue/topic/subscription that are to be tested
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$1 = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$1, senderType, receiverType);
        senderClient = clients.senderClient;
        receiverClient = clients.receiverClient;
        if (receiverClient instanceof QueueClient) {
            deadLetterClient = ns$1.createQueueClient(Namespace.getDeadLetterQueuePath(receiverClient.entityPath));
        }
        if (receiverClient instanceof SubscriptionClient) {
            deadLetterClient = ns$1.createSubscriptionClient(Namespace.getDeadLetterTopicPath(senderClient.entityPath, receiverClient.subscriptionName), receiverClient.subscriptionName);
        }
        yield purge(receiverClient, useSessions ? TestMessage.sessionId : undefined);
        yield purge(deadLetterClient);
        const peekedMsgs = yield receiverClient.peek();
        const receiverEntityType = receiverClient instanceof QueueClient ? "queue" : "topic";
        if (peekedMsgs.length) {
            chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
        }
        const peekedDeadMsgs = yield deadLetterClient.peek();
        if (peekedDeadMsgs.length) {
            chai$1.assert.fail(`Please use an empty dead letter ${receiverEntityType} for integration testing`);
        }
        sender$1 = senderClient.getSender();
        receiver$1 = useSessions
            ? yield receiverClient.getSessionReceiver({
                sessionId: TestMessage.sessionId
            })
            : receiverClient.getReceiver();
    });
}
function afterEachTest() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ns$1.close();
    });
}
describe("Batch Receiver - Settle message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest();
    }));
    function sendReceiveMsg(testMessages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield sender$1.send(testMessages);
            const msgs = yield receiver$1.receiveBatch(1);
            should$1.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$1.equal(msgs.length, 1, "Unexpected number of messages");
            should$1.equal(msgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$1.equal(msgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            should$1.equal(msgs[0].deliveryCount, 0, "DeliveryCount is different than expected");
            return msgs[0];
        });
    }
    function testComplete(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const msg = yield sendReceiveMsg(testMessages);
            yield msg.complete();
            yield testPeekMsgsLength(receiverClient, 0);
        });
    }
    it("Partitioned Queue: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testComplete();
        });
    });
    it("Partitioned Subscription: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testComplete();
        });
    });
    it("Unpartitioned Queue: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testComplete();
        });
    });
    it("Unpartitioned Subscription: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testComplete();
        });
    });
    it("Partitioned Queue with Sessions: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testComplete(true);
        });
    });
    it("Partitioned Subscription with Sessions: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testComplete(true);
        });
    });
    it("Unpartitioned Queue with Sessions: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testComplete(true);
        });
    });
    it("Unpartitioned Subscription with Sessions: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testComplete(true);
        });
    });
    function testAbandon(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const msg = yield sendReceiveMsg(testMessages);
            yield msg.abandon();
            yield testPeekMsgsLength(receiverClient, 1);
            const receivedMsgs = yield receiver$1.receiveBatch(1);
            should$1.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            should$1.equal(receivedMsgs[0].deliveryCount, 1, "DeliveryCount is different than expected");
            should$1.equal(receivedMsgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            yield receivedMsgs[0].complete();
            yield testPeekMsgsLength(receiverClient, 0);
        });
    }
    it("Partitioned Queue: abandon() retains message with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testAbandon();
        });
    });
    it("Partitioned Subscription: abandon() retains message with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testAbandon();
        });
    });
    it("Unpartitioned Queue: abandon() retains message with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testAbandon();
        });
    });
    it("Unpartitioned Subscription: abandon() retains message with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testAbandon();
        });
    });
    it("Partitioned Queue with Sessions: abandon() retains message with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testAbandon(true);
        });
    });
    it("Partitioned Subscription with Sessions: abandon() retains message with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testAbandon(true);
        });
    });
    it("Unpartitioned Queue with Sessions: abandon() retains message with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testAbandon(true);
        });
    });
    it("Unpartitioned Subscription with Sessions: abandon() retains message with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testAbandon(true);
        });
    });
    function testAbandonMsgsTillMaxDeliveryCount(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            yield sender$1.send(testMessages);
            let abandonMsgCount = 0;
            while (abandonMsgCount < maxDeliveryCount) {
                const receivedMsgs = yield receiver$1.receiveBatch(1);
                should$1.equal(receivedMsgs.length, 1, "Unexpected number of messages");
                should$1.equal(receivedMsgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
                should$1.equal(receivedMsgs[0].deliveryCount, abandonMsgCount, "DeliveryCount is different than expected");
                abandonMsgCount++;
                yield receivedMsgs[0].abandon();
            }
            yield testPeekMsgsLength(receiverClient, 0);
            const deadLetterMsgs = yield deadLetterClient.getReceiver().receiveBatch(1);
            should$1.equal(Array.isArray(deadLetterMsgs), true, "`ReceivedMessages` from Deadletter is not an array");
            should$1.equal(deadLetterMsgs.length, 1, "Unexpected number of messages");
            should$1.equal(deadLetterMsgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$1.equal(deadLetterMsgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            yield deadLetterMsgs[0].complete();
            yield testPeekMsgsLength(deadLetterClient, 0);
        });
    }
    it("Partitioned Queue: Multiple abandons until maxDeliveryCount.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testAbandonMsgsTillMaxDeliveryCount();
        });
    });
    it("Partitioned Subscription: Multiple abandons until maxDeliveryCount.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testAbandonMsgsTillMaxDeliveryCount();
        });
    });
    it("Unpartitioned Queue: Multiple abandons until maxDeliveryCount.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testAbandonMsgsTillMaxDeliveryCount();
        });
    });
    it("Unpartitioned Subscription: Multiple abandons until maxDeliveryCount.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testAbandonMsgsTillMaxDeliveryCount();
        });
    });
    it("Partitioned Queue with Sessions: Multiple abandons until maxDeliveryCount.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testAbandonMsgsTillMaxDeliveryCount(true);
        });
    });
    it("Partitioned Subscription with Sessions: Multiple abandons until maxDeliveryCount.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testAbandonMsgsTillMaxDeliveryCount(true);
        });
    });
    it("Unpartitioned Queue with Sessions: Multiple abandons until maxDeliveryCount.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testAbandonMsgsTillMaxDeliveryCount(true);
        });
    });
    it("Unpartitioned Subscription with Sessions: Multiple abandons until maxDeliveryCount.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testAbandonMsgsTillMaxDeliveryCount(true);
        });
    });
    function testDefer(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const msg = yield sendReceiveMsg(testMessages);
            if (!msg.sequenceNumber) {
                throw "Sequence Number can not be null";
            }
            const sequenceNumber = msg.sequenceNumber;
            yield msg.defer();
            const deferredMsgs = yield receiver$1.receiveDeferredMessage(sequenceNumber);
            if (!deferredMsgs) {
                throw "No message received for sequence number";
            }
            should$1.equal(deferredMsgs.body, testMessages.body, "MessageBody is different than expected");
            should$1.equal(deferredMsgs.messageId, testMessages.messageId, "MessageId is different than expected");
            should$1.equal(deferredMsgs.deliveryCount, 1, "DeliveryCount is different than expected");
            yield deferredMsgs.complete();
            yield testPeekMsgsLength(receiverClient, 0);
        });
    }
    it("Partitioned Queue: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testDefer();
        });
    });
    it("Partitioned Subscription: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testDefer();
        });
    });
    it("Partitioned Queue with Sessions: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testDefer(true);
        });
    });
    it("Partitioned Subscription with Sessions: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testDefer(true);
        });
    });
    it("Unpartitioned Queue: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testDefer();
        });
    });
    it("Unpartitioned Subscription: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testDefer();
        });
    });
    it("Unpartitioned Queue with Sessions: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testDefer(true);
        });
    });
    it("Unpartitioned Subscription with Sessions: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testDefer(true);
        });
    });
    function testDeadletter(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const msg = yield sendReceiveMsg(testMessages);
            yield msg.deadLetter();
            yield testPeekMsgsLength(receiverClient, 0);
            const deadLetterMsgs = yield deadLetterClient.getReceiver().receiveBatch(1);
            should$1.equal(Array.isArray(deadLetterMsgs), true, "`ReceivedMessages` from Deadletter is not an array");
            should$1.equal(deadLetterMsgs.length, 1, "Unexpected number of messages");
            should$1.equal(deadLetterMsgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$1.equal(deadLetterMsgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            yield deadLetterMsgs[0].complete();
            yield testPeekMsgsLength(deadLetterClient, 0);
        });
    }
    it("Partitioned Queue: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testDeadletter();
        });
    });
    it("Partitioned Subscription: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testDeadletter();
        });
    });
    it("Unpartitioned Queue: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testDeadletter();
        });
    });
    it("Unpartitioned Subscription: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testDeadletter();
        });
    });
    it("Partitioned Queue with Sessions: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testDeadletter(true);
        });
    });
    it("Partitioned Subscription with Sessions: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testDeadletter(true);
        });
    });
    it("Unpartitioned Queue with Sessions: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testDeadletter(true);
        });
    });
    it("Unpartitioned Subscription with Sessions: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testDeadletter(true);
        });
    });
});
describe("Batch Receiver - Settle deadlettered message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest();
    }));
    function deadLetterMessage(testMessage) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield sender$1.send(testMessage);
            const receivedMsgs = yield receiver$1.receiveBatch(1);
            should$1.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            should$1.equal(receivedMsgs[0].body, testMessage.body, "MessageBody is different than expected");
            should$1.equal(receivedMsgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            should$1.equal(receivedMsgs[0].deliveryCount, 0, "DeliveryCount is different than expected");
            yield receivedMsgs[0].deadLetter();
            yield testPeekMsgsLength(receiverClient, 0);
            const deadLetterMsgs = yield deadLetterClient.getReceiver().receiveBatch(1);
            should$1.equal(deadLetterMsgs.length, 1, "Unexpected number of messages");
            should$1.equal(deadLetterMsgs[0].body, testMessage.body, "MessageBody is different than expected");
            should$1.equal(deadLetterMsgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            should$1.equal(deadLetterMsgs[0].deliveryCount, 0, "DeliveryCount is different than expected");
            return deadLetterMsgs[0];
        });
    }
    function completeDeadLetteredMessage(testMessage, deadletterClient, expectedDeliverCount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const deadLetterMsgs = yield deadletterClient.getReceiver().receiveBatch(1);
            should$1.equal(deadLetterMsgs.length, 1, "Unexpected number of messages");
            should$1.equal(deadLetterMsgs[0].body, testMessage.body, "MessageBody is different than expected");
            should$1.equal(deadLetterMsgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            should$1.equal(deadLetterMsgs[0].deliveryCount, expectedDeliverCount, "DeliveryCount is different than expected");
            yield deadLetterMsgs[0].complete();
            yield testPeekMsgsLength(deadletterClient, 0);
        });
    }
    function testDeadletter(testMessage) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const deadLetterMsg = yield deadLetterMessage(testMessage);
            yield deadLetterMsg.deadLetter().catch((err) => {
                should$1.equal(err.name, "InvalidOperationError", "ErrorName is different than expected");
                errorWasThrown = true;
            });
            should$1.equal(errorWasThrown, true, "Error thrown flag must be true");
            yield completeDeadLetteredMessage(testMessage, deadLetterClient, 0);
        });
    }
    it("Partitioned Queue: Throws error when dead lettering a dead lettered message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testDeadletter(TestMessage.getSample());
        });
    });
    it("Partitioned Subscription: Throws error when dead lettering a dead lettered message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testDeadletter(TestMessage.getSample());
        });
    });
    it("Unpartitioned Queue: Throws error when dead lettering a dead lettered message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testDeadletter(TestMessage.getSample());
        });
    });
    it("Unpartitioned Subscription: Throws error when dead lettering a dead lettered message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testDeadletter(TestMessage.getSample());
        });
    });
    function testAbandon(testMessage) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const deadLetterMsg = yield deadLetterMessage(testMessage);
            yield deadLetterMsg.abandon();
            yield completeDeadLetteredMessage(testMessage, deadLetterClient, 0);
        });
    }
    it("Partitioned Queue: Abandon a message received from dead letter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testAbandon(TestMessage.getSample());
        });
    });
    it("Partitioned Subscription: Abandon a message received from dead letter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testAbandon(TestMessage.getSample());
        });
    });
    it("Unpartitioned Queue: Abandon a message received from dead letter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testAbandon(TestMessage.getSample());
        });
    });
    it("Unpartitioned Subscription: Abandon a message received from dead letter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testAbandon(TestMessage.getSample());
        });
    });
    function testDefer(testMessage) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const deadLetterMsg = yield deadLetterMessage(testMessage);
            if (!deadLetterMsg.sequenceNumber) {
                throw "Sequence Number can not be null";
            }
            const sequenceNumber = deadLetterMsg.sequenceNumber;
            yield deadLetterMsg.defer();
            const deferredMsgs = yield deadLetterClient
                .getReceiver()
                .receiveDeferredMessage(sequenceNumber);
            if (!deferredMsgs) {
                throw "No message received for sequence number";
            }
            should$1.equal(deferredMsgs.body, testMessage.body, "MessageBody is different than expected");
            should$1.equal(deferredMsgs.messageId, testMessage.messageId, "MessageId is different than expected");
            yield deferredMsgs.complete();
            yield testPeekMsgsLength(receiverClient, 0);
            yield testPeekMsgsLength(deadLetterClient, 0);
        });
    }
    it("Partitioned Queue: Defer a message received from dead letter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testDefer(TestMessage.getSample());
        });
    });
    it("Partitioned Subscription: Defer a message received from dead letter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testDefer(TestMessage.getSample());
        });
    });
    it("Unpartitioned Queue: Defer a message received from dead letter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testDefer(TestMessage.getSample());
        });
    });
    it("Unpartitioned Subscription: Defer a message received from dead letter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testDefer(TestMessage.getSample());
        });
    });
});
describe("Batch Receiver - Multiple ReceiveBatch calls", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest();
    }));
    // We use an empty queue/topic here so that the first receiveBatch call takes time to return
    function testParallelReceiveBatchCalls() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const firstBatchPromise = receiver$1.receiveBatch(1, 10);
            yield amqpCommon.delay(5000);
            const secondBatchPromise = receiver$1.receiveBatch(1, 10).catch((err) => {
                should$1.equal(err.name, "Error", "Error name is different than expected");
                errorWasThrown = true;
            });
            yield Promise.all([firstBatchPromise, secondBatchPromise]);
            should$1.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    }
    it("Partitioned Queue: Throws error when ReceiveBatch is called while the previous call is not done", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testParallelReceiveBatchCalls();
        });
    });
    it("Partitioned Subscription: Throws error when ReceiveBatch is called while the previous call is not done", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testParallelReceiveBatchCalls();
        });
    });
    it("Unpartitioned Queue: Throws error when ReceiveBatch is called while the previous call is not done", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testParallelReceiveBatchCalls();
        });
    });
    it("Unpartitioned Subscription: Throws error when ReceiveBatch is called while the previous call is not done", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testParallelReceiveBatchCalls();
        });
    });
    it("Partitioned Queue with Sessions: Throws error when ReceiveBatch is called while the previous call is not done", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testParallelReceiveBatchCalls();
        });
    });
    it("Partitioned Subscription with Sessions: Throws error when ReceiveBatch is called while the previous call is not done", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testParallelReceiveBatchCalls();
        });
    });
    it("Unpartitioned Queue with Sessions: Throws error when ReceiveBatch is called while the previous call is not done", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testParallelReceiveBatchCalls();
        });
    });
    it("Unpartitioned Subscription with Sessions: Throws error when ReceiveBatch is called while the previous call is not done", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testParallelReceiveBatchCalls();
        });
    });
    const messages = [
        {
            body: "hello1",
            messageId: `test message ${Math.random()}`,
            partitionKey: "dummy" // partitionKey is only for partitioned queue/subscrption, Unpartitioned queue/subscrption do not care about partitionKey.
        },
        {
            body: "hello2",
            messageId: `test message ${Math.random()}`,
            partitionKey: "dummy" // partitionKey is only for partitioned queue/subscrption, Unpartitioned queue/subscrption do not care about partitionKey.
        }
    ];
    const messageWithSessions = [
        {
            body: "hello1",
            messageId: `test message ${Math.random()}`,
            sessionId: TestMessage.sessionId
        },
        {
            body: "hello2",
            messageId: `test message ${Math.random()}`,
            sessionId: TestMessage.sessionId
        }
    ];
    // We test for mutilple receiveBatch specifically to ensure that batchingRecevier on a client is reused
    // See https://github.com/Azure/azure-service-bus-node/issues/31
    function testSequentialReceiveBatchCalls(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? messageWithSessions : messages;
            yield sender$1.sendBatch(testMessages);
            const msgs1 = yield receiver$1.receiveBatch(1);
            const msgs2 = yield receiver$1.receiveBatch(1);
            // Results are checked after both receiveBatches are done to ensure that the second call doesnt
            // affect the result from the first one.
            should$1.equal(Array.isArray(msgs1), true, "`ReceivedMessages` is not an array");
            should$1.equal(msgs1.length, 1, "Unexpected number of messages");
            should$1.equal(Array.isArray(msgs2), true, "`ReceivedMessages` is not an array");
            should$1.equal(msgs2.length, 1, "Unexpected number of messages");
            should$1.equal(testMessages.some((x) => x.messageId === msgs1[0].messageId), true, "MessageId is different than expected");
            should$1.equal(testMessages.some((x) => x.messageId === msgs2[0].messageId), true, "MessageId is different than expected");
            yield msgs1[0].complete();
            yield msgs2[0].complete();
        });
    }
    it("Partitioned Queue: Multiple sequential receiveBatch calls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testSequentialReceiveBatchCalls();
        });
    });
    it("Partitioned Subscription: Multiple sequential receiveBatch calls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testSequentialReceiveBatchCalls();
        });
    });
    it("Unpartitioned Queue: Multiple sequential receiveBatch calls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testSequentialReceiveBatchCalls();
        });
    });
    it("Unpartitioned Subscription: Multiple sequential receiveBatch calls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testSequentialReceiveBatchCalls();
        });
    });
    it("Partitioned Queue with Sessions: Multiple sequential receiveBatch calls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testSequentialReceiveBatchCalls(true);
        });
    });
    it("Partitioned Subscription with Sessions: Multiple sequential receiveBatch calls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testSequentialReceiveBatchCalls(true);
        });
    });
    it("Unpartitioned Queue with Sessions: Multiple sequential receiveBatch calls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testSequentialReceiveBatchCalls(true);
        });
    });
    it("Unpartitioned Subscription with Sessions: Multiple sequential receiveBatch calls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testSequentialReceiveBatchCalls(true);
        });
    });
});
describe("Batch Receiver - Others", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest();
    }));
    function testNoSettlement(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            yield sender$1.send(testMessages);
            let receivedMsgs = yield receiver$1.receiveBatch(1);
            should$1.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            should$1.equal(receivedMsgs[0].deliveryCount, 0, "DeliveryCount is different than expected");
            should$1.equal(receivedMsgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            yield testPeekMsgsLength(receiverClient, 1);
            receivedMsgs = yield receiver$1.receiveBatch(1);
            should$1.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            should$1.equal(receivedMsgs[0].deliveryCount, 1, "DeliveryCount is different than expected");
            should$1.equal(receivedMsgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            yield receivedMsgs[0].complete();
        });
    }
    it("Partitioned Queue: No settlement of the message is retained with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testNoSettlement();
        });
    });
    it("Partitioned Subscription: No settlement of the message is retained with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testNoSettlement();
        });
    });
    it("Unpartitioned Queue: No settlement of the message is retained with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testNoSettlement();
        });
    });
    it("Unpartitioned Subscription: No settlement of the message is retained with incremented deliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testNoSettlement();
        });
    });
    function testAskForMore(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            yield sender$1.send(testMessages);
            const receivedMsgs = yield receiver$1.receiveBatch(2);
            should$1.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            should$1.equal(receivedMsgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$1.equal(receivedMsgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            yield receivedMsgs[0].complete();
            yield testPeekMsgsLength(receiverClient, 0);
        });
    }
    it("Partitioned Queue: Receive n messages but queue only has m messages, where m < n", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testAskForMore();
        });
    });
    it("Partitioned Subscription: Receive n messages but subscription only has m messages, where m < n", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testAskForMore();
        });
    });
    it("Unpartitioned Queue: Receive n messages but queue only has m messages, where m < n", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testAskForMore();
        });
    });
    it("Unpartitioned Subscription: Receive n messages but subscription only has m messages, where m < n", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testAskForMore();
        });
    });
    it("Partitioned Queue with Sessions: Receive n messages but queue only has m messages, where m < n", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testAskForMore(true);
        });
    });
    it("Partitioned Subscription with Sessions: Receive n messages but subscription only has m messages, where m < n", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testAskForMore(true);
        });
    });
    it("Unpartitioned Queue with Sessions: Receive n messages but queue only has m messages, where m < n", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testAskForMore(true);
        });
    });
    it("Unpartitioned Subscription with Sessions: Receive n messages but subscription only has m messages, where m < n", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testAskForMore(true);
        });
    });
});

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$2 = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
function testPeekMsgsLength$1(client, expectedPeekLength) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const peekedMsgs = yield client.peek(expectedPeekLength + 1);
        should$2.equal(peekedMsgs.length, expectedPeekLength, "Unexpected number of msgs found when peeking");
    });
}
let ns$2;
let senderClient$1;
let receiverClient$1;
let deadLetterClient$1;
let sender$2;
let receiver$2;
function beforeEachTest$1(senderType, receiverType, useSessions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // The tests in this file expect the env variables to contain the connection string and
        // the names of empty queue/topic/subscription that are to be tested
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$2 = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$2, senderType, receiverType);
        senderClient$1 = clients.senderClient;
        receiverClient$1 = clients.receiverClient;
        if (receiverClient$1 instanceof QueueClient) {
            deadLetterClient$1 = ns$2.createQueueClient(Namespace.getDeadLetterQueuePath(receiverClient$1.entityPath));
        }
        if (receiverClient$1 instanceof SubscriptionClient) {
            deadLetterClient$1 = ns$2.createSubscriptionClient(Namespace.getDeadLetterTopicPath(senderClient$1.entityPath, receiverClient$1.subscriptionName), receiverClient$1.subscriptionName);
        }
        yield purge(receiverClient$1, useSessions ? TestMessage.sessionId : undefined);
        yield purge(deadLetterClient$1);
        const peekedMsgs = yield receiverClient$1.peek();
        const receiverEntityType = receiverClient$1 instanceof QueueClient ? "queue" : "topic";
        if (peekedMsgs.length) {
            chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
        }
        const peekedDeadMsgs = yield deadLetterClient$1.peek();
        if (peekedDeadMsgs.length) {
            chai$1.assert.fail(`Please use an empty dead letter ${receiverEntityType} for integration testing`);
        }
        sender$2 = senderClient$1.getSender();
        receiver$2 = useSessions
            ? yield receiverClient$1.getSessionReceiver({
                sessionId: TestMessage.sessionId
            })
            : receiverClient$1.getReceiver();
    });
}
function afterEachTest$1() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ns$2.close();
    });
}
function deferMessage(testMessages) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield sender$2.send(testMessages);
        const receivedMsgs = yield receiver$2.receiveBatch(1);
        should$2.equal(receivedMsgs.length, 1, "Unexpected number of messages");
        should$2.equal(receivedMsgs[0].body, testMessages.body, "MessageBody is different than expected");
        should$2.equal(receivedMsgs[0].deliveryCount, 0, "DeliveryCount is different than expected");
        should$2.equal(receivedMsgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
        if (!receivedMsgs[0].sequenceNumber) {
            throw "Sequence Number can not be null";
        }
        const sequenceNumber = receivedMsgs[0].sequenceNumber;
        yield receivedMsgs[0].defer();
        const deferredMsgs = yield receiver$2.receiveDeferredMessage(sequenceNumber);
        if (!deferredMsgs) {
            throw "No message received for sequence number";
        }
        should$2.equal(deferredMsgs.body, testMessages.body, "MessageBody is different than expected");
        should$2.equal(deferredMsgs.messageId, testMessages.messageId, "MessageId is different than expected");
        should$2.equal(deferredMsgs.deliveryCount, 1, "DeliveryCount is different than expected");
        return deferredMsgs;
    });
}
function completeDeferredMessage(sequenceNumber, expectedDeliverCount, testMessages, useSessions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield testPeekMsgsLength$1(receiverClient$1, 1);
        const deferredMsg = yield receiver$2.receiveDeferredMessage(sequenceNumber);
        if (!deferredMsg) {
            throw "No message received for sequence number";
        }
        should$2.equal(deferredMsg.body, testMessages.body, "MessageBody is different than expected");
        should$2.equal(deferredMsg.deliveryCount, expectedDeliverCount, "DeliveryCount is different than expected");
        should$2.equal(deferredMsg.messageId, testMessages.messageId, "MessageId is different than expected");
        yield deferredMsg.complete();
        yield testPeekMsgsLength$1(receiverClient$1, 0);
    });
}
describe("Abandon/Defer/Deadletter deferred message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$1();
    }));
    function testAbandon(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const deferredMsg = yield deferMessage(testMessages);
            const sequenceNumber = deferredMsg.sequenceNumber;
            if (!sequenceNumber) {
                throw "Sequence Number can not be null";
            }
            yield deferredMsg.abandon();
            yield completeDeferredMessage(sequenceNumber, 2, testMessages);
        });
    }
    it("Partitioned Queue: Abandoning a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testAbandon();
        });
    });
    it("Partitioned Subscription: Abandoning a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testAbandon();
        });
    });
    it("Partitioned Queue with Sessions: Abandoning a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testAbandon(true);
        });
    });
    it("Partitioned Subscription with Sessions: Abandoning a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testAbandon(true);
        });
    });
    it("Unpartitioned Queue: Abandoning a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testAbandon();
        });
    });
    it("Unpartitioned Subscription: Abandoning a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testAbandon();
        });
    });
    it("Unpartitioned Queue with Sessions:: Abandoning a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testAbandon(true);
        });
    });
    it("Unpartitioned Subscription with Sessions:: Abandoning a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testAbandon(true);
        });
    });
    function testDefer(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const deferredMsg = yield deferMessage(testMessages);
            const sequenceNumber = deferredMsg.sequenceNumber;
            if (!sequenceNumber) {
                throw "Sequence Number can not be null";
            }
            yield deferredMsg.defer();
            yield completeDeferredMessage(sequenceNumber, 2, testMessages);
        });
    }
    it("Partitioned Queue: Deferring a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testDefer();
        });
    });
    it("Partitioned Subscription: Deferring a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testDefer();
        });
    });
    it("Partitioned Queue with Sessions: Deferring a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testDefer(true);
        });
    });
    it("Partitioned Subscription with Sessions: Deferring a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testDefer(true);
        });
    });
    it("Unpartitioned Queue: Deferring a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testDefer();
        });
    });
    it("Unpartitioned Subscription: Deferring a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testDefer();
        });
    });
    it("Unpartitioned Queue with Sessions: Deferring a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testDefer(true);
        });
    });
    it("Unpartitioned Subscription with Sessions: Deferring a deferred message puts it back to the deferred queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testDefer(true);
        });
    });
    function testDeadletter(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const deferredMsg = yield deferMessage(testMessages);
            yield deferredMsg.deadLetter();
            yield testPeekMsgsLength$1(receiverClient$1, 0);
            const deadLetterMsgs = yield deadLetterClient$1.getReceiver().receiveBatch(1);
            should$2.equal(deadLetterMsgs.length, 1, "Unexpected number of messages");
            should$2.equal(deadLetterMsgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$2.equal(deadLetterMsgs[0].deliveryCount, 1, "DeliveryCount is different than expected");
            should$2.equal(deadLetterMsgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            yield deadLetterMsgs[0].complete();
            yield testPeekMsgsLength$1(deadLetterClient$1, 0);
        });
    }
    it("Partitioned Queue: Deadlettering a deferred message moves it to dead letter queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testDeadletter();
        });
    });
    it("Partitioned Subscription: Deadlettering a deferred message moves it to dead letter queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testDeadletter();
        });
    });
    it("Partitioned Queue with Sessions: Deadlettering a deferred message moves it to dead letter queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testDeadletter(true);
        });
    });
    it("Partitioned Subscription with Sessions: Deadlettering a deferred message moves it to dead letter queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testDeadletter(true);
        });
    });
    it("Unpartitioned Queue: Deadlettering a deferred message moves it to dead letter queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testDeadletter();
        });
    });
    it("Unpartitioned Subscription: Deadlettering a deferred message moves it to dead letter queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testDeadletter();
        });
    });
    it("Unpartitioned Queue with Sessions: Deadlettering a deferred message moves it to dead letter queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testDeadletter(true);
        });
    });
    it("Unpartitioned Subscription with Sessions: Deadlettering a deferred message moves it to dead letter queue.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$1(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testDeadletter(true);
        });
    });
});

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$3 = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
const aadServiceBusAudience = "https://servicebus.azure.net/";
function testFalsyValues(testFn) {
    [undefined, "", 0].forEach(function (value) {
        testFn(value);
    });
}
describe("Create Namespace", function () {
    it("throws error when there is no connection string", function () {
        testFalsyValues(function (value) {
            const test = function () {
                Namespace.createFromConnectionString(value);
            };
            test.should.throw(Error, "'connectionString' is a required parameter and must be of type: 'string'.");
        });
    });
    it("creates an Namespace from a connection string", function () {
        const namespace = Namespace.createFromConnectionString("Endpoint=sb://a;SharedAccessKeyName=b;SharedAccessKey=c;EntityPath=d");
        namespace.should.be.an.instanceof(Namespace);
        should$3.equal(namespace.name, "sb://a/", "Name of the namespace is different than expected");
    });
});
describe("Clients with no name", function () {
    let namespace;
    beforeEach(() => {
        namespace = Namespace.createFromConnectionString("Endpoint=sb://a;SharedAccessKeyName=b;SharedAccessKey=c;EntityPath=d");
    });
    afterEach(() => {
        return namespace.close();
    });
    it("throws error when creating queue client with no name", function () {
        testFalsyValues(function (value) {
            const test = function () {
                namespace.createQueueClient(value);
            };
            test.should.throw(Error, "'queueName' is a required parameter and must be of type 'string'.");
        });
    });
    it("throws error when creating topic client with no name", function () {
        testFalsyValues(function (value) {
            const test = function () {
                namespace.createTopicClient(value);
            };
            test.should.throw(Error, "'topicName' is a required parameter and must be of type 'string'.");
        });
    });
    it("throws error when creating subscription client with no topic name", function () {
        testFalsyValues(function (value) {
            const test = function () {
                namespace.createSubscriptionClient(value, "some-name");
            };
            test.should.throw(Error, "'topicName' is a required parameter and must be of type 'string'.");
        });
    });
    it("throws error when creating subscription client with no subscription name", function () {
        testFalsyValues(function (value) {
            const test = function () {
                namespace.createSubscriptionClient("some-name", value);
            };
            test.should.throw(Error, "'subscriptionName' is a required parameter and must be of type 'string'.");
        });
    });
});
describe("Errors with non existing Namespace", function () {
    let namespace;
    let errorWasThrown;
    beforeEach(() => {
        namespace = Namespace.createFromConnectionString("Endpoint=sb://a;SharedAccessKeyName=b;SharedAccessKey=c;EntityPath=d");
        errorWasThrown = false;
    });
    afterEach(() => {
        return namespace.close();
    });
    const testError = (err) => {
        should$3.equal(err.name, "ServiceCommunicationError", "ErrorName is different than expected");
        should$3.equal(err.message, "getaddrinfo ENOTFOUND a a:5671", "ErrorMessage is different than expected");
        errorWasThrown = true;
    };
    it("throws error when sending data via a queueClient to a non existing namespace", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = namespace.createQueueClient("some-name");
            yield client
                .getSender()
                .send({ body: "hello" })
                .catch(testError);
            should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("throws error when sending data via a topicClient to a non existing namespace", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = namespace.createTopicClient("some-name");
            yield client
                .getSender()
                .send({ body: "hello" })
                .catch(testError);
            should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("throws error when sending batch data via a queueClient to a non existing namespace", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = namespace.createQueueClient("some-name");
            yield client
                .getSender()
                .send({ body: "hello" })
                .catch(testError);
            should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("throws error when sending batch data via a topicClient to a non existing namespace", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = namespace.createTopicClient("some-name");
            yield client
                .getSender()
                .send({ body: "hello" })
                .catch(testError);
            should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("throws error when receving batch data via a queueClient from a non existing namespace", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = namespace.createQueueClient("some-name");
            yield client
                .getReceiver()
                .receiveBatch(10)
                .catch(testError);
            should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("throws error when receving batch data via a subscriptionClient from a non existing namespace", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = namespace.createSubscriptionClient("some-topic-name", "some-subscription-name");
            yield client
                .getReceiver()
                .receiveBatch(10)
                .catch(testError);
            should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("throws error when receving streaming data via a queueClient from a non existing namespace", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = namespace.createQueueClient("some-name");
            const onMessage = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                throw "onMessage should not have been called when receive call is made from a non existing namespace";
            });
            client.getReceiver().receive(onMessage, testError);
            yield amqpCommon.delay(3000);
            yield client.close();
            should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
});
describe("Errors with non existing Queue/Topic/Subscription", function () {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let namespace;
        let errorWasThrown;
        beforeEach(() => {
            if (!process.env.SERVICEBUS_CONNECTION_STRING) {
                throw "define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.";
            }
            namespace = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
            errorWasThrown = false;
        });
        afterEach(() => {
            return namespace.close();
        });
        const testError = (err, entityPath) => {
            should$3.equal(err.name, "MessagingEntityNotFoundError", "ErrorName is different than expected");
            should$3.equal(err.message.startsWith(`The messaging entity '${namespace.name}${entityPath}' could not be found.`), true);
            errorWasThrown = true;
        };
        it("throws error when sending data to a non existing queue", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const client = namespace.createQueueClient("some-name");
                yield client
                    .getSender()
                    .send({ body: "hello" })
                    .catch((err) => testError(err, "some-name"));
                should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
            });
        });
        it("throws error when sending data to a non existing topic", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const client = namespace.createTopicClient("some-name");
                yield client
                    .getSender()
                    .send({ body: "hello" })
                    .catch((err) => testError(err, "some-name"));
                should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
            });
        });
        it("throws error when sending batch data to a non existing queue", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const client = namespace.createQueueClient("some-name");
                yield client
                    .getSender()
                    .send({ body: "hello" })
                    .catch((err) => testError(err, "some-name"));
                should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
            });
        });
        it("throws error when sending batch data to a non existing topic", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const client = namespace.createTopicClient("some-name");
                yield client
                    .getSender()
                    .send({ body: "hello" })
                    .catch((err) => testError(err, "some-name"));
                should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
            });
        });
        it("throws error when receiving batch data from a non existing queue", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const client = namespace.createQueueClient("some-name");
                yield client
                    .getReceiver()
                    .receiveBatch(1)
                    .catch((err) => testError(err, "some-name"));
                should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
            });
        });
        it("throws error when receiving batch data from a non existing subscription", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const client = namespace.createSubscriptionClient("some-topic-name", "some-subscription-name");
                yield client
                    .getReceiver()
                    .receiveBatch(1)
                    .catch((err) => testError(err, "some-topic-name/Subscriptions/some-subscription-name"));
                should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
            });
        });
        it("throws error when receving streaming data from a non existing queue", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const client = namespace.createQueueClient("some-name");
                const onMessage = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    throw "onMessage should not have been called when receive call is made from a non existing namespace";
                });
                client.getReceiver().receive(onMessage, (err) => testError(err, "some-name"));
                yield amqpCommon.delay(3000);
                yield client.close();
                should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
            });
        });
        it("throws error when receving streaming data from a non existing subscription", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const client = namespace.createSubscriptionClient("some-topic-name", "some-subscription-name");
                const onMessage = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    throw "onMessage should not have been called when receive call is made from a non existing namespace";
                });
                client
                    .getReceiver()
                    .receive(onMessage, (err) => testError(err, "some-topic-name/Subscriptions/some-subscription-name"));
                yield amqpCommon.delay(3000);
                yield client.close();
                should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
            });
        });
    });
});
describe("Test createFromAadTokenCredentials", function () {
    let namespace;
    let tokenCreds;
    let errorWasThrown = false;
    if (!process.env.SERVICEBUS_CONNECTION_STRING) {
        throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
    }
    const serviceBusEndpoint = (process.env.SERVICEBUS_CONNECTION_STRING.match("Endpoint=sb://((.*).servicebus.windows.net)") || "")[1];
    function testCreateFromAadTokenCredentials(host, tokenCreds) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = TestMessage.getSample();
            namespace = Namespace.createFromAadTokenCredentials(host, tokenCreds);
            namespace.should.be.an.instanceof(Namespace);
            const clients = yield getSenderReceiverClients(namespace, ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            const sender = clients.senderClient.getSender();
            const receiver = clients.receiverClient.getReceiver();
            yield sender.send(testMessages);
            const msgs = yield receiver.receiveBatch(1);
            should$3.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$3.equal(msgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$3.equal(msgs.length, 1, "Unexpected number of messages");
        });
    }
    it("throws error for an invalid host", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const env = getEnvVars();
            tokenCreds = yield msRestAzure.loginWithServicePrincipalSecret(env.clientId, env.clientSecret, env.tenantId, {
                tokenAudience: aadServiceBusAudience
            });
            yield testCreateFromAadTokenCredentials("", tokenCreds).catch((err) => {
                errorWasThrown = true;
                should$3.equal(err.message, "'host' is a required parameter and must be of type: 'string'.", "ErrorMessage is different than expected");
            });
            should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("throws error for invalid tokenCredentials", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testCreateFromAadTokenCredentials(serviceBusEndpoint, "").catch((err) => {
                errorWasThrown = true;
                should$3.equal(err.message, "'credentials' is a required parameter and must be an instance of ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials | MSITokenCredentials.", "ErrorMessage is different than expected");
            });
            should$3.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("sends a message to the ServiceBus entity", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const env = getEnvVars();
            tokenCreds = yield msRestAzure.loginWithServicePrincipalSecret(env.clientId, env.clientSecret, env.tenantId, {
                tokenAudience: aadServiceBusAudience
            });
            yield testCreateFromAadTokenCredentials(serviceBusEndpoint, tokenCreds);
            yield namespace.close();
        });
    });
});
describe("Errors after close()", function () {
    let namespace;
    let senderClient;
    let receiverClient;
    let sender;
    let receiver;
    afterEach(() => {
        return namespace.close();
    });
    function beforeEachTest(senderType, receiverType, entityToClose, useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!process.env.SERVICEBUS_CONNECTION_STRING) {
                throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
            }
            namespace = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
            const clients = yield getSenderReceiverClients(namespace, senderType, receiverType);
            senderClient = clients.senderClient;
            receiverClient = clients.receiverClient;
            yield purge(receiverClient, useSessions ? TestMessage.sessionId : undefined);
            const peekedMsgs = yield receiverClient.peek();
            const receiverEntityType = receiverClient instanceof QueueClient ? "queue" : "topic";
            if (peekedMsgs.length) {
                chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
            }
            sender = senderClient.getSender();
            receiver = useSessions
                ? yield receiverClient.getSessionReceiver({
                    sessionId: TestMessage.sessionId
                })
                : receiverClient.getReceiver();
            // Normal send/receive
            const testMessage = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            yield sender.send(testMessage);
            const receivedMsgs = yield receiver.receiveBatch(1, 3);
            should$3.equal(receivedMsgs.length, 1, "Unexpected number of messages received");
            yield receivedMsgs[0].complete();
            // close(), so that we can then test the resulting error.
            switch (entityToClose) {
                case "namespace":
                    yield namespace.close();
                    break;
                case "senderClient":
                    yield senderClient.close();
                    break;
                case "receiverClient":
                    yield receiverClient.close();
                    break;
                case "sender":
                    yield sender.close();
                    break;
                case "receiver":
                    yield receiver.close();
                    break;
                default:
                    break;
            }
        });
    }
    /**
     * Tests that each feature of the sender throws expected error
     */
    function testSender(expectedErrorMsg) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSample();
            let errorSend = "";
            yield sender.send(testMessage).catch((err) => {
                errorSend = err.message;
            });
            should$3.equal(errorSend, expectedErrorMsg, "Expected error not thrown for send()");
            let errorSendBatch = "";
            yield sender.sendBatch([testMessage]).catch((err) => {
                errorSendBatch = err.message;
            });
            should$3.equal(errorSendBatch, expectedErrorMsg, "Expected error not thrown for sendBatch()");
            let errorScheduleMsg = "";
            yield sender.scheduleMessage(new Date(Date.now() + 30000), testMessage).catch((err) => {
                errorScheduleMsg = err.message;
            });
            should$3.equal(errorScheduleMsg, expectedErrorMsg, "Expected error not thrown for scheduleMessage()");
            let errorScheduleMsgs = "";
            yield sender.scheduleMessages(new Date(Date.now() + 30000), [testMessage]).catch((err) => {
                errorScheduleMsgs = err.message;
            });
            should$3.equal(errorScheduleMsgs, expectedErrorMsg, "Expected error not thrown for scheduleMessages()");
            let errorCancelMsg = "";
            yield sender.cancelScheduledMessage(Long.ZERO).catch((err) => {
                errorCancelMsg = err.message;
            });
            should$3.equal(errorCancelMsg, expectedErrorMsg, "Expected error not thrown for cancelScheduledMessage()");
            let errorCancelMsgs = "";
            yield sender.cancelScheduledMessages([Long.ZERO]).catch((err) => {
                errorCancelMsgs = err.message;
            });
            should$3.equal(errorCancelMsgs, expectedErrorMsg, "Expected error not thrown for cancelScheduledMessages()");
        });
    }
    /**
     * Tests that each feature of the senderClient throws expected error
     */
    function testSenderClient(expectedErrorMsg) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errorNewSender = "";
            try {
                senderClient.getSender();
            }
            catch (err) {
                errorNewSender = err.message;
            }
            should$3.equal(errorNewSender, expectedErrorMsg, "Expected error not thrown for getSender()");
        });
    }
    /**
     * Tests that each feature of the receiver throws expected error
     */
    function testReceiver(expectedErrorMsg, useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errorReceiveBatch = "";
            yield receiver.receiveBatch(1, 1).catch((err) => {
                errorReceiveBatch = err.message;
            });
            should$3.equal(errorReceiveBatch, expectedErrorMsg, "Expected error not thrown for receiveBatch()");
            let errorReceiveStream = "";
            try {
                receiver.receive(() => Promise.resolve(), (e) => console.log(e));
            }
            catch (err) {
                errorReceiveStream = err.message;
            }
            should$3.equal(errorReceiveStream, expectedErrorMsg, "Expected error not thrown for receive()");
            let errorDeferredMsg = "";
            yield receiver.receiveDeferredMessage(Long.ZERO).catch((err) => {
                errorDeferredMsg = err.message;
            });
            should$3.equal(errorDeferredMsg, expectedErrorMsg, "Expected error not thrown for receiveDeferredMessage()");
            let errorDeferredMsgs = "";
            yield receiver.receiveDeferredMessage(Long.ZERO).catch((err) => {
                errorDeferredMsgs = err.message;
            });
            should$3.equal(errorDeferredMsgs, expectedErrorMsg, "Expected error not thrown for receiveDeferredMessages()");
            let errorRenewLock = "";
            yield receiver.renewLock("randomLockToken").catch((err) => {
                errorRenewLock = err.message;
            });
            should$3.equal(errorRenewLock, expectedErrorMsg, "Expected error not thrown for renewLock()");
        });
    }
    /**
     * Tests that each feature of the receiverClient throws expected error
     */
    function testReceiverClient(expectedErrorMsg, useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errorNewReceiver = "";
            try {
                useSessions
                    ? yield receiverClient.getSessionReceiver({
                        sessionId: TestMessage.sessionId
                    })
                    : receiverClient.getReceiver();
            }
            catch (err) {
                errorNewReceiver = err.message;
            }
            should$3.equal(errorNewReceiver, expectedErrorMsg, "Expected error not thrown for getReceiver()");
            let errorPeek = "";
            yield receiverClient.peek().catch((err) => {
                errorPeek = err.message;
            });
            should$3.equal(errorPeek, expectedErrorMsg, "Expected error not thrown for peek() from receiverClient");
            let errorPeekBySequence = "";
            yield receiverClient.peekBySequenceNumber(Long.ZERO).catch((err) => {
                errorPeekBySequence = err.message;
            });
            should$3.equal(errorPeekBySequence, expectedErrorMsg, "Expected error not thrown for peekBySequenceNumber() from receiverClient");
        });
    }
    /**
     * Tests that each feature of the receiver client with sessions throws expected error
     */
    function testSessionReceiver(expectedErrorMsg) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testReceiver(expectedErrorMsg, true);
            const sessionReceiver = receiver;
            let errorPeek = "";
            yield sessionReceiver.peek().catch((err) => {
                errorPeek = err.message;
            });
            should$3.equal(errorPeek, expectedErrorMsg, "Expected error not thrown for peek() from sessionReceiver");
            let errorPeekBySequence = "";
            yield sessionReceiver.peekBySequenceNumber(Long.ZERO).catch((err) => {
                errorPeekBySequence = err.message;
            });
            should$3.equal(errorPeekBySequence, expectedErrorMsg, "Expected error not thrown for peekBySequenceNumber() from sessionReceiver");
            let errorGetState = "";
            yield sessionReceiver.getState().catch((err) => {
                errorGetState = err.message;
            });
            should$3.equal(errorGetState, expectedErrorMsg, "Expected error not thrown for getState()");
            let errorSetState = "";
            yield sessionReceiver.setState("state!!").catch((err) => {
                errorSetState = err.message;
            });
            should$3.equal(errorSetState, expectedErrorMsg, "Expected error not thrown for setState()");
        });
    }
    /**
     * Tests that each feature of the topic filters throws expected error
     */
    function testRules(expectedErrorMsg) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const subscriptionClient = receiverClient;
            let errorAddRule = "";
            yield subscriptionClient.addRule("myRule", true).catch((err) => {
                errorAddRule = err.message;
            });
            should$3.equal(errorAddRule, expectedErrorMsg, "Expected error not thrown for addRule()");
            let errorRemoveRule = "";
            yield subscriptionClient.removeRule("myRule").catch((err) => {
                errorRemoveRule = err.message;
            });
            should$3.equal(errorRemoveRule, expectedErrorMsg, "Expected error not thrown for removeRule()");
            let errorGetRules = "";
            yield subscriptionClient.getRules().catch((err) => {
                errorGetRules = err.message;
            });
            should$3.equal(errorGetRules, expectedErrorMsg, "Expected error not thrown for getRule()");
        });
    }
    describe("Errors after close() on namespace", function () {
        const entityToClose = "namespace";
        const expectedErrorMsg = "The underlying AMQP connection is closed.";
        it("Partitioned Queue: errors after close() on namespace", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue, entityToClose);
                yield testSender(expectedErrorMsg);
                yield testSenderClient(expectedErrorMsg);
                yield testReceiver(expectedErrorMsg);
                yield testReceiverClient(expectedErrorMsg);
            });
        });
        it("Partitioned Queue with sessions: errors after close() on namespace", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, entityToClose, true);
                yield testSender(expectedErrorMsg);
                yield testSenderClient(expectedErrorMsg);
                yield testSessionReceiver(expectedErrorMsg);
                yield testReceiverClient(expectedErrorMsg, true);
            });
        });
        it("Partitioned Topic/Subscription: errors after close() on namespace", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription, entityToClose);
                yield testSender(expectedErrorMsg);
                yield testSenderClient(expectedErrorMsg);
                yield testReceiver(expectedErrorMsg);
                yield testReceiverClient(expectedErrorMsg);
                yield testRules(expectedErrorMsg);
            });
        });
        it("Partitioned Topic/Subscription with sessions: errors after close() on namespace", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, entityToClose, true);
                yield testSender(expectedErrorMsg);
                yield testSenderClient(expectedErrorMsg);
                yield testSessionReceiver(expectedErrorMsg);
                yield testReceiverClient(expectedErrorMsg, true);
                yield testRules(expectedErrorMsg);
            });
        });
        it("Unpartitioned Queue: errors after close() on namespace", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue, entityToClose);
                yield testSender(expectedErrorMsg);
                yield testSenderClient(expectedErrorMsg);
                yield testReceiver(expectedErrorMsg);
                yield testReceiverClient(expectedErrorMsg);
            });
        });
        it("Unpartitioned Queue with sessions: errors after close() on namespace", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, entityToClose, true);
                yield testSender(expectedErrorMsg);
                yield testSenderClient(expectedErrorMsg);
                yield testSessionReceiver(expectedErrorMsg);
                yield testReceiverClient(expectedErrorMsg, true);
            });
        });
        it("Unpartitioned Topic/Subscription: errors after close() on namespace", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription, entityToClose);
                yield testSender(expectedErrorMsg);
                yield testSenderClient(expectedErrorMsg);
                yield testReceiver(expectedErrorMsg);
                yield testReceiverClient(expectedErrorMsg);
                yield testRules(expectedErrorMsg);
            });
        });
        it("Unpartitioned Topic/Subscription with sessions: errors after close() on namespace", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, entityToClose, true);
                yield testSender(expectedErrorMsg);
                yield testSenderClient(expectedErrorMsg);
                yield testSessionReceiver(expectedErrorMsg);
                yield testReceiverClient(expectedErrorMsg, true);
                yield testRules(expectedErrorMsg);
            });
        });
        it("Create Queue/Topic/Subscription clients throws error after namespace.close()", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // beforeEachTest() can be run for any entity type, we need it only to ensure that the
                // connection is indeed opened
                yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue, entityToClose);
                let errorCreateQueueClient = "";
                try {
                    namespace.createQueueClient("random-name");
                }
                catch (err) {
                    errorCreateQueueClient = err.message;
                }
                should$3.equal(errorCreateQueueClient, expectedErrorMsg, "Expected error not thrown for createQueueClient()");
                let errorCreateTopicClient = "";
                try {
                    namespace.createTopicClient("random-name");
                }
                catch (err) {
                    errorCreateTopicClient = err.message;
                }
                should$3.equal(errorCreateTopicClient, expectedErrorMsg, "Expected error not thrown for createTopicClient()");
                let errorCreateSubscriptionClient = "";
                try {
                    namespace.createSubscriptionClient("random-name", "random-name");
                }
                catch (err) {
                    errorCreateSubscriptionClient = err.message;
                }
                should$3.equal(errorCreateSubscriptionClient, expectedErrorMsg, "Expected error not thrown for createubscriptionClient()");
            });
        });
    });
    describe("Errors after close() on senderClient", function () {
        const entityToClose = "senderClient";
        const expectedSenderErrorMsg = "The sender has been closed and can no longer be used.";
        const expectedQueueClientErrorMsg = "The queueClient has been closed and can no longer be used.";
        const expectedTopicClientErrorMsg = "The topicClient has been closed and can no longer be used.";
        it("Partitioned Queue: errors after close() on senderClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue, entityToClose);
                yield testSender(expectedSenderErrorMsg);
                yield testSenderClient(expectedQueueClientErrorMsg);
            });
        });
        it("Partitioned Queue with sessions: errors after close() on senderClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, entityToClose, true);
                yield testSender(expectedSenderErrorMsg);
                yield testSenderClient(expectedQueueClientErrorMsg);
            });
        });
        it("Partitioned Topic/Subscription: errors after close() on senderClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription, entityToClose);
                yield testSender(expectedSenderErrorMsg);
                yield testSenderClient(expectedTopicClientErrorMsg);
            });
        });
        it("Partitioned Topic/Subscription with sessions: errors after close() on senderClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, entityToClose, true);
                yield testSender(expectedSenderErrorMsg);
                yield testSenderClient(expectedTopicClientErrorMsg);
            });
        });
        it("Unpartitioned Queue: errors after close() on senderClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue, entityToClose);
                yield testSender(expectedSenderErrorMsg);
                yield testSenderClient(expectedQueueClientErrorMsg);
            });
        });
        it("Unpartitioned Queue with sessions: errors after close() on senderClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, entityToClose, true);
                yield testSender(expectedSenderErrorMsg);
                yield testSenderClient(expectedQueueClientErrorMsg);
            });
        });
        it("Unpartitioned Topic/Subscription: errors after close() on senderClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription, entityToClose);
                yield testSender(expectedSenderErrorMsg);
                yield testSenderClient(expectedTopicClientErrorMsg);
            });
        });
        it("Unpartitioned Topic/Subscription with sessions: errors after close() on senderClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, entityToClose, true);
                yield testSender(expectedSenderErrorMsg);
                yield testSenderClient(expectedTopicClientErrorMsg);
            });
        });
    });
    describe("Errors after close() on receiverClient", function () {
        const entityToClose = "receiverClient";
        const expectedReceiverErrorMsg = "The receiver has been closed and can no longer be used.";
        const expectedQueueClientErrorMsg = "The queueClient has been closed and can no longer be used.";
        const expectedSubscriptionClientErrorMsg = "The subscriptionClient has been closed and can no longer be used.";
        it("Partitioned Queue: errors after close() on receiverClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue, entityToClose);
                yield testReceiver(expectedReceiverErrorMsg);
                yield testReceiverClient(expectedQueueClientErrorMsg);
            });
        });
        it("Partitioned Queue with sessions: errors after close() on receiverClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, entityToClose, true);
                yield testSessionReceiver(expectedReceiverErrorMsg);
                yield testReceiverClient(expectedQueueClientErrorMsg, true);
            });
        });
        it("Partitioned Topic/Subscription: errors after close() on receiverClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription, entityToClose);
                yield testReceiver(expectedReceiverErrorMsg);
                yield testReceiverClient(expectedSubscriptionClientErrorMsg);
                yield testRules(expectedSubscriptionClientErrorMsg);
            });
        });
        it("Partitioned Topic/Subscription with sessions: errors after close() on receiverClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, entityToClose, true);
                yield testSessionReceiver(expectedReceiverErrorMsg);
                yield testReceiverClient(expectedSubscriptionClientErrorMsg, true);
                yield testRules(expectedSubscriptionClientErrorMsg);
            });
        });
        it("Unpartitioned Queue: errors after close() on receiverClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue, entityToClose);
                yield testReceiver(expectedReceiverErrorMsg);
                yield testReceiverClient(expectedQueueClientErrorMsg);
            });
        });
        it("Unpartitioned Queue with sessions: errors after close() on receiverClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, entityToClose, true);
                yield testSessionReceiver(expectedReceiverErrorMsg);
                yield testReceiverClient(expectedQueueClientErrorMsg, true);
            });
        });
        it("Unpartitioned Topic/Subscription: errors after close() on receiverClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription, entityToClose);
                yield testReceiver(expectedReceiverErrorMsg);
                yield testReceiverClient(expectedSubscriptionClientErrorMsg);
                yield testRules(expectedSubscriptionClientErrorMsg);
            });
        });
        it("Unpartitioned Topic/Subscription with sessions: errors after close() on receiverClient", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, entityToClose, true);
                yield testSessionReceiver(expectedReceiverErrorMsg);
                yield testReceiverClient(expectedSubscriptionClientErrorMsg, true);
                yield testRules(expectedSubscriptionClientErrorMsg);
            });
        });
    });
    describe("Errors after close() on sender", function () {
        const entityToClose = "sender";
        const expectedSenderErrorMsg = "The sender has been closed and can no longer be used.";
        it("Partitioned Queue: errors after close() on sender", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue, entityToClose);
                yield testSender(expectedSenderErrorMsg);
            });
        });
        it("Partitioned Queue with sessions: errors after close() on sender", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, entityToClose, true);
                yield testSender(expectedSenderErrorMsg);
            });
        });
        it("Partitioned Topic/Subscription: errors after close() on sender", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription, entityToClose);
                yield testSender(expectedSenderErrorMsg);
            });
        });
        it("Partitioned Topic/Subscription with sessions: errors after close() on sender", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, entityToClose, true);
                yield testSender(expectedSenderErrorMsg);
            });
        });
        it("Unpartitioned Queue: errors after close() on sender", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue, entityToClose);
                yield testSender(expectedSenderErrorMsg);
            });
        });
        it("Unpartitioned Queue with sessions: errors after close() on sender", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, entityToClose, true);
                yield testSender(expectedSenderErrorMsg);
            });
        });
        it("Unpartitioned Topic/Subscription: errors after close() on sender", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription, entityToClose);
                yield testSender(expectedSenderErrorMsg);
            });
        });
        it("Unpartitioned Topic/Subscription with sessions: errors after close() on sender", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, entityToClose, true);
                yield testSender(expectedSenderErrorMsg);
            });
        });
    });
    describe("Errors after close() on receiver", function () {
        const entityToClose = "receiver";
        const expectedReceiverErrorMsg = "The receiver has been closed and can no longer be used.";
        it("Partitioned Queue: errors after close() on receiver", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedQueue, ClientType.PartitionedQueue, entityToClose);
                yield testReceiver(expectedReceiverErrorMsg);
            });
        });
        it("Partitioned Queue with sessions: errors after close() on receiver", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, entityToClose, true);
                yield testSessionReceiver(expectedReceiverErrorMsg);
            });
        });
        it("Partitioned Topic/Subscription: errors after close() on receiver", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedTopic, ClientType.PartitionedSubscription, entityToClose);
                yield testReceiver(expectedReceiverErrorMsg);
            });
        });
        it("Partitioned Topic/Subscription with sessions: errors after close() on receiver", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, entityToClose, true);
                yield testSessionReceiver(expectedReceiverErrorMsg);
            });
        });
        it("Unpartitioned Queue: errors after close() on receiver", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue, entityToClose);
                yield testReceiver(expectedReceiverErrorMsg);
            });
        });
        it("Unpartitioned Queue with sessions: errors after close() on receiver", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, entityToClose, true);
                yield testSessionReceiver(expectedReceiverErrorMsg);
            });
        });
        it("Unpartitioned Topic/Subscription: errors after close() on receiver", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription, entityToClose);
                yield testReceiver(expectedReceiverErrorMsg);
            });
        });
        it("Unpartitioned Topic/Subscription with sessions: errors after close() on receiver", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield beforeEachTest(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, entityToClose, true);
                yield testSessionReceiver(expectedReceiverErrorMsg);
            });
        });
    });
});

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$4 = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
function testPeekMsgsLength$2(client, expectedPeekLength) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const peekedMsgs = yield client.peek(expectedPeekLength + 1);
        should$4.equal(peekedMsgs.length, expectedPeekLength, "Unexpected number of msgs found when peeking");
    });
}
let ns$3;
let errorWasThrown$1;
let senderClient$2;
let receiverClient$2;
let sender$3;
let receiver$3;
function beforeEachTest$2(senderType, receiverType, useSessions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // The tests in this file expect the env variables to contain the connection string and
        // the names of empty queue/topic/subscription that are to be tested
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$3 = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$3, senderType, receiverType);
        senderClient$2 = clients.senderClient;
        receiverClient$2 = clients.receiverClient;
        yield purge(receiverClient$2, useSessions ? TestMessage.sessionId : undefined);
        const peekedMsgs = yield receiverClient$2.peek();
        const receiverEntityType = receiverClient$2 instanceof QueueClient ? "queue" : "topic";
        if (peekedMsgs.length) {
            chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
        }
        sender$3 = senderClient$2.getSender();
        receiver$3 = useSessions
            ? yield receiverClient$2.getSessionReceiver({
                sessionId: TestMessage.sessionId,
                receiveMode: ReceiveMode.receiveAndDelete
            })
            : receiverClient$2.getReceiver({ receiveMode: ReceiveMode.receiveAndDelete });
        errorWasThrown$1 = false;
    });
}
function afterEachTest$2() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ns$3.close();
    });
}
describe("Batch Receiver in ReceiveAndDelete mode", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$2();
    }));
    function sendReceiveMsg(testMessages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield sender$3.send(testMessages);
            const msgs = yield receiver$3.receiveBatch(1);
            should$4.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$4.equal(msgs.length, 1, "Unexpected number of messages");
            should$4.equal(msgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$4.equal(msgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            should$4.equal(msgs[0].deliveryCount, 0, "DeliveryCount is different than expected");
        });
    }
    function testNoSettlement(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            yield sendReceiveMsg(testMessages);
            yield testPeekMsgsLength$2(receiverClient$2, 0);
        });
    }
    it("Partitioned Queue: No settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testNoSettlement();
        });
    });
    it("Partitioned Subscription: No settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testNoSettlement();
        });
    });
    /*it("Unpartitioned Queue: No settlement of the message removes message", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
      await testNoSettlement();
    });
  
    it("Unpartitioned Subscription: No settlement of the message removes message", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
      await testNoSettlement();
    });*/
    it("Partitioned Queue with Sessions: No settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testNoSettlement(true);
        });
    });
    it("Partitioned Subscription with Sessions: No settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testNoSettlement(true);
        });
    });
    it("Unpartitioned Queue with Sessions: No settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testNoSettlement(true);
        });
    });
    it("Unpartitioned Subscription with Sessions: No settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testNoSettlement(true);
        });
    });
});
describe("Streaming Receiver in ReceiveAndDelete mode", function () {
    let errorFromErrorHandler;
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$2();
    }));
    function sendReceiveMsg(testMessages, autoCompleteFlag) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield sender$3.send(testMessages);
            const receivedMsgs = [];
            receiver$3.receive((msg) => {
                receivedMsgs.push(msg);
                return Promise.resolve();
            }, (err) => {
                if (err) {
                    errorFromErrorHandler = err;
                }
            }, { autoComplete: autoCompleteFlag });
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1);
            should$4.equal(msgsCheck, true, "Could not receive the messages in expected time.");
            should$4.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            should$4.equal(receivedMsgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$4.equal(receivedMsgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            should$4.equal(errorFromErrorHandler, undefined, errorFromErrorHandler && errorFromErrorHandler.message);
            yield testPeekMsgsLength$2(receiverClient$2, 0);
        });
    }
    function testNoSettlement(autoCompleteFlag, useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            yield sendReceiveMsg(testMessages, autoCompleteFlag);
            yield testPeekMsgsLength$2(receiverClient$2, 0);
        });
    }
    it("Partitioned Queue: With auto-complete enabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testNoSettlement(true);
        });
    });
    it("Partitioned Subscription: With auto-complete enabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testNoSettlement(true);
        });
    });
    /* it("Unpartitioned Queue: With auto-complete enabled, no settlement of the message removes message", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
      await testNoSettlement(true);
    });
  
    it("Unpartitioned Subscription: With auto-complete enabled, no settlement of the message removes message", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
      await testNoSettlement(true);
    });*/
    it("Partitioned Queue with Sessions: With auto-complete enabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testNoSettlement(true, true);
        });
    });
    it("Partitioned Subscription with Sessions: With auto-complete enabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testNoSettlement(true, true);
        });
    });
    it("Unpartitioned Queue with Sessions: With auto-complete enabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testNoSettlement(true, true);
        });
    });
    it("Unpartitioned Subscription with Sessions: With auto-complete enabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testNoSettlement(true, true);
        });
    });
    it("Partitioned Queue: With auto-complete disabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testNoSettlement(false);
        });
    });
    it("Partitioned Subscription: With auto-complete disabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testNoSettlement(false);
        });
    });
    /* it("Unpartitioned Queue: With auto-complete disabled, no settlement of the message removes message", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
      await testNoSettlement(false);
    });
  
    it("Unpartitioned Subscription: With auto-complete disabled, no settlement of the message removes message", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
      await testNoSettlement(false);
    });*/
    it("Partitioned Queue with Sessions: With auto-complete disabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testNoSettlement(false, true);
        });
    });
    it("Partitioned Subscription with Sessions: With auto-complete disabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testNoSettlement(false, true);
        });
    });
    it("Unpartitioned Queue with Sessions: With auto-complete disabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testNoSettlement(false, true);
        });
    });
    it("Unpartitioned Subscription with Sessions: With auto-complete disabled, no settlement of the message removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testNoSettlement(false, true);
        });
    });
});
describe("Unsupported features in ReceiveAndDelete mode", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$2();
    }));
    function sendReceiveMsg(testMessages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield sender$3.send(testMessages);
            const msgs = yield receiver$3.receiveBatch(1);
            should$4.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$4.equal(msgs.length, 1, "Unexpected number of messages");
            should$4.equal(msgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$4.equal(msgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            should$4.equal(msgs[0].deliveryCount, 0, "DeliveryCount is different than expected");
            return msgs[0];
        });
    }
    const testError = (err) => {
        should$4.equal(err.message, "The operation is only supported in 'PeekLock' receive mode.", "ErrorMessage is different than expected");
        errorWasThrown$1 = true;
    };
    function testSettlement(operation, useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const msg = yield sendReceiveMsg(testMessages);
            if (operation === DispositionType.complete) {
                yield msg.complete().catch((err) => testError(err));
            }
            else if (operation === DispositionType.abandon) {
                yield msg.abandon().catch((err) => testError(err));
            }
            else if (operation === DispositionType.deadletter) {
                yield msg.deadLetter().catch((err) => testError(err));
            }
            else if (operation === DispositionType.defer) {
                yield msg.defer().catch((err) => testError(err));
            }
            should$4.equal(errorWasThrown$1, true, "Error thrown flag must be true");
            yield testPeekMsgsLength$2(receiverClient$2, 0);
        });
    }
    it("Partitioned Queue: complete() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testSettlement(DispositionType.complete);
        });
    });
    it("Partitioned Subscription: complete() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testSettlement(DispositionType.complete);
        });
    });
    /* it("Unpartitioned Queue: complete() throws error", async function(): Promise<void> {
      await beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
      await testSettlement(DispositionType.complete);
    });
  
    it("Unpartitioned Subscription: complete() throws error", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
      await testSettlement(DispositionType.complete);
    });*/
    it("Partitioned Queue with Sessions: complete() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testSettlement(DispositionType.complete, true);
        });
    });
    it("Partitioned Subscription with Sessions: complete() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testSettlement(DispositionType.complete, true);
        });
    });
    it("Unpartitioned Queue with Sessions: complete() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testSettlement(DispositionType.complete, true);
        });
    });
    it("Unpartitioned Subscription with Sessions: complete() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testSettlement(DispositionType.complete, true);
        });
    });
    it("Partitioned Queue: abandon() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testSettlement(DispositionType.abandon);
        });
    });
    it("Partitioned Subscription: abandon() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testSettlement(DispositionType.abandon);
        });
    });
    /* it("Unpartitioned Queue: abandon() throws error", async function(): Promise<void> {
      await beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
      await testSettlement(DispositionType.abandon);
    });
  
    it("Unpartitioned Subscription: abandon() throws error", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
      await testSettlement(DispositionType.abandon);
    });*/
    it("Partitioned Queue with Sessions: abandon() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testSettlement(DispositionType.abandon, true);
        });
    });
    it("Partitioned Subscription with Sessions: abandon() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testSettlement(DispositionType.abandon, true);
        });
    });
    it("Unpartitioned Queue with Sessions: abandon() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testSettlement(DispositionType.abandon, true);
        });
    });
    it("Unpartitioned Subscription with Sessions: abandon() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testSettlement(DispositionType.abandon, true);
        });
    });
    it("Partitioned Queue: defer() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testSettlement(DispositionType.defer);
        });
    });
    it("Partitioned Subscription: defer() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testSettlement(DispositionType.defer);
        });
    });
    /* it("Unpartitioned Queue: defer() throws error", async function(): Promise<void> {
      await beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
      await testSettlement(DispositionType.defer);
    });
  
    it("Unpartitioned Subscription: defer() throws error", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
      await testSettlement(DispositionType.defer);
    });*/
    it("Partitioned Queue with Sessions: defer() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testSettlement(DispositionType.defer, true);
        });
    });
    it("Partitioned Subscription with Sessions: defer() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testSettlement(DispositionType.defer, true);
        });
    });
    it("Unpartitioned Queue with Sessions: defer() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testSettlement(DispositionType.defer, true);
        });
    });
    it("Unpartitioned Subscription with Sessions: defer() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testSettlement(DispositionType.defer, true);
        });
    });
    it("Partitioned Queue: deadLetter() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testSettlement(DispositionType.deadletter);
        });
    });
    it("Partitioned Subscription: deadLetter() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testSettlement(DispositionType.deadletter);
        });
    });
    /* it("Unpartitioned Queue: deadLetter() throws error", async function(): Promise<void> {
      await beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
      await testSettlement(DispositionType.deadletter);
    });
  
    it("Unpartitioned Subscription: deadLetter() throws error", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
      await testSettlement(DispositionType.deadletter);
    });*/
    it("Partitioned Queue with Sessions: deadLetter() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testSettlement(DispositionType.deadletter, true);
        });
    });
    it("Partitioned Subscription with Sessions: deadLetter() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testSettlement(DispositionType.deadletter, true);
        });
    });
    it("Unpartitioned Queue with Sessions: deadLetter() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testSettlement(DispositionType.deadletter, true);
        });
    });
    it("Unpartitioned Subscription with Sessions: deadLetter() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testSettlement(DispositionType.deadletter, true);
        });
    });
    function testRenewLock() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const msg = yield sendReceiveMsg(TestMessage.getSample());
            yield receiver$3.renewLock(msg).catch((err) => testError(err));
            should$4.equal(errorWasThrown$1, true, "Error thrown flag must be true");
        });
    }
    it("Partitioned Queue: Renew message lock throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testRenewLock();
        });
    });
    it("Partitioned Subscription: Renew message lock throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$2(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testRenewLock();
        });
    });
    /* it("Unpartitioned Queue: Renew message lock throws error", async function(): Promise<void> {
      await beforeEachTest(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
      await testRenewLock();
    });
  
    it("Unpartitioned Subscription: Renew message lock throws error", async function(): Promise<
      void
    > {
      await beforeEachTest(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
      await testRenewLock();
    });*/
});

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$5 = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
let ns$4;
let senderClient$3;
let receiverClient$3;
function beforeEachTest$3(senderType, receiverType) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$4 = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$4, senderType, receiverType);
        senderClient$3 = clients.senderClient;
        receiverClient$3 = clients.receiverClient;
        yield purge(receiverClient$3);
        const peekedMsgs = yield receiverClient$3.peek();
        const receiverEntityType = receiverClient$3 instanceof QueueClient ? "queue" : "topic";
        if (peekedMsgs.length) {
            chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
        }
    });
}
function afterEachTest$3() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ns$4.close();
    });
}
describe("Unpartitioned Queue - Lock Renewal", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$3(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$3();
    }));
    it("Batch Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalHappyCase(senderClient$3, receiverClient$3);
        });
    });
    it("Batch Receiver: complete() after lock expiry with throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalErrorOnLockExpiry(senderClient$3, receiverClient$3);
        });
    });
    it("Streaming Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testStreamingReceiverManualLockRenewalHappyCase(senderClient$3, receiverClient$3);
        });
    });
    it("Streaming Receiver: complete() after lock expiry with auto-renewal disabled throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 0,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                willCompleteFail: true
            });
        });
    });
    it("Streaming Receiver: lock will not expire until configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 38,
                delayBeforeAttemptingToCompleteMessageInSeconds: 35,
                willCompleteFail: false
            });
        });
    });
    it("Streaming Receiver: lock expires sometime after configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 35,
                delayBeforeAttemptingToCompleteMessageInSeconds: 55,
                willCompleteFail: true
            });
        });
    }).timeout(90000);
    it("Streaming Receiver: No lock renewal when config value is less than lock duration", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 15,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                willCompleteFail: true
            });
        });
    });
});
describe("Partitioned Queue - Lock Renewal", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$3(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$3();
    }));
    it("Batch Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalHappyCase(senderClient$3, receiverClient$3);
        });
    });
    it("Batch Receiver: complete() after lock expiry with throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalErrorOnLockExpiry(senderClient$3, receiverClient$3);
        });
    });
    it("Streaming Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testStreamingReceiverManualLockRenewalHappyCase(senderClient$3, receiverClient$3);
        });
    });
    it("Streaming Receiver: complete() after lock expiry with auto-renewal disabled throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 0,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                willCompleteFail: true
            });
            // Complete fails as expected
        });
    });
    it("Streaming Receiver: lock will not expire until configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 38,
                delayBeforeAttemptingToCompleteMessageInSeconds: 35,
                willCompleteFail: false
            });
        });
    });
    it("Streaming Receiver: lock expires sometime after configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 35,
                delayBeforeAttemptingToCompleteMessageInSeconds: 55,
                willCompleteFail: true
            });
        });
    }).timeout(90000);
    it("Streaming Receiver: No lock renewal when config value is less than lock duration", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 15,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                willCompleteFail: true
            });
        });
    });
});
describe("Unpartitioned Subscription - Lock Renewal", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$3(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$3();
    }));
    it("Batch Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalHappyCase(senderClient$3, receiverClient$3);
        });
    });
    it("Batch Receiver: complete() after lock expiry with throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalErrorOnLockExpiry(senderClient$3, receiverClient$3);
        });
    });
    it("Streaming Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testStreamingReceiverManualLockRenewalHappyCase(senderClient$3, receiverClient$3);
        });
    });
    it("Streaming Receiver: complete() after lock expiry with auto-renewal disabled throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 0,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                willCompleteFail: true
            });
            // Complete fails as expected
        });
    });
    it("Streaming Receiver: lock will not expire until configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 38,
                delayBeforeAttemptingToCompleteMessageInSeconds: 35,
                willCompleteFail: false
            });
        });
    });
    it("Streaming Receiver: lock expires sometime after configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 35,
                delayBeforeAttemptingToCompleteMessageInSeconds: 55,
                willCompleteFail: true
            });
        });
    }).timeout(90000);
    it("Streaming Receiver: No lock renewal when config value is less than lock duration", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 15,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                willCompleteFail: true
            });
        });
    });
});
describe("Partitioned Subscription - Lock Renewal", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$3(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$3();
    }));
    it("Batch Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalHappyCase(senderClient$3, receiverClient$3);
        });
    });
    it("Batch Receiver: complete() after lock expiry with throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalErrorOnLockExpiry(senderClient$3, receiverClient$3);
        });
    });
    it("Streaming Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testStreamingReceiverManualLockRenewalHappyCase(senderClient$3, receiverClient$3);
        });
    });
    it("Streaming Receiver: complete() after lock expiry with auto-renewal disabled throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 0,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                willCompleteFail: true
            });
            // Complete fails as expected
        });
    });
    it("Streaming Receiver: lock will not expire until configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 38,
                delayBeforeAttemptingToCompleteMessageInSeconds: 35,
                willCompleteFail: false
            });
        });
    });
    it("Streaming Receiver: lock expires sometime after configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 35,
                delayBeforeAttemptingToCompleteMessageInSeconds: 55,
                willCompleteFail: true
            });
        });
    }).timeout(90000);
    it("Streaming Receiver: No lock renewal when config value is less than lock duration", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior(senderClient$3, receiverClient$3, {
                maxAutoRenewDurationInSeconds: 15,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                willCompleteFail: true
            });
        });
    });
});
const lockDurationInMilliseconds = 30000;
let uncaughtErrorFromHandlers;
const onError = (err) => {
    uncaughtErrorFromHandlers = err;
};
/**
 * Test renewLock() after receiving a message using Batch Receiver
 */
function testBatchReceiverManualLockRenewalHappyCase(senderClient, receiverClient) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const testMessage = TestMessage.getSample();
        yield senderClient.getSender().send(testMessage);
        const receiver = receiverClient.getReceiver();
        const msgs = yield receiver.receiveBatch(1);
        // Compute expected initial lock expiry time
        const expectedLockExpiryTimeUtc = new Date();
        expectedLockExpiryTimeUtc.setSeconds(expectedLockExpiryTimeUtc.getSeconds() + lockDurationInMilliseconds / 1000);
        should$5.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
        should$5.equal(msgs.length, 1, "Unexpected number of messages");
        should$5.equal(msgs[0].body, testMessage.body, "MessageBody is different than expected");
        should$5.equal(msgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
        // Verify initial lock expiry time on the message
        assertTimestampsAreApproximatelyEqual(msgs[0].lockedUntilUtc, expectedLockExpiryTimeUtc, "Initial");
        yield rheaPromise.delay(5000);
        if (msgs[0].lockToken) {
            yield receiver.renewLock(msgs[0].lockToken);
        }
        // Compute expected lock expiry time after renewing lock after 5 seconds
        expectedLockExpiryTimeUtc.setSeconds(expectedLockExpiryTimeUtc.getSeconds() + 5);
        // Verify lock expiry time after renewLock()
        assertTimestampsAreApproximatelyEqual(msgs[0].lockedUntilUtc, expectedLockExpiryTimeUtc, "After renewlock()");
        yield msgs[0].complete();
    });
}
/**
 * Test settling of message from Batch Receiver fails after message lock expires
 */
function testBatchReceiverManualLockRenewalErrorOnLockExpiry(senderClient, receiverClient) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const testMessage = TestMessage.getSample();
        yield senderClient.getSender().send(testMessage);
        const receiver = receiverClient.getReceiver();
        const msgs = yield receiver.receiveBatch(1);
        should$5.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
        should$5.equal(msgs.length, 1, "Expected message length does not match");
        should$5.equal(msgs[0].body, testMessage.body, "MessageBody is different than expected");
        should$5.equal(msgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
        // Sleeping 30 seconds...
        yield rheaPromise.delay(lockDurationInMilliseconds + 1000);
        let errorWasThrown = false;
        yield msgs[0].complete().catch((err) => {
            should$5.equal(err.name, "MessageLockLostError", "ErrorName is different than expected");
            errorWasThrown = true;
        });
        should$5.equal(errorWasThrown, true, "Error thrown flag must be true");
        // Clean up any left over messages
        const unprocessedMsgs = yield receiver.receiveBatch(1);
        yield unprocessedMsgs[0].complete();
    });
}
/**
 * Test renewLock() after receiving a message using Streaming Receiver with autoLockRenewal disabled
 */
function testStreamingReceiverManualLockRenewalHappyCase(senderClient, receiverClient) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let numOfMessagesReceived = 0;
        const testMessage = TestMessage.getSample();
        yield senderClient.getSender().send(testMessage);
        const receiver = receiverClient.getReceiver();
        const onMessage = (brokeredMessage) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (numOfMessagesReceived < 1) {
                numOfMessagesReceived++;
                should$5.equal(brokeredMessage.body, testMessage.body, "MessageBody is different than expected");
                should$5.equal(brokeredMessage.messageId, testMessage.messageId, "MessageId is different than expected");
                // Compute expected initial lock expiry time
                const expectedLockExpiryTimeUtc = new Date();
                expectedLockExpiryTimeUtc.setSeconds(expectedLockExpiryTimeUtc.getSeconds() + lockDurationInMilliseconds / 1000);
                // Verify initial expiry time on message
                assertTimestampsAreApproximatelyEqual(brokeredMessage.lockedUntilUtc, expectedLockExpiryTimeUtc, "Initial");
                yield rheaPromise.delay(5000);
                yield receiver.renewLock(brokeredMessage);
                // Compute expected lock expiry time after renewing lock after 5 seconds
                expectedLockExpiryTimeUtc.setSeconds(expectedLockExpiryTimeUtc.getSeconds() + 5);
                // Verify actual expiry time on session after first renewal
                assertTimestampsAreApproximatelyEqual(brokeredMessage.lockedUntilUtc, expectedLockExpiryTimeUtc, "After renewlock");
                yield brokeredMessage.complete();
            }
        });
        receiver.receive(onMessage, onError, {
            autoComplete: false,
            maxMessageAutoRenewLockDurationInSeconds: 0
        });
        yield rheaPromise.delay(10000);
        yield receiver.close();
        if (uncaughtErrorFromHandlers) {
            chai$1.assert.fail(uncaughtErrorFromHandlers.message);
        }
        should$5.equal(numOfMessagesReceived, 1, "Unexpected number of messages");
    });
}
function testAutoLockRenewalConfigBehavior(senderClient, receiverClient, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let numOfMessagesReceived = 0;
        const testMessage = TestMessage.getSample();
        yield senderClient.getSender().send(testMessage);
        const receiver = receiverClient.getReceiver();
        const onMessage = (brokeredMessage) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (numOfMessagesReceived < 1) {
                numOfMessagesReceived++;
                should$5.equal(brokeredMessage.body, testMessage.body, "MessageBody is different than expected");
                should$5.equal(brokeredMessage.messageId, testMessage.messageId, "MessageId is different than expected");
                // Sleeping...
                yield rheaPromise.delay(options.delayBeforeAttemptingToCompleteMessageInSeconds * 1000);
                let errorWasThrown = false;
                yield brokeredMessage.complete().catch((err) => {
                    should$5.equal(err.name, "MessageLockLostError", "ErrorName is different than expected");
                    errorWasThrown = true;
                });
                should$5.equal(errorWasThrown, options.willCompleteFail, "Error Thrown flag value mismatch");
            }
        });
        receiver.receive(onMessage, onError, {
            autoComplete: false,
            maxMessageAutoRenewLockDurationInSeconds: options.maxAutoRenewDurationInSeconds
        });
        yield rheaPromise.delay(options.delayBeforeAttemptingToCompleteMessageInSeconds * 1000 + 10000);
        yield receiver.close();
        if (uncaughtErrorFromHandlers) {
            chai$1.assert.fail(uncaughtErrorFromHandlers.message);
        }
        should$5.equal(numOfMessagesReceived, 1, "Mismatch in number of messages received");
        if (options.willCompleteFail) {
            // Clean up any left over messages
            const newReceiver = receiverClient.getReceiver();
            const unprocessedMsgs = yield newReceiver.receiveBatch(1);
            yield unprocessedMsgs[0].complete();
        }
    });
}
function assertTimestampsAreApproximatelyEqual(actualTimeInUTC, expectedTimeInUTC, label) {
    if (actualTimeInUTC) {
        should$5.equal(Math.pow((actualTimeInUTC.valueOf() - expectedTimeInUTC.valueOf()) / 1000, 2) < 100, // Within +/- 10 seconds
        true, `${label}: Actual time ${actualTimeInUTC} must be approximately equal to ${expectedTimeInUTC}`);
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$6 = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
let ns$5;
let senderClient$4;
let receiverClient$4;
function beforeEachTest$4(senderType, receiverType) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$5 = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$5, senderType, receiverType);
        senderClient$4 = clients.senderClient;
        receiverClient$4 = clients.receiverClient;
        yield purge(receiverClient$4, TestMessage.sessionId);
        const peekedMsgs = yield receiverClient$4.peek();
        const receiverEntityType = receiverClient$4 instanceof QueueClient ? "queue" : "topic";
        if (peekedMsgs.length) {
            chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
        }
    });
}
function afterEachTest$4() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ns$5.close();
    });
}
describe("Unpartitioned Queue - Lock Renewal for Sessions", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$4(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$4();
    }));
    it("Batch Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalHappyCase$1(senderClient$4, receiverClient$4);
        });
    });
    it("Batch Receiver: complete() after lock expiry with throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalErrorOnLockExpiry$1(senderClient$4, receiverClient$4);
        });
    });
    it("Streaming Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testStreamingReceiverManualLockRenewalHappyCase$1(senderClient$4, receiverClient$4);
        });
    });
    it("Streaming Receiver: complete() after lock expiry with auto-renewal disabled throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 0,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    });
    it("Streaming Receiver: lock will not expire until configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 38,
                delayBeforeAttemptingToCompleteMessageInSeconds: 35,
                expectSessionLockLostErrorToBeThrown: false
            });
        });
    });
    it("Streaming Receiver: lock expires sometime after configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 35,
                delayBeforeAttemptingToCompleteMessageInSeconds: 80,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    }).timeout(95000);
    it("Receive a msg using Streaming Receiver, lock renewal does not take place when config value is less than lock duration", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 15,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    });
});
describe("Partitioned Queue - Lock Renewal for Sessions", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$4(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$4();
    }));
    it("Batch Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalHappyCase$1(senderClient$4, receiverClient$4);
        });
    });
    it("Batch Receiver: complete() after lock expiry with throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalErrorOnLockExpiry$1(senderClient$4, receiverClient$4);
        });
    });
    it("Streaming Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testStreamingReceiverManualLockRenewalHappyCase$1(senderClient$4, receiverClient$4);
        });
    });
    it("Streaming Receiver: complete() after lock expiry with auto-renewal disabled throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 0,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    });
    it("Streaming Receiver: lock will not expire until configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 38,
                delayBeforeAttemptingToCompleteMessageInSeconds: 35,
                expectSessionLockLostErrorToBeThrown: false
            });
        });
    });
    it("Streaming Receiver: lock expires sometime after configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 35,
                delayBeforeAttemptingToCompleteMessageInSeconds: 80,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    }).timeout(95000);
    it("Receive a msg using Streaming Receiver, lock renewal does not take place when config value is less than lock duration", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 15,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    });
});
describe("Unpartitioned Subscription - Lock Renewal for Sessions", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$4(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$4();
    }));
    it("Batch Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalHappyCase$1(senderClient$4, receiverClient$4);
        });
    });
    it("Batch Receiver: complete() after lock expiry with throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalErrorOnLockExpiry$1(senderClient$4, receiverClient$4);
        });
    });
    it("Streaming Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testStreamingReceiverManualLockRenewalHappyCase$1(senderClient$4, receiverClient$4);
        });
    });
    it("Streaming Receiver: complete() after lock expiry with auto-renewal disabled throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 0,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    });
    it("Streaming Receiver: lock will not expire until configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 38,
                delayBeforeAttemptingToCompleteMessageInSeconds: 35,
                expectSessionLockLostErrorToBeThrown: false
            });
        });
    });
    it("Streaming Receiver: lock expires sometime after configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 35,
                delayBeforeAttemptingToCompleteMessageInSeconds: 80,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    }).timeout(95000);
    it("Receive a msg using Streaming Receiver, lock renewal does not take place when config value is less than lock duration", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 15,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    });
});
describe("Partitioned Subscription - Lock Renewal for Sessions", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$4(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$4();
    }));
    it("Batch Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalHappyCase$1(senderClient$4, receiverClient$4);
        });
    });
    it("Batch Receiver: complete() after lock expiry with throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testBatchReceiverManualLockRenewalErrorOnLockExpiry$1(senderClient$4, receiverClient$4);
        });
    });
    it("Streaming Receiver: renewLock() resets lock duration each time.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testStreamingReceiverManualLockRenewalHappyCase$1(senderClient$4, receiverClient$4);
        });
    });
    it("Streaming Receiver: complete() after lock expiry with auto-renewal disabled throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 0,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    });
    it("Streaming Receiver: lock will not expire until configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 38,
                delayBeforeAttemptingToCompleteMessageInSeconds: 35,
                expectSessionLockLostErrorToBeThrown: false
            });
        });
    });
    it("Streaming Receiver: lock expires sometime after configured time", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 35,
                delayBeforeAttemptingToCompleteMessageInSeconds: 80,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    }).timeout(95000);
    it("Receive a msg using Streaming Receiver, lock renewal does not take place when config value is less than lock duration", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testAutoLockRenewalConfigBehavior$1(senderClient$4, receiverClient$4, {
                maxSessionAutoRenewLockDurationInSeconds: 15,
                delayBeforeAttemptingToCompleteMessageInSeconds: 31,
                expectSessionLockLostErrorToBeThrown: true
            });
        });
    });
});
const lockDurationInMilliseconds$1 = 30000;
// const maxSessionAutoRenewLockDurationInSeconds = 300;
let uncaughtErrorFromHandlers$1;
const onError$1 = (err) => {
    uncaughtErrorFromHandlers$1 = err;
};
/**
 * Test manual renewLock() using Batch Receiver, with autoLockRenewal disabled
 */
function testBatchReceiverManualLockRenewalHappyCase$1(senderClient, receiverClient) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const testMessage = TestMessage.getSessionSample();
        yield senderClient.getSender().send(testMessage);
        const sessionClient = yield receiverClient.getSessionReceiver({
            sessionId: TestMessage.sessionId,
            maxSessionAutoRenewLockDurationInSeconds: 0
        });
        const msgs = yield sessionClient.receiveBatch(1);
        // Compute expected initial lock expiry time
        const expectedLockExpiryTimeUtc = new Date();
        expectedLockExpiryTimeUtc.setSeconds(expectedLockExpiryTimeUtc.getSeconds() + lockDurationInMilliseconds$1 / 1000);
        should$6.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
        should$6.equal(msgs.length, 1, "Unexpected number of messages");
        should$6.equal(msgs[0].body, testMessage.body, "MessageBody is different than expected");
        should$6.equal(msgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
        // Verify initial lock expiry time on the session
        assertTimestampsAreApproximatelyEqual$1(sessionClient.sessionLockedUntilUtc, expectedLockExpiryTimeUtc, "Initial");
        yield amqpCommon.delay(5000);
        yield sessionClient.renewLock();
        // Compute expected lock expiry time after renewing lock after 5 seconds
        expectedLockExpiryTimeUtc.setSeconds(expectedLockExpiryTimeUtc.getSeconds() + 5);
        // Verify lock expiry time after renewLock()
        assertTimestampsAreApproximatelyEqual$1(sessionClient.sessionLockedUntilUtc, expectedLockExpiryTimeUtc, "After renewlock()");
        yield msgs[0].complete();
    });
}
/**
 * Test settling of message from Batch Receiver fails after session lock expires
 */
function testBatchReceiverManualLockRenewalErrorOnLockExpiry$1(senderClient, receiverClient) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const testMessage = TestMessage.getSessionSample();
        yield senderClient.getSender().send(testMessage);
        let sessionClient = yield receiverClient.getSessionReceiver({
            sessionId: TestMessage.sessionId,
            maxSessionAutoRenewLockDurationInSeconds: 0
        });
        const msgs = yield sessionClient.receiveBatch(1);
        should$6.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
        should$6.equal(msgs.length, 1, "Expected message length does not match");
        should$6.equal(msgs[0].body, testMessage.body, "MessageBody is different than expected");
        should$6.equal(msgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
        yield amqpCommon.delay(lockDurationInMilliseconds$1 + 1000);
        let errorWasThrown = false;
        yield msgs[0].complete().catch((err) => {
            should$6.equal(err.name, "SessionLockLostError", "ErrorName is different than expected");
            errorWasThrown = true;
        });
        should$6.equal(errorWasThrown, true, "Error thrown flag must be true");
        // Subsequent receivers for the same session should work as expected.
        sessionClient = yield receiverClient.getSessionReceiver();
        const unprocessedMsgs = yield sessionClient.receiveBatch(1);
        should$6.equal(unprocessedMsgs[0].deliveryCount, 1, "Unexpected deliveryCount");
        yield unprocessedMsgs[0].complete();
    });
}
/**
 * Test manual renewLock() using Streaming Receiver with autoLockRenewal disabled
 */
function testStreamingReceiverManualLockRenewalHappyCase$1(senderClient, receiverClient) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let numOfMessagesReceived = 0;
        const testMessage = TestMessage.getSessionSample();
        yield senderClient.getSender().send(testMessage);
        const sessionClient = yield receiverClient.getSessionReceiver({
            sessionId: TestMessage.sessionId,
            maxSessionAutoRenewLockDurationInSeconds: 0
        });
        const onSessionMessage = (brokeredMessage) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (numOfMessagesReceived < 1) {
                numOfMessagesReceived++;
                should$6.equal(brokeredMessage.body, testMessage.body, "MessageBody is different than expected");
                should$6.equal(brokeredMessage.messageId, testMessage.messageId, "MessageId is different than expected");
                // Compute expected initial lock expiry time
                const expectedLockExpiryTimeUtc = new Date();
                expectedLockExpiryTimeUtc.setSeconds(expectedLockExpiryTimeUtc.getSeconds() + lockDurationInMilliseconds$1 / 1000);
                // Verify initial expiry time on session
                assertTimestampsAreApproximatelyEqual$1(sessionClient.sessionLockedUntilUtc, expectedLockExpiryTimeUtc, "Initial");
                yield amqpCommon.delay(5000);
                yield sessionClient.renewLock();
                // Compute expected lock expiry time after renewing lock after 5 seconds
                expectedLockExpiryTimeUtc.setSeconds(expectedLockExpiryTimeUtc.getSeconds() + 5);
                // Verify actual expiry time on session after renewal
                assertTimestampsAreApproximatelyEqual$1(sessionClient.sessionLockedUntilUtc, expectedLockExpiryTimeUtc, "After renewlock()");
                yield brokeredMessage.complete();
            }
        });
        yield sessionClient.receive(onSessionMessage, onError$1, {
            autoComplete: false
        });
        yield amqpCommon.delay(10000);
        yield sessionClient.close();
        if (uncaughtErrorFromHandlers$1) {
            chai$1.assert.fail(uncaughtErrorFromHandlers$1.message);
        }
        should$6.equal(numOfMessagesReceived, 1, "Unexpected number of messages");
    });
}
function testAutoLockRenewalConfigBehavior$1(senderClient, receiverClient, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let numOfMessagesReceived = 0;
        const testMessage = TestMessage.getSessionSample();
        yield senderClient.getSender().send(testMessage);
        const sessionClient = yield receiverClient.getSessionReceiver({
            sessionId: TestMessage.sessionId,
            maxSessionAutoRenewLockDurationInSeconds: options.maxSessionAutoRenewLockDurationInSeconds
        });
        let sessionLockLostErrorThrown = false;
        const messagesReceived = [];
        yield sessionClient.receive((brokeredMessage) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (numOfMessagesReceived < 1) {
                numOfMessagesReceived++;
                should$6.equal(brokeredMessage.body, testMessage.body, "MessageBody is different than expected");
                should$6.equal(brokeredMessage.messageId, testMessage.messageId, "MessageId is different than expected");
                messagesReceived.push(brokeredMessage);
                // Sleeping...
                yield amqpCommon.delay(options.delayBeforeAttemptingToCompleteMessageInSeconds * 1000);
            }
        }), (err) => {
            if (err.name === "SessionLockLostError") {
                sessionLockLostErrorThrown = true;
            }
            else {
                onError$1(err);
            }
        }, {
            autoComplete: false
        });
        yield amqpCommon.delay(options.delayBeforeAttemptingToCompleteMessageInSeconds * 1000 + 2000);
        should$6.equal(sessionLockLostErrorThrown, options.expectSessionLockLostErrorToBeThrown, "SessionLockLostErrorThrown flag must match");
        should$6.equal(messagesReceived.length, 1, "Mismatch in number of messages received");
        let errorWasThrown = false;
        yield messagesReceived[0].complete().catch((err) => {
            should$6.equal(err.name, "SessionLockLostError", "ErrorName is different than expected");
            errorWasThrown = true;
        });
        should$6.equal(errorWasThrown, options.expectSessionLockLostErrorToBeThrown, "Error Thrown flag value mismatch");
        yield sessionClient.close();
        if (uncaughtErrorFromHandlers$1) {
            chai$1.assert.fail(uncaughtErrorFromHandlers$1.message);
        }
    });
}
function assertTimestampsAreApproximatelyEqual$1(actualTimeInUTC, expectedTimeInUTC, label) {
    if (actualTimeInUTC) {
        should$6.equal(Math.pow((actualTimeInUTC.valueOf() - expectedTimeInUTC.valueOf()) / 1000, 2) < 100, // Within +/- 10 seconds
        true, `${label}: Actual time ${actualTimeInUTC} must be approximately equal to ${expectedTimeInUTC}`);
    }
}

// Since `npm run build-samples` now update the typescript samples to make them debuggable,
// we now have the below tests to ensure such updates dont get checked in.
describe("Ensure typescript samples use published package", function () {
    const regex = new RegExp('import (.*) from "@azure/service-bus"');
    function testSamples(folder) {
        const files = fs.readdirSync(folder);
        const failingFiles = files.filter((file) => {
            const fileContents = fs.readFileSync(path.join(folder, file), { encoding: "utf-8" });
            return !regex.test(fileContents);
        });
        if (failingFiles.length) {
            chai$1.assert.fail(`${failingFiles.length} files (${failingFiles}) dont import @azure/service-bus`);
        }
    }
    it("Ensure getStarted samples use published package", () => {
        const folder = path.join(__dirname, "../examples/typescript/gettingStarted");
        testSamples(folder);
    });
    it("Ensure advancedFeatures samples use published package", () => {
        const folder = path.join(__dirname, "../examples/typescript/advancedFeatures");
        testSamples(folder);
    });
});

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$7 = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
function testPeekMsgsLength$3(client, expectedPeekLength) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const peekedMsgs = yield client.peek(expectedPeekLength + 1);
        should$7.equal(peekedMsgs.length, expectedPeekLength, "Unexpected number of msgs found when peeking");
    });
}
let ns$6;
let senderClient$5;
let receiverClient$5;
let receiver$4;
function beforeEachTest$5(senderType, receiverType, useSessions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // The tests in this file expect the env variables to contain the connection string and
        // the names of empty queue/topic/subscription that are to be tested
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$6 = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$6, senderType, receiverType);
        senderClient$5 = clients.senderClient;
        receiverClient$5 = clients.receiverClient;
        yield purge(receiverClient$5, useSessions ? TestMessage.sessionId : undefined);
        const peekedMsgs = yield receiverClient$5.peek();
        const receiverEntityType = receiverClient$5 instanceof QueueClient ? "queue" : "topic";
        if (peekedMsgs.length) {
            chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
        }
        receiver$4 = useSessions
            ? yield receiverClient$5.getSessionReceiver({
                sessionId: TestMessage.sessionId
            })
            : receiverClient$5.getReceiver();
    });
}
function afterEachTest$5() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ns$6.close();
    });
}
describe("Simple Send", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$5();
    }));
    function testSimpleSend(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            yield senderClient$5.getSender().send(testMessages);
            const msgs = yield receiver$4.receiveBatch(1);
            should$7.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$7.equal(msgs.length, 1, "Unexpected number of messages");
            should$7.equal(msgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$7.equal(msgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            should$7.equal(msgs[0].deliveryCount, 0, "DeliveryCount is different than expected");
            yield msgs[0].complete();
            yield testPeekMsgsLength$3(receiverClient$5, 0);
        });
    }
    it("Partitioned Queue: Simple Send", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testSimpleSend();
        });
    });
    it("Partitioned Topic: Simple Send", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testSimpleSend();
        });
    });
    it("Unpartitioned Queue: Simple Send", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testSimpleSend();
        });
    });
    it("Unpartitioned Topic: Simple Send", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testSimpleSend();
        });
    });
    it("Partitioned Queue with Sessions: Simple Send", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testSimpleSend(true);
        });
    });
    it("Partitioned Topic with Sessions: Simple Send", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testSimpleSend(true);
        });
    });
    it("Unpartitioned Queue with Sessions: Simple Send", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testSimpleSend(true);
        });
    });
    it("Unpartitioned Topic with Sessions: Simple Send", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testSimpleSend(true);
        });
    });
});
describe("Schedule single message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$5();
    }));
    function testScheduleMessage(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const scheduleTime = new Date(Date.now() + 10000); // 10 seconds from now
            yield senderClient$5.getSender().scheduleMessage(scheduleTime, testMessages);
            const msgs = yield receiver$4.receiveBatch(1);
            const msgEnqueueTime = msgs[0].enqueuedTimeUtc ? msgs[0].enqueuedTimeUtc.valueOf() : 0;
            should$7.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$7.equal(msgs.length, 1, "Unexpected number of messages");
            should$7.equal(msgEnqueueTime - scheduleTime.valueOf() >= 0, true, "Enqueued time must be greater than scheduled time"); // checking received message enqueue time is greater or equal to the scheduled time.
            should$7.equal(msgs[0].body, testMessages.body, "MessageBody is different than expected");
            should$7.equal(msgs[0].messageId, testMessages.messageId, "MessageId is different than expected");
            yield msgs[0].complete();
            yield testPeekMsgsLength$3(receiverClient$5, 0);
        });
    }
    it("Partitioned Queue: Schedule single message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testScheduleMessage();
        });
    });
    it("Partitioned Topic: Schedule single message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testScheduleMessage();
        });
    });
    it("Unpartitioned Queue: Schedule single message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testScheduleMessage();
        });
    });
    it("Unpartitioned Topic: Schedule single message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testScheduleMessage();
        });
    });
    it("Partitioned Queue with Sessions: Schedule single message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testScheduleMessage(true);
        });
    });
    it("Partitioned Topic with Sessions: Schedule single message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testScheduleMessage(true);
        });
    });
    it("Unpartitioned Queue with Sessions: Schedule single message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testScheduleMessage(true);
        });
    });
    it("Unpartitioned Topic with Sessions: Schedule single message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testScheduleMessage(true);
        });
    });
});
describe("Schedule multiple messages", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$5();
    }));
    const messages = [
        {
            body: "hello1",
            messageId: `test message ${Math.random()}`,
            partitionKey: "dummy" // partitionKey is only for partitioned queue/subscrption, Unpartitioned queue/subscrption do not care about partitionKey.
        },
        {
            body: "hello2",
            messageId: `test message ${Math.random()}`,
            partitionKey: "dummy" // partitionKey is only for partitioned queue/subscrption, Unpartitioned queue/subscrption do not care about partitionKey.
        }
    ];
    const messageWithSessions = [
        {
            body: "hello1",
            messageId: `test message ${Math.random()}`,
            sessionId: TestMessage.sessionId
        },
        {
            body: "hello2",
            messageId: `test message ${Math.random()}`,
            sessionId: TestMessage.sessionId
        }
    ];
    function testScheduleMessages(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? messageWithSessions : messages;
            const scheduleTime = new Date(Date.now() + 10000); // 10 seconds from now
            yield senderClient$5.getSender().scheduleMessages(scheduleTime, testMessages);
            const msgs = yield receiver$4.receiveBatch(2);
            should$7.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$7.equal(msgs.length, 2, "Unexpected number of messages");
            const msgEnqueueTime1 = msgs[0].enqueuedTimeUtc ? msgs[0].enqueuedTimeUtc.valueOf() : 0;
            const msgEnqueueTime2 = msgs[1].enqueuedTimeUtc ? msgs[1].enqueuedTimeUtc.valueOf() : 0;
            // checking received message enqueue time is greater or equal to the scheduled time.
            should$7.equal(msgEnqueueTime1 - scheduleTime.valueOf() >= 0, true, "msgEnqueueTime1 time must be greater than scheduled time");
            should$7.equal(msgEnqueueTime2 - scheduleTime.valueOf() >= 0, true, "msgEnqueueTime2 time must be greater than scheduled time");
            should$7.equal(testMessages.some((x) => x.messageId === msgs[0].messageId), true, "MessageId of first message is different than expected");
            should$7.equal(testMessages.some((x) => x.messageId === msgs[1].messageId), true, "MessageId of second message is different than expected");
            yield msgs[0].complete();
            yield msgs[1].complete();
            yield testPeekMsgsLength$3(receiverClient$5, 0);
        });
    }
    it("Partitioned Queue: Schedule multiple messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testScheduleMessages();
        });
    });
    it("Partitioned Topic: Schedule multiple messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testScheduleMessages();
        });
    });
    it("UnPartitioned Queue: Schedule multiple messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testScheduleMessages();
        });
    });
    it("UnPartitioned Topic: Schedule multiple messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testScheduleMessages();
        });
    });
    it("Partitioned Queue with Sessions: Schedule multiple messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testScheduleMessages(true);
        });
    });
    it("Partitioned Topic with Sessions: Schedule multiple messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testScheduleMessages(true);
        });
    });
    it("Unpartitioned Queue with Sessions: Schedule multiple messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testScheduleMessages(true);
        });
    });
    it("Unpartitioned Topic with Sessions: Schedule multiple messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testScheduleMessages(true);
        });
    });
});
describe("Cancel single Scheduled message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$5();
    }));
    function testCancelScheduleMessage(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const scheduleTime = new Date(Date.now() + 30000); // 30 seconds from now as anything less gives inconsistent results for cancelling
            const sequenceNumber = yield senderClient$5
                .getSender()
                .scheduleMessage(scheduleTime, testMessages);
            yield amqpCommon.delay(2000);
            yield senderClient$5.getSender().cancelScheduledMessage(sequenceNumber);
            // Wait until we are sure we have passed the schedule time
            yield amqpCommon.delay(30000);
            yield testPeekMsgsLength$3(receiverClient$5, 0);
        });
    }
    it("Partitioned Queue: Cancel single Scheduled message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testCancelScheduleMessage();
        });
    });
    it("Partitioned Topic: Cancel single Scheduled message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testCancelScheduleMessage();
        });
    });
    it("Unpartitioned Queue: Cancel single Scheduled message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testCancelScheduleMessage();
        });
    });
    it("Unpartitioned Topic: Cancel single Scheduled message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testCancelScheduleMessage();
        });
    });
    it("Partitioned Queue with Sessions: Cancel single Scheduled message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testCancelScheduleMessage(true);
        });
    });
    it("Partitioned Topic with Sessions: Cancel single Scheduled message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testCancelScheduleMessage(true);
        });
    });
    it("Unpartitioned Queue with Sessions: Cancel single Scheduled message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testCancelScheduleMessage(true);
        });
    });
    it("Unpartitioned Topic with Sessions: Cancel single Scheduled message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testCancelScheduleMessage(true);
        });
    });
});
describe("Cancel multiple Scheduled messages", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$5();
    }));
    function testCancelScheduleMessages(useSessions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = useSessions ? TestMessage.getSessionSample() : TestMessage.getSample();
            const sender = senderClient$5.getSender();
            const scheduleTime = new Date(Date.now() + 30000); // 30 seconds from now as anything less gives inconsistent results for cancelling
            const sequenceNumber1 = yield sender.scheduleMessage(scheduleTime, testMessage);
            const sequenceNumber2 = yield sender.scheduleMessage(scheduleTime, testMessage);
            yield amqpCommon.delay(2000);
            yield sender.cancelScheduledMessages([sequenceNumber1, sequenceNumber2]);
            // Wait until we are sure we have passed the schedule time
            yield amqpCommon.delay(30000);
            yield testPeekMsgsLength$3(receiverClient$5, 0);
        });
    }
    it("Partitioned Queue: Cancel scheduled messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testCancelScheduleMessages(false);
        });
    });
    it("Partitioned Topic: Cancel scheduled messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testCancelScheduleMessages(false);
        });
    });
    it("Unpartitioned Queue: Cancel scheduled messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testCancelScheduleMessages(false);
        });
    });
    it("Unpartitioned Topic: Cancel scheduled messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testCancelScheduleMessages(false);
        });
    });
    it("Partitioned Queue with Sessions: Cancel scheduled messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions, true);
            yield testCancelScheduleMessages(true);
        });
    });
    it("Partitioned Topic with Sessions: Cancel scheduled messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions, true);
            yield testCancelScheduleMessages(true);
        });
    });
    it("Unpartitioned Queue with Sessions: Cancel scheduled messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions, true);
            yield testCancelScheduleMessages(true);
        });
    });
    it("Unpartitioned Topic with Sessions: Cancel scheduled messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$5(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions, true);
            yield testCancelScheduleMessages(true);
        });
    });
});
describe("Message validations", function () {
    const longString = "A very very very very very very very very very very very very very very very very very very very very very very very very very long string.";
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$5();
    }));
    function validationTest(msg, expectedErrorMsg) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let actualErrorMsg = "";
            yield beforeEachTest$5(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            const sender = senderClient$5.getSender();
            yield sender.send(msg).catch((err) => {
                actualErrorMsg = err.message;
            });
            should$7.equal(actualErrorMsg, expectedErrorMsg, "Error not thrown as expected");
        });
    }
    it("Error thrown when the 'msg' is undefined", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest(undefined, "data is required and it must be of type object.");
        });
    });
    it("Error thrown when the 'contentType' is not of type 'string'", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", contentType: 1 }, "'contentType' must be of type 'string'.");
        });
    });
    it("Error thrown when the 'label' is not of type 'string'", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", label: 1 }, "'label' must be of type 'string'.");
        });
    });
    it("Error thrown when the 'to' is not of type 'string'", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", to: 1 }, "'to' must be of type 'string'.");
        });
    });
    it("Error thrown when the 'replyToSessionId' is not of type 'string'", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", replyToSessionId: 1 }, "'replyToSessionId' must be of type 'string'.");
        });
    });
    it("Error thrown when the 'timeToLive' is not of type 'number'", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", timeToLive: "" }, "'timeToLive' must be of type 'number'.");
        });
    });
    it("Error thrown when the 'scheduledEnqueueTimeUtc' is not an instance of a valid 'Date'", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", scheduledEnqueueTimeUtc: new Date("foo") }, "'scheduledEnqueueTimeUtc' must be an instance of a valid 'Date'.");
        });
    });
    it("Error thrown when the 'scheduledEnqueueTimeUtc' is a number(not an instance of 'Date')", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", scheduledEnqueueTimeUtc: 1 }, "'scheduledEnqueueTimeUtc' must be an instance of a valid 'Date'.");
        });
    });
    it("Error thrown when the length of 'partitionKey' is greater than 128 characters", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", partitionKey: longString }, "'partitionKey' must be of type 'string' with a length less than 128 characters.");
        });
    });
    it("Error thrown when the 'partitionKey' is not of type 'string'", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", partitionKey: 1 }, "'partitionKey' must be of type 'string' with a length less than 128 characters.");
        });
    });
    it("Error thrown when the length of 'viaPartitionKey' is greater than 128 characters.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", viaPartitionKey: longString }, "'viaPartitionKey' must be of type 'string' with a length less than 128 characters.");
        });
    });
    it("Error thrown when the 'viaPartitionKey' is not of type 'string'", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", viaPartitionKey: 1 }, "'viaPartitionKey' must be of type 'string' with a length less than 128 characters.");
        });
    });
    it("Error thrown when the 'sessionId' is not of type 'string'", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", sessionId: 1 }, "'sessionId' must be of type 'string'.");
        });
    });
    it("Error thrown when the length of 'sessionId' is greater than 128 characters", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", sessionId: longString }, "Length of 'sessionId' of type 'string' cannot be greater than 128 characters.");
        });
    });
    it("Error thrown when the 'messageId' is not a whole number.", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", messageId: 1.5 }, "'messageId' must be a whole integer. Decimal points are not allowed.");
        });
    });
    it("Error thrown when the length of 'messageId' is greater than 128 characters", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", messageId: longString }, "Length of 'messageId' of type 'string' cannot be greater than 128 characters.");
        });
    });
    it("Error thrown when the 'correlationId' is not an instance of 'string' | 'number' | Buffer", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield validationTest({ body: "", correlationId: [] }, "'correlationId' must be of type 'string' | 'number' | Buffer.");
        });
    });
});

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$8 = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
function testPeekMsgsLength$4(client, expectedPeekLength) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const peekedMsgs = yield client.peek(expectedPeekLength + 1);
        should$8.equal(peekedMsgs.length, expectedPeekLength, "Unexpected number of msgs found when peeking");
    });
}
let ns$7;
let senderClient$6;
let receiverClient$6;
let unexpectedError;
function unExpectedErrorHandler(err) {
    if (err) {
        unexpectedError = err;
    }
}
const testSessionId2 = "my-session2";
function beforeEachTest$6(senderType, sessionType) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // The tests in this file expect the env variables to contain the connection string and
        // the names of empty queue/topic/subscription that are to be tested
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$7 = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$7, senderType, sessionType);
        senderClient$6 = clients.senderClient;
        receiverClient$6 = clients.receiverClient;
        yield purge(receiverClient$6, TestMessage.sessionId);
        const peekedMsgs = yield receiverClient$6.peek();
        const receiverEntityType = receiverClient$6 instanceof QueueClient ? "queue" : "topic";
        if (peekedMsgs.length) {
            chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
        }
    });
}
function afterEachTest$6() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ns$7.close();
    });
}
describe("SessionReceiver with invalid sessionId", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$6();
    }));
    function test_batching() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSessionSample();
            yield senderClient$6.getSender().send(testMessage);
            let receiver = yield receiverClient$6.getSessionReceiver({
                sessionId: "non" + TestMessage.sessionId
            });
            let msgs = yield receiver.receiveBatch(1, 10);
            should$8.equal(msgs.length, 0, "Unexpected number of messages");
            yield receiver.close();
            receiver = yield receiverClient$6.getSessionReceiver();
            msgs = yield receiver.receiveBatch(1);
            should$8.equal(msgs.length, 1, "Unexpected number of messages");
            should$8.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$8.equal(msgs[0].body, testMessage.body, "MessageBody is different than expected");
            should$8.equal(msgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            yield msgs[0].complete();
            yield testPeekMsgsLength$4(receiverClient$6, 0);
        });
    }
    it("Partitioned Queue - Batch Receiver: no messages received for invalid sessionId", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield test_batching();
        });
    });
    it("Partitioned Subscription - Batch Receiver: no messages received for invalid sessionId", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield test_batching();
        });
    });
    it("Unpartitioned Queue - Batch Receiver: no messages received for invalid sessionId", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield test_batching();
        });
    });
    it("Unpartitioned Subscription - Batch Receiver: no messages received for invalid sessionId", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield test_batching();
        });
    });
    function test_streaming() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSessionSample();
            yield senderClient$6.getSender().send(testMessage);
            let receiver = yield receiverClient$6.getSessionReceiver({
                sessionId: "non" + TestMessage.sessionId
            });
            let receivedMsgs = [];
            receiver.receive((msg) => {
                receivedMsgs.push(msg);
                return Promise.resolve();
            }, unExpectedErrorHandler);
            yield amqpCommon.delay(2000);
            should$8.equal(receivedMsgs.length, 0, `Expected 0, received ${receivedMsgs.length} messages`);
            yield receiver.close();
            receiver = yield receiverClient$6.getSessionReceiver();
            receivedMsgs = [];
            receiver.receive((msg) => {
                should$8.equal(msg.body, testMessage.body, "MessageBody is different than expected");
                should$8.equal(msg.messageId, testMessage.messageId, "MessageId is different than expected");
                return msg.complete().then(() => {
                    receivedMsgs.push(msg);
                });
            }, unExpectedErrorHandler, { autoComplete: false });
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1);
            should$8.equal(msgsCheck, true, `Expected 1, received ${receivedMsgs.length} messages`);
            should$8.equal(unexpectedError, undefined, unexpectedError && unexpectedError.message);
            yield testPeekMsgsLength$4(receiverClient$6, 0);
        });
    }
    it("Partitioned Queue - Streaming Receiver: no messages received for invalid sessionId", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield test_streaming();
        });
    });
    it("Partitioned Subscription - Streaming Receiver: no messages received for invalid sessionId", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield test_streaming();
        });
    });
    it("Unpartitioned Queue - Streaming Receiver: no messages received for invalid sessionId", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield test_streaming();
        });
    });
    it("Unpartitioned Subscription - Streaming Receiver: no messages received for invalid sessionId", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield test_streaming();
        });
    });
});
describe("SessionReceiver with no sessionId", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$6();
    }));
    const testMessagesWithDifferentSessionIds = [
        {
            body: "hello1",
            messageId: `test message ${Math.random()}`,
            sessionId: TestMessage.sessionId
        },
        {
            body: "hello2",
            messageId: `test message ${Math.random()}`,
            sessionId: testSessionId2
        }
    ];
    function testComplete_batching() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sender = senderClient$6.getSender();
            yield sender.send(testMessagesWithDifferentSessionIds[0]);
            yield sender.send(testMessagesWithDifferentSessionIds[1]);
            let receiver = yield receiverClient$6.getSessionReceiver();
            let msgs = yield receiver.receiveBatch(2);
            should$8.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$8.equal(msgs.length, 1, "Unexpected number of messages");
            should$8.equal(testMessagesWithDifferentSessionIds.some((x) => msgs[0].body === x.body &&
                msgs[0].messageId === x.messageId &&
                msgs[0].sessionId === x.sessionId), true, "Received Message doesnt match any of the test messages");
            yield msgs[0].complete();
            yield receiver.close();
            receiver = yield receiverClient$6.getSessionReceiver();
            msgs = yield receiver.receiveBatch(2);
            should$8.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$8.equal(msgs.length, 1, "Unexpected number of messages");
            should$8.equal(testMessagesWithDifferentSessionIds.some((x) => msgs[0].body === x.body &&
                msgs[0].messageId === x.messageId &&
                msgs[0].sessionId === x.sessionId), true, "Received Message doesnt match any of the test messages");
            yield msgs[0].complete();
            yield testPeekMsgsLength$4(receiverClient$6, 0);
        });
    }
    it("Partitioned Queue: complete() removes message from random session", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield purge(receiverClient$6, testSessionId2);
            yield testComplete_batching();
        });
    });
    it("Partitioned Subscription: complete() removes message from random session", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield purge(receiverClient$6, testSessionId2);
            yield testComplete_batching();
        });
    });
    it("Unpartitioned Queue: complete() removes message from random session", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield purge(receiverClient$6, testSessionId2);
            yield testComplete_batching();
        });
    });
    it("Unpartitioned Subscription: complete() removes message from random session", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield purge(receiverClient$6, testSessionId2);
            yield testComplete_batching();
        });
    });
});
describe("Session State", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$6();
    }));
    function testGetSetState() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sender = senderClient$6.getSender();
            const testMessage = TestMessage.getSessionSample();
            yield sender.send(testMessage);
            let receiver = yield receiverClient$6.getSessionReceiver();
            let msgs = yield receiver.receiveBatch(2);
            should$8.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$8.equal(msgs.length, 1, "Unexpected number of messages");
            should$8.equal(msgs[0].body, testMessage.body, "MessageBody is different than expected");
            should$8.equal(msgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            should$8.equal(msgs[0].sessionId, testMessage.sessionId, "SessionId is different than expected");
            let testState = yield receiver.getState();
            should$8.equal(!!testState, false, "SessionState is different than expected");
            yield receiver.setState("new_state");
            testState = yield receiver.getState();
            should$8.equal(testState, "new_state", "SessionState is different than expected");
            yield receiver.close();
            receiver = yield receiverClient$6.getSessionReceiver();
            msgs = yield receiver.receiveBatch(2);
            should$8.equal(Array.isArray(msgs), true, "`ReceivedMessages` is not an array");
            should$8.equal(msgs.length, 1, "Unexpected number of messages");
            should$8.equal(msgs[0].body, testMessage.body, "MessageBody is different than expected");
            should$8.equal(msgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            should$8.equal(msgs[0].sessionId, testMessage.sessionId, "SessionId is different than expected");
            testState = yield receiver.getState();
            should$8.equal(testState, "new_state", "SessionState is different than expected");
            yield receiver.setState(""); // clearing the session-state
            yield msgs[0].complete();
            yield testPeekMsgsLength$4(receiverClient$6, 0);
        });
    }
    it("Partitioned Queue - Testing getState and setState", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield purge(receiverClient$6, testSessionId2);
            yield testGetSetState();
        });
    });
    it("Partitioned Subscription - Testing getState and setState", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield purge(receiverClient$6, testSessionId2);
            yield testGetSetState();
        });
    });
    it("Unpartitioned Queue - Testing getState and setState", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield purge(receiverClient$6, testSessionId2);
            yield testGetSetState();
        });
    });
    it("Unpartitioned Subscription - Testing getState and setState", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield purge(receiverClient$6, testSessionId2);
            yield testGetSetState();
        });
    });
});
describe("Second SessionReceiver for same sessionId", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$6();
    }));
    function testSecondSessionReceiverForSameSession() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sender = senderClient$6.getSender();
            const testMessage = TestMessage.getSessionSample();
            yield sender.send(testMessage);
            const firstReceiver = yield receiverClient$6.getSessionReceiver();
            should$8.equal(firstReceiver.sessionId, testMessage.sessionId, "MessageId is different than expected");
            let errorWasThrown = false;
            try {
                const secondReceiver = yield receiverClient$6.getSessionReceiver({
                    sessionId: testMessage.sessionId
                });
                if (secondReceiver) {
                    chai$1.assert.fail("Second receiver for same session id should not have been created");
                }
            }
            catch (error) {
                errorWasThrown =
                    error &&
                        error.message ===
                            `Close the current session receiver for sessionId ${testMessage.sessionId} before using "getSessionReceiver" to create a new one for the same sessionId`;
            }
            should$8.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    }
    it("Partitioned Queue - Second Session Receiver for same session id throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testSecondSessionReceiverForSameSession();
        });
    });
    it("Partitioned Subscription - Second Session Receiver for same session id throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testSecondSessionReceiverForSameSession();
        });
    });
    it("Unpartitioned Queue - Second Session Receiver for same session id throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testSecondSessionReceiverForSameSession();
        });
    });
    it("Unpartitioned Subscription - Second Session Receiver for same session id throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$6(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testSecondSessionReceiverForSameSession();
        });
    });
});

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$9 = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
function testPeekMsgsLength$5(client, expectedPeekLength) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const peekedMsgs = yield client.peek(expectedPeekLength + 1);
        should$9.equal(peekedMsgs.length, expectedPeekLength, "Unexpected number of msgs found when peeking");
    });
}
let ns$8;
let senderClient$7;
let receiverClient$7;
let sender$4;
let receiver$5;
let deadLetterClient$2;
let errorWasThrown$2;
let unexpectedError$1;
const maxDeliveryCount$1 = 10;
function unExpectedErrorHandler$1(err) {
    if (err) {
        unexpectedError$1 = err;
    }
}
function beforeEachTest$7(senderType, receiverType) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // The tests in this file expect the env variables to contain the connection string and
        // the names of empty queue/topic/subscription that are to be tested
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$8 = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$8, senderType, receiverType);
        senderClient$7 = clients.senderClient;
        receiverClient$7 = clients.receiverClient;
        if (receiverClient$7 instanceof QueueClient) {
            deadLetterClient$2 = ns$8.createQueueClient(Namespace.getDeadLetterQueuePath(receiverClient$7.entityPath));
        }
        if (receiverClient$7 instanceof SubscriptionClient) {
            deadLetterClient$2 = ns$8.createSubscriptionClient(Namespace.getDeadLetterTopicPath(senderClient$7.entityPath, receiverClient$7.subscriptionName), receiverClient$7.subscriptionName);
        }
        yield purge(receiverClient$7);
        yield purge(deadLetterClient$2);
        const peekedMsgs = yield receiverClient$7.peek();
        const receiverEntityType = receiverClient$7 instanceof QueueClient ? "queue" : "topic";
        if (peekedMsgs.length) {
            chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
        }
        const peekedDeadMsgs = yield deadLetterClient$2.peek();
        if (peekedDeadMsgs.length) {
            chai$1.assert.fail(`Please use an empty dead letter ${receiverEntityType} for integration testing`);
        }
        sender$4 = senderClient$7.getSender();
        receiver$5 = receiverClient$7.getReceiver();
        errorWasThrown$2 = false;
        unexpectedError$1 = undefined;
    });
}
function afterEachTest$7() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ns$8.close();
    });
}
describe("Streaming - Misc Tests", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$7();
    }));
    function testAutoComplete() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSample();
            yield sender$4.send(testMessage);
            const receivedMsgs = [];
            receiver$5.receive((msg) => {
                receivedMsgs.push(msg);
                should$9.equal(msg.body, testMessage.body, "MessageBody is different than expected");
                should$9.equal(msg.messageId, testMessage.messageId, "MessageId is different than expected");
                return Promise.resolve();
            }, unExpectedErrorHandler$1);
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1 && receivedMsgs[0].delivery.remote_settled === true);
            should$9.equal(msgsCheck, true, receivedMsgs.length !== 1
                ? `Expected 1, received ${receivedMsgs.length} messages`
                : "Message didnt get auto-completed in time");
            yield receiver$5.close();
            should$9.equal(unexpectedError$1, undefined, unexpectedError$1 && unexpectedError$1.message);
            should$9.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            yield testPeekMsgsLength$5(receiverClient$7, 0);
        });
    }
    it("Partitioned Queue: AutoComplete removes the message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testAutoComplete();
        });
    });
    it("Partitioned Subscription: AutoComplete removes the message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testAutoComplete();
        });
    });
    it("UnPartitioned Queue: AutoComplete removes the message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testAutoComplete();
        });
    });
    it("UnPartitioned Subscription: AutoComplete removes the message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testAutoComplete();
        });
    });
    function testManualComplete() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSample();
            yield sender$4.send(testMessage);
            const receivedMsgs = [];
            receiver$5.receive((msg) => {
                receivedMsgs.push(msg);
                should$9.equal(msg.body, testMessage.body, "MessageBody is different than expected");
                should$9.equal(msg.messageId, testMessage.messageId, "MessageId is different than expected");
                return Promise.resolve();
            }, unExpectedErrorHandler$1, { autoComplete: false });
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1);
            should$9.equal(msgsCheck, true, `Expected 1, received ${receivedMsgs.length} messages`);
            yield testPeekMsgsLength$5(receiverClient$7, 1);
            should$9.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            yield receivedMsgs[0].complete();
            yield receiver$5.close();
            should$9.equal(unexpectedError$1, undefined, unexpectedError$1 && unexpectedError$1.message);
            yield testPeekMsgsLength$5(receiverClient$7, 0);
        });
    }
    it("Partitioned Queue: Disabled autoComplete, no manual complete retains the message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testManualComplete();
        });
    });
    it("Partitioned Subscription: Disabled autoComplete, no manual complete retains the message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testManualComplete();
        });
    });
    it("UnPartitioned Queue: Disabled autoComplete, no manual complete retains the message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testManualComplete();
        });
    });
    it("UnPartitioned Subscription: Disabled autoComplete, no manual complete retains the message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testManualComplete();
        });
    });
});
describe("Streaming - Complete message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$7();
    }));
    function testComplete(autoComplete) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSample();
            yield sender$4.send(testMessage);
            const receivedMsgs = [];
            receiver$5.receive((msg) => {
                should$9.equal(msg.body, testMessage.body, "MessageBody is different than expected");
                should$9.equal(msg.messageId, testMessage.messageId, "MessageId is different than expected");
                return msg.complete().then(() => {
                    receivedMsgs.push(msg);
                });
            }, unExpectedErrorHandler$1, { autoComplete });
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1);
            should$9.equal(msgsCheck, true, `Expected 1, received ${receivedMsgs.length} messages`);
            yield receiver$5.close();
            should$9.equal(unexpectedError$1, undefined, unexpectedError$1 && unexpectedError$1.message);
            should$9.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            yield testPeekMsgsLength$5(receiverClient$7, 0);
        });
    }
    it("Partitioned Queue: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testComplete(false);
        });
    });
    it("Partitioned Subscription: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testComplete(false);
        });
    });
    it("UnPartitioned Queue: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testComplete(false);
        });
    });
    it("UnPartitioned Subscription: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testComplete(false);
        });
    });
    it("Partitioned Queue with autoComplete: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testComplete(true);
        });
    });
    it("Partitioned Subscription with autoComplete: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testComplete(true);
        });
    });
    it("UnPartitioned Queue with autoComplete: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testComplete(true);
        });
    });
    it("UnPartitioned Subscription with autoComplete: complete() removes message", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testComplete(true);
        });
    });
});
describe("Streaming - Abandon message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$7();
    }));
    function testMultipleAbandons() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSample();
            yield sender$4.send(testMessage);
            let checkDeliveryCount = 0;
            receiver$5.receive((msg) => {
                should$9.equal(msg.deliveryCount, checkDeliveryCount, "DeliveryCount is different than expected");
                return msg.abandon().then(() => {
                    checkDeliveryCount++;
                });
            }, unExpectedErrorHandler$1, { autoComplete: false });
            const deliveryCountFlag = yield checkWithTimeout(() => checkDeliveryCount === maxDeliveryCount$1);
            should$9.equal(deliveryCountFlag, true, "DeliveryCount is different than expected");
            yield receiver$5.close();
            should$9.equal(unexpectedError$1, undefined, unexpectedError$1 && unexpectedError$1.message);
            yield testPeekMsgsLength$5(receiverClient$7, 0); // No messages in the queue
            const deadLetterMsgs = yield deadLetterClient$2.getReceiver().receiveBatch(1);
            should$9.equal(Array.isArray(deadLetterMsgs), true, "`ReceivedMessages` is not an array");
            should$9.equal(deadLetterMsgs.length, 1, "Unexpected number of messages");
            should$9.equal(deadLetterMsgs[0].deliveryCount, maxDeliveryCount$1, "DeliveryCount is different than expected");
            should$9.equal(deadLetterMsgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            yield deadLetterMsgs[0].complete();
            yield testPeekMsgsLength$5(deadLetterClient$2, 0);
        });
    }
    it("Partitioned Queue: Multiple abandons until maxDeliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testMultipleAbandons();
        });
    });
    it("Partitioned Subscription: Multiple abandons until maxDeliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testMultipleAbandons();
        });
    });
    it("Unpartitioned Queue: Multiple abandons until maxDeliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testMultipleAbandons();
        });
    });
    it("Unpartitioned Subscription: Multiple abandons until maxDeliveryCount", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testMultipleAbandons();
        });
    });
});
describe("Streaming - Defer message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$7();
    }));
    function testDefer(autoComplete) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSample();
            yield sender$4.send(testMessage);
            let sequenceNum = 0;
            receiver$5.receive((msg) => {
                return msg.defer().then(() => {
                    sequenceNum = msg.sequenceNumber;
                });
            }, unExpectedErrorHandler$1, { autoComplete });
            const sequenceNumCheck = yield checkWithTimeout(() => sequenceNum !== 0);
            should$9.equal(sequenceNumCheck, true, "Either the message is not received or observed an unexpected SequenceNumber.");
            yield receiver$5.close();
            should$9.equal(unexpectedError$1, undefined, unexpectedError$1 && unexpectedError$1.message);
            receiver$5 = receiverClient$7.getReceiver();
            const deferredMsgs = yield receiver$5.receiveDeferredMessages([sequenceNum]);
            if (!deferredMsgs) {
                throw "No message received for sequence number";
            }
            should$9.equal(deferredMsgs[0].body, testMessage.body, "MessageBody is different than expected");
            should$9.equal(deferredMsgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            should$9.equal(deferredMsgs[0].deliveryCount, 1, "DeliveryCount is different than expected");
            yield deferredMsgs[0].complete();
            yield testPeekMsgsLength$5(receiverClient$7, 0);
        });
    }
    it("Partitioned Queue: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testDefer(false);
        });
    });
    it("Partitioned Subscription: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testDefer(false);
        });
    });
    it("UnPartitioned Queue: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testDefer(false);
        });
    });
    it("UnPartitioned Subscription: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testDefer(false);
        });
    });
    it("Partitioned Queue with autoComplete: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testDefer(true);
        });
    });
    it("Partitioned Subscription with autoComplete: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testDefer(true);
        });
    });
    it("UnPartitioned Queue with autoComplete: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testDefer(true);
        });
    });
    it("UnPartitioned Subscription with autoComplete: defer() moves message to deferred queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testDefer(true);
        });
    });
});
describe("Streaming - Deadletter message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$7();
    }));
    function testDeadletter(autoComplete) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSample();
            yield sender$4.send(testMessage);
            const receivedMsgs = [];
            receiver$5.receive((msg) => {
                return msg.deadLetter().then(() => {
                    receivedMsgs.push(msg);
                });
            }, unExpectedErrorHandler$1, { autoComplete });
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1);
            should$9.equal(msgsCheck, true, `Expected 1, received ${receivedMsgs.length} messages`);
            yield receiver$5.close();
            should$9.equal(unexpectedError$1, undefined, unexpectedError$1 && unexpectedError$1.message);
            should$9.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            yield testPeekMsgsLength$5(receiverClient$7, 0);
            const deadLetterMsgs = yield deadLetterClient$2.getReceiver().receiveBatch(1);
            should$9.equal(Array.isArray(deadLetterMsgs), true, "`ReceivedMessages` is not an array");
            should$9.equal(deadLetterMsgs.length, 1, "Unexpected number of messages");
            should$9.equal(deadLetterMsgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            yield deadLetterMsgs[0].complete();
            yield testPeekMsgsLength$5(deadLetterClient$2, 0);
        });
    }
    it("Partitioned Queue: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testDeadletter(false);
        });
    });
    it("Partitioned Subscription: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testDeadletter(false);
        });
    });
    it("UnPartitioned Queue: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testDeadletter(false);
        });
    });
    it("UnPartitioned Subscription: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testDeadletter(false);
        });
    });
    it("Partitioned Queue with autoComplete: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testDeadletter(true);
        });
    });
    it("Partitioned Subscription with autoComplete: deadLetter() moves message to deadletter", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testDeadletter(true);
        });
    });
    it("UnPartitioned Queue with autoComplete: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testDeadletter(true);
        });
    });
    it("UnPartitioned Subscription with autoComplete: deadLetter() moves message to deadletter queue", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testDeadletter(true);
        });
    });
});
describe("Streaming - Multiple Streaming Receivers", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$7();
    }));
    function testMultipleReceiveCalls() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            receiver$5.receive((msg) => {
                return msg.complete();
            }, unExpectedErrorHandler$1);
            yield amqpCommon.delay(1000);
            try {
                receiver$5.receive((msg) => {
                    return Promise.resolve();
                }, (err) => {
                    should$9.exist(err);
                });
            }
            catch (err) {
                errorWasThrown$2 = true;
                should$9.equal(!err.message.search("has already been created for the Subscription"), false, "ErrorMessage is different than expected");
            }
            should$9.equal(errorWasThrown$2, true, "Error thrown flag must be true");
        });
    }
    it("Partitioned Queue: Second Streaming Receiver call should fail if the first one is not stopped", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testMultipleReceiveCalls();
        });
    });
    it("Partitioned Subscription: Second Streaming Receiver call should fail if the first one is not stopped", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testMultipleReceiveCalls();
        });
    });
    it("UnPartitioned Queue: Second Streaming Receiver call should fail if the first one is not stopped", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testMultipleReceiveCalls();
        });
    });
    it("UnPartitioned Subscription: Second Streaming Receiver call should fail if the first one is not stopped", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testMultipleReceiveCalls();
        });
    });
});
describe("Streaming - Settle an already Settled message throws error", () => {
    afterEach(() => tslib_1.__awaiter(undefined, void 0, void 0, function* () {
        yield afterEachTest$7();
    }));
    const testError = (err) => {
        should$9.equal(err.message, "This message has been already settled.", "ErrorMessage is different than expected");
        errorWasThrown$2 = true;
    };
    function testSettlement(operation) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSample();
            yield sender$4.send(testMessage);
            const receivedMsgs = [];
            receiver$5.receive((msg) => {
                receivedMsgs.push(msg);
                return Promise.resolve();
            }, unExpectedErrorHandler$1);
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1 && receivedMsgs[0].delivery.remote_settled === true);
            should$9.equal(msgsCheck, true, receivedMsgs.length !== 1
                ? `Expected 1, received ${receivedMsgs.length} messages`
                : "Message didnt get auto-completed in time");
            should$9.equal(unexpectedError$1, undefined, unexpectedError$1 && unexpectedError$1.message);
            should$9.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            should$9.equal(receivedMsgs[0].body, testMessage.body, "MessageBody is different than expected");
            should$9.equal(receivedMsgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            yield testPeekMsgsLength$5(receiverClient$7, 0);
            if (operation === DispositionType.complete) {
                yield receivedMsgs[0].complete().catch((err) => testError(err));
            }
            else if (operation === DispositionType.abandon) {
                yield receivedMsgs[0].abandon().catch((err) => testError(err));
            }
            else if (operation === DispositionType.deadletter) {
                yield receivedMsgs[0].deadLetter().catch((err) => testError(err));
            }
            else if (operation === DispositionType.defer) {
                yield receivedMsgs[0].defer().catch((err) => testError(err));
            }
            should$9.equal(errorWasThrown$2, true, "Error thrown flag must be true");
        });
    }
    it("Partitioned Queue: complete() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testSettlement(DispositionType.complete);
        });
    });
    it("Partitioned Subscription: complete() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testSettlement(DispositionType.complete);
        });
    });
    it("UnPartitioned Queue: complete() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testSettlement(DispositionType.complete);
        });
    });
    it("UnPartitioned Subscription: complete() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testSettlement(DispositionType.complete);
        });
    });
    it("Partitioned Queue: abandon() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testSettlement(DispositionType.abandon);
        });
    });
    it("Partitioned Subscription: abandon() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testSettlement(DispositionType.abandon);
        });
    });
    it("UnPartitioned Queue: abandon() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testSettlement(DispositionType.abandon);
        });
    });
    it("UnPartitioned Subscription: abandon() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testSettlement(DispositionType.abandon);
        });
    });
    it("Partitioned Queue: defer() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testSettlement(DispositionType.defer);
        });
    });
    it("Partitioned Subscription: defer() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testSettlement(DispositionType.defer);
        });
    });
    it("UnPartitioned Queue: defer() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testSettlement(DispositionType.defer);
        });
    });
    it("UnPartitioned Subscription: defer() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testSettlement(DispositionType.defer);
        });
    });
    it("Partitioned Queue: deadLetter() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testSettlement(DispositionType.deadletter);
        });
    });
    it("Partitioned Subscription: deadLetter() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testSettlement(DispositionType.deadletter);
        });
    });
    it("UnPartitioned Queue: deadLetter() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testSettlement(DispositionType.deadletter);
        });
    });
    it("UnPartitioned Subscription: deadLetter() throws error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testSettlement(DispositionType.deadletter);
        });
    });
});
describe("Streaming - User Error", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$7();
    }));
    function testUserError() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield sender$4.send(TestMessage.getSample());
            const errorMessage = "Will we see this error message?";
            const receivedMsgs = [];
            receiver$5.receive((msg) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield msg.complete().then(() => {
                    receivedMsgs.push(msg);
                });
                throw new Error(errorMessage);
            }), unExpectedErrorHandler$1);
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1);
            should$9.equal(msgsCheck, true, `Expected 1, received ${receivedMsgs.length} messages.`);
            yield receiver$5.close();
            should$9.equal(unexpectedError$1 && unexpectedError$1.message, errorMessage, "User error did not surface.");
            should$9.equal(receivedMsgs.length, 1, "Unexpected number of messages");
        });
    }
    it("Partitioned Queue: onError handler is called for user error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testUserError();
        });
    });
    it("Partitioned Subscription: onError handler is called for user error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testUserError();
        });
    });
    it("UnPartitioned Queue: onError handler is called for user error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testUserError();
        });
    });
    it("UnPartitioned Subscription: onError handler is called for user error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testUserError();
        });
    });
});
describe("Streaming - maxConcurrentCalls", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$7();
    }));
    function testConcurrency(maxConcurrentCalls) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessages = [TestMessage.getSample(), TestMessage.getSample()];
            yield sender$4.sendBatch(testMessages);
            const settledMsgs = [];
            const receivedMsgs = [];
            receiver$5.receive((msg) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (receivedMsgs.length === 1) {
                    if ((!maxConcurrentCalls || maxConcurrentCalls === 1) && settledMsgs.length === 0) {
                        throw new Error("onMessage for the second message should not have been called before the first message got settled");
                    }
                }
                else {
                    if (maxConcurrentCalls && maxConcurrentCalls > 1 && settledMsgs.length !== 0) {
                        throw new Error("onMessage for the second message should have been called before the first message got settled");
                    }
                }
                receivedMsgs.push(msg);
                yield amqpCommon.delay(2000);
                yield msg.complete().then(() => {
                    settledMsgs.push(msg);
                });
            }), unExpectedErrorHandler$1, maxConcurrentCalls ? { maxConcurrentCalls } : {});
            yield checkWithTimeout(() => settledMsgs.length === 2);
            yield receiver$5.close();
            should$9.equal(unexpectedError$1, undefined, unexpectedError$1 && unexpectedError$1.message);
            should$9.equal(settledMsgs.length, 2, `Expected 2, received ${settledMsgs.length} messages.`);
        });
    }
    it("Partitioned Queue: no maxConcurrentCalls passed", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testConcurrency();
        });
    });
    it("Partitioned Queue: pass 1 for maxConcurrentCalls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testConcurrency(1);
        });
    });
    it("Partitioned Queue: pass 2 for maxConcurrentCalls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            yield testConcurrency(2);
        });
    });
    it("Unpartitioned Queue: no maxConcurrentCalls passed", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testConcurrency();
        });
    });
    it("Unpartitioned Queue: pass 1 for maxConcurrentCalls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testConcurrency(1);
        });
    });
    it("Unpartitioned Queue: pass 2 for maxConcurrentCalls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedQueue, ClientType.UnpartitionedQueue);
            yield testConcurrency(2);
        });
    });
    it("Partitioned Subscription: no maxConcurrentCalls passed", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testConcurrency();
        });
    });
    it("Partitioned Queue: pass 1 for maxConcurrentCalls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testConcurrency(1);
        });
    });
    it("Partitioned Queue: pass 2 for maxConcurrentCalls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.PartitionedTopic, ClientType.PartitionedSubscription);
            yield testConcurrency(2);
        });
    });
    it("Unpartitioned Subscription: no maxConcurrentCalls passed", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testConcurrency();
        });
    });
    it("Unpartitioned Queue: pass 1 for maxConcurrentCalls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testConcurrency(1);
        });
    });
    it("Unpartitioned Queue: pass 2 for maxConcurrentCalls", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$7(ClientType.UnpartitionedTopic, ClientType.UnpartitionedSubscription);
            yield testConcurrency(2);
        });
    });
});

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$a = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
function testPeekMsgsLength$6(client, expectedPeekLength) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const peekedMsgs = yield client.peek(expectedPeekLength + 1);
        should$a.equal(peekedMsgs.length, expectedPeekLength, "Unexpected number of msgs found when peeking");
    });
}
let ns$9;
let senderClient$8;
let receiverClient$8;
let deadLetterClient$3;
let sessionReceiver;
let sender$5;
let errorWasThrown$3;
let unexpectedError$2;
function unExpectedErrorHandler$2(err) {
    if (err) {
        unexpectedError$2 = err;
    }
}
function beforeEachTest$8(senderType, receiverType) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // The tests in this file expect the env variables to contain the connection string and
        // the names of empty queue/topic/subscription that are to be tested
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$9 = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$9, senderType, receiverType);
        senderClient$8 = clients.senderClient;
        receiverClient$8 = clients.receiverClient;
        sender$5 = senderClient$8.getSender();
        if (receiverClient$8 instanceof QueueClient) {
            deadLetterClient$3 = ns$9.createQueueClient(Namespace.getDeadLetterQueuePath(receiverClient$8.entityPath));
        }
        if (receiverClient$8 instanceof SubscriptionClient) {
            deadLetterClient$3 = ns$9.createSubscriptionClient(Namespace.getDeadLetterTopicPath(senderClient$8.entityPath, receiverClient$8.subscriptionName), receiverClient$8.subscriptionName);
        }
        yield purge(receiverClient$8, TestMessage.sessionId);
        yield purge(deadLetterClient$3);
        const peekedMsgs = yield receiverClient$8.peek();
        const receiverEntityType = receiverClient$8 instanceof QueueClient ? "queue" : "topic";
        if (peekedMsgs.length) {
            chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
        }
        sessionReceiver = yield receiverClient$8.getSessionReceiver({
            sessionId: TestMessage.sessionId
        });
        errorWasThrown$3 = false;
        unexpectedError$2 = undefined;
    });
}
function afterEachTest$8() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ns$9.close();
    });
}
describe("Sessions Streaming - Misc Tests", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$8();
    }));
    function testAutoComplete() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSessionSample();
            yield sender$5.send(testMessage);
            const receivedMsgs = [];
            sessionReceiver.receive((msg) => {
                receivedMsgs.push(msg);
                should$a.equal(msg.body, testMessage.body, "MessageBody is different than expected");
                should$a.equal(msg.messageId, testMessage.messageId, "MessageId is different than expected");
                return Promise.resolve();
            }, unExpectedErrorHandler$2);
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1 && receivedMsgs[0].delivery.remote_settled === true);
            should$a.equal(msgsCheck, true, receivedMsgs.length !== 1
                ? `Expected 1, received ${receivedMsgs.length} messages`
                : "Message didnt get auto-completed in time");
            should$a.equal(unexpectedError$2, undefined, unexpectedError$2 && unexpectedError$2.message);
            should$a.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            yield testPeekMsgsLength$6(receiverClient$8, 0);
        });
    }
    it("Partitioned Queue: AutoComplete removes the message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testAutoComplete();
        });
    });
    it("Partitioned Subscription: AutoComplete removes the message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testAutoComplete();
        });
    });
    it("UnPartitioned Queue: AutoComplete removes the message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testAutoComplete();
        });
    });
    it("UnPartitioned Subscription: AutoComplete removes the message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testAutoComplete();
        });
    });
    function testManualComplete() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSessionSample();
            yield sender$5.send(testMessage);
            const receivedMsgs = [];
            sessionReceiver.receive((msg) => {
                receivedMsgs.push(msg);
                should$a.equal(msg.body, testMessage.body, "MessageBody is different than expected");
                should$a.equal(msg.messageId, testMessage.messageId, "MessageId is different than expected");
                return Promise.resolve();
            }, unExpectedErrorHandler$2, { autoComplete: false });
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1);
            should$a.equal(msgsCheck, true, `Expected 1, received ${receivedMsgs.length} messages`);
            yield testPeekMsgsLength$6(receiverClient$8, 1);
            yield receivedMsgs[0].complete();
            should$a.equal(unexpectedError$2, undefined, unexpectedError$2 && unexpectedError$2.message);
            should$a.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            yield testPeekMsgsLength$6(receiverClient$8, 0);
        });
    }
    it("Partitioned Queue: Disabled autoComplete, no manual complete retains the message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testManualComplete();
        });
    });
    it("Partitioned Subscription: Disabled autoComplete, no manual complete retains the message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testManualComplete();
        });
    });
    it("UnPartitioned Queue: Disabled autoComplete, no manual complete retains the message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testManualComplete();
        });
    });
    it("UnPartitioned Subscription: Disabled autoComplete, no manual complete retains the message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testManualComplete();
        });
    });
});
describe("Sessions Streaming - Complete message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$8();
    }));
    function testComplete(autoComplete) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSessionSample();
            yield sender$5.send(testMessage);
            const receivedMsgs = [];
            sessionReceiver.receive((msg) => {
                should$a.equal(msg.body, testMessage.body, "MessageBody is different than expected");
                should$a.equal(msg.messageId, testMessage.messageId, "MessageId is different than expected");
                return msg.complete().then(() => {
                    receivedMsgs.push(msg);
                });
            }, unExpectedErrorHandler$2, { autoComplete });
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1);
            should$a.equal(msgsCheck, true, `Expected 1, received ${receivedMsgs.length} messages`);
            should$a.equal(unexpectedError$2, undefined, unexpectedError$2 && unexpectedError$2.message);
            should$a.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            yield testPeekMsgsLength$6(receiverClient$8, 0);
        });
    }
    it("Partitioned Queue: complete() removes message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testComplete(false);
        });
    });
    it("Partitioned Subscription: complete() removes message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testComplete(false);
        });
    });
    it("UnPartitioned Queue: complete() removes message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testComplete(false);
        });
    });
    it("UnPartitioned Subscription: complete() removes message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testComplete(false);
        });
    });
    it("Partitioned Queue with autoComplete: complete() removes message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testComplete(true);
        });
    });
    it("Partitioned Subscription with autoComplete: complete() removes message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testComplete(true);
        });
    });
    it("UnPartitioned Queue with autoComplete: complete() removes message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testComplete(true);
        });
    });
    it("UnPartitioned Subscription with autoComplete: complete() removes message(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testComplete(true);
        });
    });
});
describe("Sessions Streaming - Abandon message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$8();
    }));
    function testAbandon(autoComplete) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSessionSample();
            yield sender$5.send(testMessage);
            let abandonFlag = 0;
            yield sessionReceiver.receive((msg) => {
                return msg.abandon().then(() => {
                    abandonFlag = 1;
                    if (sessionReceiver.isReceivingMessages()) {
                        return sessionReceiver.close();
                    }
                    return Promise.resolve();
                });
            }, unExpectedErrorHandler$2, { autoComplete });
            const msgAbandonCheck = yield checkWithTimeout(() => abandonFlag === 1);
            should$a.equal(msgAbandonCheck, true, "Abandoning the message results in a failure");
            if (sessionReceiver.isReceivingMessages()) {
                yield sessionReceiver.close();
            }
            should$a.equal(unexpectedError$2, undefined, unexpectedError$2 && unexpectedError$2.message);
            sessionReceiver = yield receiverClient$8.getSessionReceiver({
                sessionId: TestMessage.sessionId
            });
            const receivedMsgs = yield sessionReceiver.receiveBatch(1);
            should$a.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            should$a.equal(receivedMsgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            should$a.equal(receivedMsgs[0].deliveryCount, 1, "DeliveryCount is different than expected");
            yield receivedMsgs[0].complete();
            yield testPeekMsgsLength$6(receiverClient$8, 0);
        });
    }
    it("Partitioned Queue: abandon() retains message with incremented deliveryCount(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testAbandon(false);
        });
    });
    it("Partitioned Subscription: abandon() retains message with incremented deliveryCount(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testAbandon(false);
        });
    });
    it("UnPartitioned Queue: abandon() retains message with incremented deliveryCount(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testAbandon(false);
        });
    });
    it("UnPartitioned Subscription: abandon() retains message with incremented deliveryCount(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testAbandon(false);
        });
    });
    it("Partitioned Queue with autoComplete: abandon() retains message with incremented deliveryCount(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testAbandon(true);
        });
    });
    it("Partitioned Subscription with autoComplete: abandon() retains message with incremented deliveryCount(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testAbandon(true);
        });
    });
    it("UnPartitioned Queue with autoComplete: abandon() retains message with incremented deliveryCount(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testAbandon(true);
        });
    });
    it("UnPartitioned Subscription with autoComplete: abandon() retains message with incremented deliveryCount(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testAbandon(true);
        });
    });
});
describe("Sessions Streaming - Defer message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$8();
    }));
    function testDefer(autoComplete) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSessionSample();
            yield sender$5.send(testMessage);
            let sequenceNum = 0;
            yield sessionReceiver.receive((msg) => {
                return msg.defer().then(() => {
                    sequenceNum = msg.sequenceNumber;
                });
            }, unExpectedErrorHandler$2, { autoComplete });
            const sequenceNumCheck = yield checkWithTimeout(() => sequenceNum !== 0);
            should$a.equal(sequenceNumCheck, true, "Either the message is not received or observed an unexpected SequenceNumber.");
            should$a.equal(unexpectedError$2, undefined, unexpectedError$2 && unexpectedError$2.message);
            const deferredMsg = yield sessionReceiver.receiveDeferredMessage(sequenceNum);
            if (!deferredMsg) {
                throw "No message received for sequence number";
            }
            should$a.equal(deferredMsg.body, testMessage.body, "MessageBody is different than expected");
            should$a.equal(deferredMsg.messageId, testMessage.messageId, "MessageId is different than expected");
            should$a.equal(deferredMsg.deliveryCount, 1, "DeliveryCount is different than expected");
            yield deferredMsg.complete();
            yield testPeekMsgsLength$6(receiverClient$8, 0);
        });
    }
    it("Partitioned Queue: defer() moves message to deferred queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testDefer(false);
        });
    });
    it("Partitioned Subscription: defer() moves message to deferred queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testDefer(false);
        });
    });
    it("UnPartitioned Queue: defer() moves message to deferred queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testDefer(false);
        });
    });
    it("UnPartitioned Subscription: defer() moves message to deferred queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testDefer(false);
        });
    });
    it("Partitioned Queue with autoComplete: defer() moves message to deferred queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testDefer(true);
        });
    });
    it("Partitioned Subscription with autoComplete: defer() moves message to deferred queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testDefer(true);
        });
    });
    it("UnPartitioned Queue with autoComplete: defer() moves message to deferred queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testDefer(true);
        });
    });
    it("UnPartitioned Subscription with autoComplete: defer() moves message to deferred queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testDefer(true);
        });
    });
});
describe("Sessions Streaming - Deadletter message", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$8();
    }));
    function testDeadletter(autoComplete) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSessionSample();
            yield sender$5.send(testMessage);
            let msgCount = 0;
            yield sessionReceiver.receive((msg) => {
                return msg.deadLetter().then(() => {
                    msgCount++;
                });
            }, unExpectedErrorHandler$2, { autoComplete });
            const msgsCheck = yield checkWithTimeout(() => msgCount === 1);
            should$a.equal(msgsCheck, true, `Expected 1, received ${msgCount} messages`);
            should$a.equal(unexpectedError$2, undefined, unexpectedError$2 && unexpectedError$2.message);
            should$a.equal(msgCount, 1, "Unexpected number of messages");
            yield testPeekMsgsLength$6(receiverClient$8, 0);
            const deadLetterMsgs = yield deadLetterClient$3.getReceiver().receiveBatch(1);
            should$a.equal(Array.isArray(deadLetterMsgs), true, "`ReceivedMessages` is not an array");
            should$a.equal(deadLetterMsgs.length, 1, "Unexpected number of messages");
            should$a.equal(deadLetterMsgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            yield deadLetterMsgs[0].complete();
            yield testPeekMsgsLength$6(deadLetterClient$3, 0);
        });
    }
    it("Partitioned Queue: deadLetter() moves message to deadletter queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testDeadletter(false);
        });
    });
    it("Partitioned Subscription: deadLetter() moves message to deadletter queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testDeadletter(false);
        });
    });
    it("UnPartitioned Queue: deadLetter() moves message to deadletter queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testDeadletter(false);
        });
    });
    it("UnPartitioned Subscription: deadLetter() moves message to deadletter queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testDeadletter(false);
        });
    });
    it("Partitioned Queue with autoComplete: deadLetter() moves message to deadletter queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testDeadletter(true);
        });
    });
    it("Partitioned Subscription with autoComplete: deadLetter() moves message to deadletter(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testDeadletter(true);
        });
    });
    it("UnPartitioned Queue with autoComplete: deadLetter() moves message to deadletter queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testDeadletter(true);
        });
    });
    it("UnPartitioned Subscription with autoComplete: deadLetter() moves message to deadletter queue(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testDeadletter(true);
        });
    });
});
describe("Sessions Streaming - Multiple Streaming Receivers", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$8();
    }));
    function testMultipleReceiveCalls() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield sessionReceiver.receive((msg) => {
                return msg.complete();
            }, unExpectedErrorHandler$2);
            yield amqpCommon.delay(5000);
            try {
                yield sessionReceiver.receive((msg) => {
                    return Promise.resolve();
                }, (err) => {
                    should$a.exist(err);
                });
            }
            catch (err) {
                errorWasThrown$3 = true;
                should$a.equal(!err.message.search("has already been created for the Subscription"), false, "ErrorMessage is different than expected");
            }
            should$a.equal(errorWasThrown$3, true, "Error thrown flag must be true");
        });
    }
    it("Partitioned Queue: Second Streaming Receiver call should fail if the first one is not stopped(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testMultipleReceiveCalls();
        });
    });
    it("Partitioned Subscription: Second Streaming Receiver call should fail if the first one is not stopped(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testMultipleReceiveCalls();
        });
    });
    it("UnPartitioned Queue: Second Streaming Receiver call should fail if the first one is not stopped(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testMultipleReceiveCalls();
        });
    });
    it("UnPartitioned Subscription: Second Streaming Receiver call should fail if the first one is not stopped(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testMultipleReceiveCalls();
        });
    });
});
describe("Sessions Streaming - Settle an already Settled message throws error", () => {
    afterEach(() => tslib_1.__awaiter(undefined, void 0, void 0, function* () {
        yield afterEachTest$8();
    }));
    const testError = (err) => {
        should$a.equal(err.message, "This message has been already settled.", "ErrorMessage is different than expected");
        errorWasThrown$3 = true;
    };
    function testSettlement(operation) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSessionSample();
            yield sender$5.send(testMessage);
            const receivedMsgs = [];
            sessionReceiver.receive((msg) => {
                receivedMsgs.push(msg);
                return Promise.resolve();
            }, unExpectedErrorHandler$2);
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1 && receivedMsgs[0].delivery.remote_settled === true);
            should$a.equal(msgsCheck, true, receivedMsgs.length !== 1
                ? `Expected 1, received ${receivedMsgs.length} messages`
                : "Message didnt get auto-completed in time");
            should$a.equal(unexpectedError$2, undefined, unexpectedError$2 && unexpectedError$2.message);
            should$a.equal(receivedMsgs.length, 1, "Unexpected number of messages");
            should$a.equal(receivedMsgs[0].body, testMessage.body, "MessageBody is different than expected");
            should$a.equal(receivedMsgs[0].messageId, testMessage.messageId, "MessageId is different than expected");
            yield testPeekMsgsLength$6(receiverClient$8, 0);
            if (operation === DispositionType.complete) {
                yield receivedMsgs[0].complete().catch((err) => testError(err));
            }
            else if (operation === DispositionType.abandon) {
                yield receivedMsgs[0].abandon().catch((err) => testError(err));
            }
            else if (operation === DispositionType.deadletter) {
                yield receivedMsgs[0].deadLetter().catch((err) => testError(err));
            }
            else if (operation === DispositionType.defer) {
                yield receivedMsgs[0].defer().catch((err) => testError(err));
            }
            should$a.equal(errorWasThrown$3, true, "Error thrown flag must be true");
        });
    }
    it("Partitioned Queue: complete() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testSettlement(DispositionType.complete);
        });
    });
    it("Partitioned Subscription: complete() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testSettlement(DispositionType.complete);
        });
    });
    it("UnPartitioned Queue: complete() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testSettlement(DispositionType.complete);
        });
    });
    it("UnPartitioned Subscription: complete() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testSettlement(DispositionType.complete);
        });
    });
    it("Partitioned Queue: abandon() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testSettlement(DispositionType.abandon);
        });
    });
    it("Partitioned Subscription: abandon() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testSettlement(DispositionType.abandon);
        });
    });
    it("UnPartitioned Queue: abandon() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testSettlement(DispositionType.abandon);
        });
    });
    it("UnPartitioned Subscription: abandon() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testSettlement(DispositionType.abandon);
        });
    });
    it("Partitioned Queue: defer() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testSettlement(DispositionType.defer);
        });
    });
    it("Partitioned Subscription: defer() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testSettlement(DispositionType.defer);
        });
    });
    it("UnPartitioned Queue: defer() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testSettlement(DispositionType.defer);
        });
    });
    it("UnPartitioned Subscription: defer() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testSettlement(DispositionType.defer);
        });
    });
    it("Partitioned Queue: deadLetter() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testSettlement(DispositionType.deadletter);
        });
    });
    it("Partitioned Subscription: deadLetter() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testSettlement(DispositionType.deadletter);
        });
    });
    it("UnPartitioned Queue: deadLetter() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testSettlement(DispositionType.deadletter);
        });
    });
    it("UnPartitioned Subscription: deadLetter() throws error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testSettlement(DispositionType.deadletter);
        });
    });
});
describe("Sessions Streaming - User Error", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$8();
    }));
    function testUserError() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const testMessage = TestMessage.getSessionSample();
            yield sender$5.send(testMessage);
            const errorMessage = "Will we see this error message?";
            const receivedMsgs = [];
            sessionReceiver.receive((msg) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield msg.complete().then(() => {
                    receivedMsgs.push(msg);
                });
                throw new Error(errorMessage);
            }), unExpectedErrorHandler$2);
            const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === 1);
            should$a.equal(msgsCheck, true, `Expected 1, received ${receivedMsgs.length} messages.`);
            yield sessionReceiver.close();
            should$a.equal(unexpectedError$2 && unexpectedError$2.message, errorMessage, "User error did not surface.");
            should$a.equal(receivedMsgs.length, 1, "Unexpected number of messages");
        });
    }
    it("Partitioned Queue: onError handler is called for user error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testUserError();
        });
    });
    it("Partitioned Subscription: onError handler is called for user error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testUserError();
        });
    });
    it("UnPartitioned Queue: onError handler is called for user error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testUserError();
        });
    });
    it("UnPartitioned Subscription: onError handler is called for user error(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testUserError();
        });
    });
});
describe("Sessions Streaming - maxConcurrentCalls", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$8();
    }));
    function testConcurrency(maxConcurrentCalls) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof maxConcurrentCalls === "number" &&
                (maxConcurrentCalls < 1 || maxConcurrentCalls > 2)) {
                chai$1.assert.fail("Sorry, the tests here only support cases when maxConcurrentCalls is set to 1 or 2");
            }
            const testMessages = [TestMessage.getSessionSample(), TestMessage.getSessionSample()];
            yield sender$5.sendBatch(testMessages);
            const settledMsgs = [];
            const receivedMsgs = [];
            sessionReceiver.receive((msg) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (receivedMsgs.length === 1) {
                    if ((!maxConcurrentCalls || maxConcurrentCalls === 1) && settledMsgs.length === 0) {
                        throw new Error("onMessage for the second message should not have been called before the first message got settled");
                    }
                }
                else {
                    if (maxConcurrentCalls === 2 && settledMsgs.length !== 0) {
                        throw new Error("onMessage for the second message should have been called before the first message got settled");
                    }
                }
                receivedMsgs.push(msg);
                yield amqpCommon.delay(2000);
                yield msg.complete().then(() => {
                    settledMsgs.push(msg);
                });
            }), unExpectedErrorHandler$2, maxConcurrentCalls ? { maxConcurrentCalls } : {});
            yield checkWithTimeout(() => settledMsgs.length === 2);
            yield sessionReceiver.close();
            should$a.equal(unexpectedError$2, undefined, unexpectedError$2 && unexpectedError$2.message);
            should$a.equal(settledMsgs.length, 2, `Expected 2, received ${settledMsgs.length} messages.`);
        });
    }
    it("Partitioned Queue: no maxConcurrentCalls passed(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testConcurrency();
        });
    });
    it("Partitioned Queue: pass 1 for maxConcurrentCalls(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testConcurrency();
        });
    });
    it("Partitioned Queue: pass 2 for maxConcurrentCalls(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedQueueWithSessions, ClientType.PartitionedQueueWithSessions);
            yield testConcurrency();
        });
    });
    it("Unpartitioned Queue: no maxConcurrentCalls passed(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testConcurrency();
        });
    });
    it("Unpartitioned Queue: pass 1 for maxConcurrentCalls(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testConcurrency();
        });
    });
    it("Unpartitioned Queue: pass 2 for maxConcurrentCalls(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedQueueWithSessions, ClientType.UnpartitionedQueueWithSessions);
            yield testConcurrency();
        });
    });
    it("Partitioned Subscription: no maxConcurrentCalls passed(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testConcurrency();
        });
    });
    it("Partitioned Queue: pass 1 for maxConcurrentCalls(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testConcurrency(1);
        });
    });
    it("Partitioned Queue: pass 2 for maxConcurrentCalls(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.PartitionedTopicWithSessions, ClientType.PartitionedSubscriptionWithSessions);
            yield testConcurrency(2);
        });
    });
    it("Unpartitioned Subscription: no maxConcurrentCalls passed(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testConcurrency();
        });
    });
    it("Unpartitioned Queue: pass 1 for maxConcurrentCalls(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testConcurrency(1);
        });
    });
    it("Unpartitioned Queue: pass 2 for maxConcurrentCalls(with sessions)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$8(ClientType.UnpartitionedTopicWithSessions, ClientType.UnpartitionedSubscriptionWithSessions);
            yield testConcurrency(2);
        });
    });
});

// Copyright (c) Microsoft Corporation. All rights reserved.
const should$b = chai$1.should();
main.config();
chai$1.use(chaiAsPromised);
// We need to remove rules before adding one because otherwise the existing default rule will let in all messages.
function removeAllRules(client) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const rules = yield client.getRules();
        for (let i = 0; i < rules.length; i++) {
            const rule = rules[i];
            yield client.removeRule(rule.name);
        }
    });
}
function testPeekMsgsLength$7(client, expectedPeekLength) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const peekedMsgs = yield client.peek(expectedPeekLength + 1);
        should$b.equal(peekedMsgs.length, expectedPeekLength, "Unexpected number of msgs found when peeking");
    });
}
let ns$a;
let subscriptionClient$1;
let topicClient$1;
function beforeEachTest$9(receiverType) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // The tests in this file expect the env variables to contain the connection string and
        // the names of empty queue/topic/subscription that are to be tested
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$a = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$a, ClientType.TopicFilterTestTopic, receiverType);
        topicClient$1 = clients.senderClient;
        subscriptionClient$1 = clients.receiverClient;
        yield purge(subscriptionClient$1);
        const peekedSubscriptionMsg = yield subscriptionClient$1.peek();
        if (peekedSubscriptionMsg.length) {
            chai$1.assert.fail("Please use an empty Subscription for integration testing");
        }
        if (receiverType === ClientType.TopicFilterTestSubscription) {
            yield removeAllRules(subscriptionClient$1);
        }
    });
}
function afterEachTest$9(clearRules = true) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (clearRules) {
            yield removeAllRules(subscriptionClient$1);
            yield subscriptionClient$1.addRule("DefaultFilter", true);
            const rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules.length, 1, "Unexpected number of rules");
            should$b.equal(rules[0].name, "DefaultFilter", "RuleName is different than expected");
        }
        yield ns$a.close();
    });
}
const data = [
    { Color: "blue", Quantity: 5, Priority: "low" },
    { Color: "red", Quantity: 10, Priority: "high" },
    { Color: "yellow", Quantity: 5, Priority: "low" },
    { Color: "blue", Quantity: 10, Priority: "low" },
    { Color: "blue", Quantity: 5, Priority: "high" },
    { Color: "blue", Quantity: 10, Priority: "low" },
    { Color: "red", Quantity: 5, Priority: "low" },
    { Color: "red", Quantity: 10, Priority: "low" },
    { Color: "red", Quantity: 5, Priority: "low" },
    { Color: "yellow", Quantity: 10, Priority: "high" },
    { Color: "yellow", Quantity: 5, Priority: "low" },
    { Color: "yellow", Quantity: 10, Priority: "low" }
];
function sendOrders() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const sender = topicClient$1.getSender();
        for (let index = 0; index < data.length; index++) {
            const element = data[index];
            const message = {
                body: "",
                messageId: `messageId: ${Math.random()}`,
                correlationId: `${element.Priority}`,
                label: `${element.Color}`,
                userProperties: {
                    color: `${element.Color}`,
                    quantity: element.Quantity,
                    priority: `${element.Priority}`
                },
                partitionKey: "dummy" // Ensures all messages go to same parition to make peek work reliably
            };
            yield sender.send(message);
        }
    });
}
function receiveOrders(client, expectedMessageCount) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let errorFromErrorHandler;
        const receivedMsgs = [];
        const receiver = client.getReceiver();
        receiver.receive((msg) => {
            return msg.complete().then(() => {
                receivedMsgs.push(msg);
            });
        }, (err) => {
            if (err) {
                errorFromErrorHandler = err;
            }
        });
        const msgsCheck = yield checkWithTimeout(() => receivedMsgs.length === expectedMessageCount);
        should$b.equal(msgsCheck, true, `Expected ${expectedMessageCount}, but received ${receivedMsgs.length} messages`);
        yield receiver.close();
        should$b.equal(errorFromErrorHandler, undefined, errorFromErrorHandler && errorFromErrorHandler.message);
        should$b.equal(receivedMsgs.length, expectedMessageCount, "Unexpected number of messages");
        return receivedMsgs;
    });
}
function addRules(ruleName, filter, sqlRuleActionExpression) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield subscriptionClient$1.addRule(ruleName, filter, sqlRuleActionExpression);
        const rules = yield subscriptionClient$1.getRules();
        should$b.equal(rules.length, 1, "Unexpected number of rules");
        should$b.equal(rules[0].name, ruleName, "Expected Rule not found");
        if (sqlRuleActionExpression) {
            should$b.equal(rules[0].action.expression, sqlRuleActionExpression, "Action not set on the rule.");
        }
    });
}
describe("addRule()", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$9(ClientType.TopicFilterTestSubscription);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$9();
    }));
    function BooleanFilter(bool) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield subscriptionClient$1.addRule("BooleanFilter", bool);
            const rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules.length, 1, "Unexpected number of rules");
            should$b.equal(rules[0].name, "BooleanFilter", "RuleName is different than expected");
        });
    }
    it("Add True Filter", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield BooleanFilter(true);
        });
    });
    it("Add False Filter", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield BooleanFilter(false);
        });
    });
    it("Add SQL filter", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield subscriptionClient$1.addRule("Priority_1", "(priority = 1 OR priority = 2) AND (sys.label LIKE '%String2')");
            const rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules.length, 1, "Unexpected number of rules");
            should$b.equal(rules[0].name, "Priority_1", "RuleName is different than expected");
        });
    });
    it("Add SQL filter and action", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield subscriptionClient$1.addRule("Priority_1", "(priority = 1 OR priority = 3) AND (sys.label LIKE '%String1')", "SET sys.label = 'MessageX'");
            const rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules.length, 1, "Unexpected number of rules");
            should$b.equal(rules[0].name, "Priority_1", "RuleName is different than expected");
        });
    });
    it("Add Correlation filter", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield subscriptionClient$1.addRule("Correlationfilter", {
                label: "red",
                correlationId: "high"
            });
            const rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules.length, 1, "Unexpected number of rules");
            should$b.equal(rules[0].name, "Correlationfilter", "RuleName is different than expected");
        });
    });
    it("Add rule with a name which matches with existing rule", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield subscriptionClient$1.addRule("Priority_1", "priority = 1");
            let errorWasThrown = false;
            try {
                yield subscriptionClient$1.addRule("Priority_1", "priority = 2");
            }
            catch (error) {
                errorWasThrown = true;
                should$b.equal(!error.message.search("Priority_1' already exists."), false, "ErrorMessage is different than expected");
                should$b.equal(error.name, "MessagingEntityAlreadyExistsError", "ErrorName is different than expected");
            }
            should$b.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("Add rule with no name", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errorWasThrown = false;
            try {
                yield subscriptionClient$1.addRule("", "priority = 2");
            }
            catch (error) {
                errorWasThrown = true;
                should$b.equal(!error.message.search("Rule name is missing"), false, "ErrorMessage is different than expected");
                should$b.equal(error.name, "Error", "ErrorName is different than expected");
            }
            should$b.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("Add rule with no filter", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errorWasThrown = false;
            try {
                yield subscriptionClient$1.addRule("Priority_1", "");
            }
            catch (error) {
                errorWasThrown = true;
                should$b.equal(!error.message.search("Filter is missing"), false, "ErrorMessage is different than expected");
                should$b.equal(error.name, "Error", "ErrorName is different than expected");
            }
            should$b.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("Add rule with a Boolean filter whose input is not a Boolean, SQL expression or a Correlation filter", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errorWasThrown = false;
            try {
                yield subscriptionClient$1.addRule("Priority_2", {});
            }
            catch (error) {
                errorWasThrown = true;
                should$b.equal(error.message, "Cannot add rule. Filter should be either a boolean, string or should have one of the Correlation filter properties.");
            }
            should$b.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("Adding a rule with a Correlation filter, error for irrelevant properties", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errorWasThrown = false;
            const filter = {
                correlationId: 1,
                invalidProperty: 2
            };
            try {
                yield subscriptionClient$1.addRule("Priority_2", filter);
            }
            catch (error) {
                errorWasThrown = true;
                should$b.equal(error.message, 'Cannot add rule. Given filter object has unexpected property "invalidProperty".');
            }
            should$b.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
});
describe("removeRule()", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$9(ClientType.TopicFilterTestSubscription);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$9();
    }));
    it("Removing non existing rule on a subscription that doesnt have any rules should throw error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errorWasThrown = false;
            try {
                yield subscriptionClient$1.removeRule("Priority_5");
            }
            catch (error) {
                should$b.equal(!error.message.search("Priority_5' could not be found"), false, "ErrorMessage is different than expected");
                should$b.equal(error.name, "MessagingEntityNotFoundError", "ErrorName is different than expected");
                errorWasThrown = true;
            }
            should$b.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
    it("Removing non existing rule on a subscription that has other rules should throw error", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errorWasThrown = false;
            try {
                yield subscriptionClient$1.addRule("Priority_1", "priority = 1");
                yield subscriptionClient$1.removeRule("Priority_5");
            }
            catch (error) {
                errorWasThrown = true;
            }
            should$b.equal(errorWasThrown, true, "Error thrown flag must be true");
        });
    });
});
describe("getRules()", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$9(ClientType.TopicFilterTestSubscription);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$9();
    }));
    it("Subscription with 0/1/multiple rules returns rules as expected", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules.length, 0, "Unexpected number of rules");
            const expr1 = "(priority = 1)";
            yield subscriptionClient$1.addRule("Priority_1", expr1);
            rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules.length, 1, "Unexpected number of rules");
            should$b.equal(rules[0].name, "Priority_1", "RuleName is different than expected");
            should$b.equal(JSON.stringify(rules[0].filter), JSON.stringify({ expression: expr1 }), "Filter-expression is different than expected");
            const expr2 = "(priority = 1 OR priority = 3) AND (sys.label LIKE '%String1')";
            yield subscriptionClient$1.addRule("Priority_2", expr2);
            rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules.length, 2, "Unexpected number of rules");
            should$b.equal(rules[0].name, "Priority_1", "RuleName is different than expected");
            should$b.equal(JSON.stringify(rules[0].filter), JSON.stringify({ expression: expr1 }), "Filter-expression is different than expected");
            should$b.equal(rules[1].name, "Priority_2", "RuleName is different than expected");
            should$b.equal(JSON.stringify(rules[1].filter), JSON.stringify({ expression: expr2 }), "Filter-expression is different than expected");
        });
    });
    it("Rule with SQL filter and action returns expected filter and action expression", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield subscriptionClient$1.addRule("Priority_1", "(priority = 1 OR priority = 3) AND (sys.label LIKE '%String1')", "SET sys.label = 'MessageX'");
            const rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules[0].name, "Priority_1", "RuleName is different than expected");
        });
    });
    it("Rule with Correlation filter returns expected filter", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield subscriptionClient$1.addRule("Correlationfilter", {
                label: "red",
                correlationId: "high"
            });
            const rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules[0].name, "Correlationfilter", "RuleName is different than expected");
            const expectedFilter = {
                correlationId: "high",
                label: "red",
                userProperties: []
            };
            should$b.equal(rules.length, 1, "Unexpected number of rules");
            rules.forEach((rule) => {
                should$b.equal(rule.filter.correlationId, expectedFilter.correlationId, "MessageId is different than expected");
                should$b.equal(rule.filter.label, expectedFilter.label, "Filter-label is different than expected");
                const userProperties = rule.filter.userProperties;
                should$b.equal(Array.isArray(userProperties), true, "`ReceivedMessages` is not an array");
                should$b.equal(userProperties.length, 0, "Unexpected number of messages");
            });
        });
    });
});
describe("Default Rule - Send/Receive", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$9(ClientType.TopicFilterTestDefaultSubscription);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$9(false);
    }));
    it("Default rule is returned for the subscription for which no rules were added", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules.length, 1, "Unexpected number of rules");
            should$b.equal(rules[0].name, "$Default", "RuleName is different than expected");
        });
    });
    it("Subscription with default filter receives all messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield sendOrders();
            yield receiveOrders(subscriptionClient$1, data.length);
            yield testPeekMsgsLength$7(subscriptionClient$1, 0);
        });
    });
});
describe("Boolean Filter - Send/Receive", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$9(ClientType.TopicFilterTestSubscription);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$9();
    }));
    function addFilterAndReceiveOrders(bool, client, expectedMessageCount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield subscriptionClient$1.addRule("BooleanFilter", bool);
            const rules = yield subscriptionClient$1.getRules();
            should$b.equal(rules.length, 1, "Unexpected number of rules");
            should$b.equal(rules[0].name, "BooleanFilter", "RuleName is different than expected");
            yield sendOrders();
            yield receiveOrders(client, expectedMessageCount);
            yield testPeekMsgsLength$7(client, 0);
        });
    }
    it("True boolean filter receives all messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield addFilterAndReceiveOrders(true, subscriptionClient$1, data.length);
        });
    });
    it("False boolean filter does not receive any messages", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield addFilterAndReceiveOrders(false, subscriptionClient$1, 0);
        });
    });
});
describe("Sql Filter - Send/Receive", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$9(ClientType.TopicFilterTestSubscription);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$9();
    }));
    it("SQL rule filter on the message properties", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield addRules("SQLMsgPropertyRule", "sys.label = 'red'");
            yield sendOrders();
            const dataLength = data.filter((x) => x.Color === "red").length;
            yield receiveOrders(subscriptionClient$1, dataLength);
            yield testPeekMsgsLength$7(subscriptionClient$1, 0);
        });
    });
    it("SQL rule filter on the custom properties", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield addRules("SQLCustomRule", "color = 'red'");
            yield sendOrders();
            const dataLength = data.filter((x) => x.Color === "red").length;
            yield receiveOrders(subscriptionClient$1, dataLength);
            yield testPeekMsgsLength$7(subscriptionClient$1, 0);
        });
    });
    it("SQL rule filter using AND operator ", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield addRules("SqlRuleWithAND", "color = 'blue' and quantity = 10");
            yield sendOrders();
            const dataLength = data.filter((x) => x.Color === "blue" && x.Quantity === 10).length;
            yield receiveOrders(subscriptionClient$1, dataLength);
            yield testPeekMsgsLength$7(subscriptionClient$1, 0);
        });
    });
    it("SQL rule filter using OR operator ", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield addRules("SqlRuleWithOR", "color = 'blue' OR quantity = 10");
            yield sendOrders();
            const dataLength = data.filter((x) => x.Color === "blue" || x.Quantity === 10).length;
            yield receiveOrders(subscriptionClient$1, dataLength);
            yield testPeekMsgsLength$7(subscriptionClient$1, 0);
        });
    });
    it("SQL rule filter with action with custom properties", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield addRules("SqlRuleWithAction", "color='blue'", "SET priority = 'High'");
            yield sendOrders();
            const dataLength = data.filter((x) => x.Color === "blue").length;
            const receivedMsgs = yield receiveOrders(subscriptionClient$1, dataLength);
            if (receivedMsgs[0].userProperties) {
                should$b.equal(receivedMsgs[0].userProperties.priority, "High", "Priority of the receivedMessage is different than expected");
            }
            else {
                chai$1.assert.fail("Received message doesnt have user properties");
            }
            yield testPeekMsgsLength$7(subscriptionClient$1, 0);
        });
    });
    // Standard subscription : Update message properties in random order.
    // Premium subscription : Update message properties only first time when you create new subscription.
    /* it("SQL rule filter with action with message properties", async function(): Promise<void> {
      await addRules("SqlRuleWithAction", "color='blue'", "SET sys.label = 'color blue'");
  
      await sendOrders();
      const dataLength = data.filter((x) => x.Color === "blue").length;
      const receivedMsgs = await receiveOrders(subscriptionClient, dataLength);
  
      if (receivedMsgs[0].userProperties) {
        should.equal(receivedMsgs[0].userProperties.priority, "High",
          "Priority of the receivedMessage is different than expected");
      } else {
        chai.assert.fail("Received message doesnt have user properties");
      }
      await testPeekMsgsLength(subscriptionClient, 0);
    });*/
});
describe("Correlation Filter - Send/Receive", function () {
    beforeEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield beforeEachTest$9(ClientType.TopicFilterTestSubscription);
    }));
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$9();
    }));
    it("Correlation filter on the message properties", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield addRules("CorrelationMsgPropertyRule", {
                label: "red"
            });
            yield sendOrders();
            const dataLength = data.filter((x) => x.Color === "red").length;
            yield receiveOrders(subscriptionClient$1, dataLength);
            yield testPeekMsgsLength$7(subscriptionClient$1, 0);
        });
    });
    it("Correlation filter on the custom properties", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield addRules("CorrelationCustomRule", {
                userProperties: {
                    color: "red"
                }
            });
            yield sendOrders();
            const dataLength = data.filter((x) => x.Color === "red").length;
            yield receiveOrders(subscriptionClient$1, dataLength);
            yield testPeekMsgsLength$7(subscriptionClient$1, 0);
        });
    });
    it("Correlation filter with SQL action", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield addRules("CorrelationRuleWithAction", {
                userProperties: {
                    color: "blue"
                }
            }, "SET priority = 'High'");
            yield sendOrders();
            const dataLength = data.filter((x) => x.Color === "blue").length;
            const receivedMsgs = yield receiveOrders(subscriptionClient$1, dataLength);
            if (receivedMsgs[0].userProperties) {
                should$b.equal(receivedMsgs[0].userProperties.priority, "High", "Priority of the receivedMessage is different than expected");
            }
            else {
                chai$1.assert.fail("Received message doesnt have user properties");
            }
            yield testPeekMsgsLength$7(subscriptionClient$1, 0);
        });
    });
});

// Copyright (c) Microsoft Corporation. All rights reserved.
main.config();
chai$1.use(chaiAsPromised);
let ns$b;
let senderClient$9;
let receiverClient$9;
let deadLetterClient$4;
let sender$6;
let receiver$6;
const numberOfMessages = 11000;
let consecutiveZeroMessagesCount = 0;
const maxConsecutiveZeroMessagesCount = 100;
let totalMessagesPurged = 0;
function beforeEachTest$a(senderType, receiverType, useSessions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // The tests in this file expect the env variables to contain the connection string and
        // the names of empty queue/topic/subscription that are to be tested
        if (!process.env.SERVICEBUS_CONNECTION_STRING) {
            throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
        }
        ns$b = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
        const clients = yield getSenderReceiverClients(ns$b, senderType, receiverType);
        senderClient$9 = clients.senderClient;
        receiverClient$9 = clients.receiverClient;
        if (receiverClient$9 instanceof QueueClient) {
            deadLetterClient$4 = ns$b.createQueueClient(Namespace.getDeadLetterQueuePath(receiverClient$9.entityPath));
        }
        if (receiverClient$9 instanceof SubscriptionClient) {
            deadLetterClient$4 = ns$b.createSubscriptionClient(Namespace.getDeadLetterTopicPath(senderClient$9.entityPath, receiverClient$9.subscriptionName), receiverClient$9.subscriptionName);
        }
        yield purge(receiverClient$9, useSessions ? TestMessage.sessionId : undefined);
        yield purge(deadLetterClient$4);
        const peekedMsgs = yield receiverClient$9.peek();
        const receiverEntityType = receiverClient$9 instanceof QueueClient ? "queue" : "topic";
        if (peekedMsgs.length) {
            chai$1.assert.fail(`Please use an empty ${receiverEntityType} for integration testing`);
        }
        const peekedDeadMsgs = yield deadLetterClient$4.peek();
        if (peekedDeadMsgs.length) {
            chai$1.assert.fail(`Please use an empty dead letter ${receiverEntityType} for integration testing`);
        }
        sender$6 = senderClient$9.getSender();
        receiver$6 = receiverClient$9.getReceiver({ receiveMode: ReceiveMode.receiveAndDelete });
    });
}
function afterEachTest$a() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield ns$b.close();
    });
}
describe("User Issue 1466", function () {
    afterEach(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield afterEachTest$a();
    }));
    function purgeMessages() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let continueLoop = true;
            const list = [];
            for (let index = 0; index < numberOfMessages; index++) {
                list.push("Message " + index);
            }
            // let count = 0;
            do {
                // if (count === 2) {
                //   break;
                // }
                // count++;
                console.log("#################################################################");
                // receiver = receiverClient.getReceiver({ receiveMode: ReceiveMode.receiveAndDelete });
                const messages = yield receiver$6.receiveBatch(numberOfMessages / 10, 5);
                messages.forEach((element) => {
                    list.splice(list.indexOf(element.body), 1);
                });
                const deletedMessagesCount = messages.length;
                totalMessagesPurged += deletedMessagesCount;
                console.log("totalMessagesPurged = " + totalMessagesPurged + ", yet to receive = " + list.length);
                if (deletedMessagesCount === 0) {
                    consecutiveZeroMessagesCount++;
                    console.log("yet to receive = " + list);
                    yield rheaPromise.delay(5000);
                    if (consecutiveZeroMessagesCount > maxConsecutiveZeroMessagesCount) {
                        continueLoop = false;
                    }
                }
                else {
                    consecutiveZeroMessagesCount = 0;
                }
                // await delay(3000);
                // await receiver.close();
            } while (continueLoop);
        });
    }
    it.only("User Issue 1466 - batch receiver", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$a(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            let batchMessages = [];
            let index = 0;
            for (index = 0; index < numberOfMessages; index++) {
                if (index % (numberOfMessages / 10) === 0) {
                    console.log(`Sending ${index}`);
                    if (batchMessages.length > 0)
                        yield sender$6.sendBatch(batchMessages);
                    batchMessages = [];
                }
                batchMessages.push({ body: "Message " + index });
                // await sender.send({ body: "Message " + index });
            }
            console.log(`Sending ${index}`);
            yield sender$6.sendBatch(batchMessages);
            console.log("Sending Done, waiting for 10 seconds...");
            yield rheaPromise.delay(10000);
            yield purgeMessages();
        });
    });
    it("User Issue 1466 - streaming receiver", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield beforeEachTest$a(ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            let batchMessages = [];
            let index = 0;
            for (index = 0; index < numberOfMessages; index++) {
                if (index % (numberOfMessages / 10) === 0) {
                    console.log(`Sending ${index}`);
                    if (batchMessages.length > 0)
                        yield sender$6.sendBatch(batchMessages);
                    batchMessages = [];
                }
                batchMessages.push({ body: "Message " + index });
            }
            console.log(`Sending ${index}`);
            yield sender$6.sendBatch(batchMessages);
            console.log("Sending Done, waiting for 10 seconds...");
            yield rheaPromise.delay(10000);
            const receivedMsgs = [];
            receiver$6.receive((msg) => {
                receivedMsgs.push(msg);
                console.log(msg.body);
                if (receivedMsgs.length % (numberOfMessages / 10) === 0) {
                    console.log("received " + receivedMsgs.length + " messages till now");
                }
                return Promise.resolve();
            }, (err) => {
                if (err) {
                    console.log(err.message);
                }
            });
            yield rheaPromise.delay(10000000);
            console.log(receivedMsgs.length);
        });
    });
    it("User Issue 1466 - no sending", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!process.env.SERVICEBUS_CONNECTION_STRING) {
                throw new Error("Define SERVICEBUS_CONNECTION_STRING in your environment before running integration tests.");
            }
            ns$b = Namespace.createFromConnectionString(process.env.SERVICEBUS_CONNECTION_STRING);
            const clients = yield getSenderReceiverClients(ns$b, ClientType.PartitionedQueue, ClientType.PartitionedQueue);
            receiverClient$9 = clients.receiverClient;
            yield purgeMessages();
        });
    });
});
//# sourceMappingURL=index.js.map
